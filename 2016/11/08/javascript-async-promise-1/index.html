<!DOCTYPE html><html><head><meta charset="utf-8"><title>비동기와 Promise #1 | NonBlock</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="JavaScript 의 비동기와 Promise 에 대해 알아보자"><meta property="og:type" content="article"><meta property="og:title" content="비동기와 Promise #1"><meta property="og:url" content="https://blog.javarouka.me/2016/11/08/javascript-async-promise-1/index.html"><meta property="og:site_name" content="NonBlock"><meta property="og:description" content="JavaScript 의 비동기와 Promise 에 대해 알아보자"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://blog.javarouka.me/asset/images/js.jpg"><meta property="article:published_time" content="2016-11-07T15:00:00.000Z"><meta property="article:modified_time" content="2020-09-22T04:18:02.866Z"><meta property="article:author" content="JavaRouka"><meta property="article:tag" content="javascript"><meta property="article:tag" content="ecmascript"><meta property="article:tag" content="promise"><meta property="article:tag" content="async"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.javarouka.me/asset/images/js.jpg"><link rel="apple-touch-icon" sizes="57x57" href="/fav/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/fav/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/fav/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/fav/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/fav/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/fav/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/fav/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/fav/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/fav/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/fav/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/fav/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/fav/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/fav/favicon-16x16.png"><link rel="manifest" href="/fav/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/fav/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><meta name="keywords" content="javascript,ecmascript,promise,async"><link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-85661914-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-85661914-1")</script><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"><script type="text/javascript">var __sauron=__sauron||[];__sauron.push(["pageview"]),function(){var e="https://analy1.sauroneyes.com/";__sauron.push(["setTrackerUrl",e+"analytics/"]);var a=document,r=a.createElement("script"),s=a.getElementsByTagName("script")[0];r.type="text/javascript",r.async=!0,r.defer=!0,r.src=e+"js/sauron.js",s.parentNode.insertBefore(r,s)}()</script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="alternate" href="/atom.xml" title="NonBlock" type="application/atom+xml">
</head><body><div class="site-wrapper"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">N </span><span class="b">o </span><span class="b">n </span><span class="b">B </span><span class="b">l </span><span class="w">o </span><span class="b">c </span><span class="w">k </span></a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><aside class="category-wrapper"><div class="site-category"><a class="nav flex-column-link" href="/categories/effective-java/">Effective Java</a><a class="nav flex-column-link" href="/categories/review/">Review</a><a class="nav flex-column-link" href="/categories/tech/">Tech</a><a class="nav flex-column-link" href="/categories/tech/translate/">Translate</a><a class="nav flex-column-link" href="/categories/book/">book</a><a class="nav flex-column-link" href="/categories/java/">java</a><a class="nav flex-column-link" href="/categories/java/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/javascript/">javascript</a><a class="nav flex-column-link" href="/categories/javascript/react/">react</a><a class="nav flex-column-link" href="/categories/javascript/react/redux-saga/">redux-saga</a><a class="nav flex-column-link" href="/categories/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/kotlin/tech/">tech</a><a class="nav flex-column-link" href="/categories/kotlin/tech/translate/">translate</a></div><div class="search"><form name="searchform" id="searchform" class="u-search-form"><input type="text" id="searchinput" class="u-search-input st-default-search-input" data-list-highlight="true" data-list-value-completion="true" placeholder="Looking for something in this blog?"> <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit"><span class="icon icon-search"></span></button></form></div><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-javascript-async-promise-1" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">비동기와 Promise #1</h1><h2 class="article-sub-title">JavaScript 의 비동기와 Promise 에 대해 알아보자</h2><div class="article-meta">Posted on <time class="article-time" datetime="2016-11-07T15:00:00.000Z" itemprop="datePublished">2016-11-08</time></div></header><div class="article-entry" itemprop="articleBody"><h2 id="Run-to-Completion"><a href="#Run-to-Completion" class="headerlink" title="Run to Completion"></a>Run to Completion</h2><p>다음 Java Code 가 있다.</p><p>어떤 웹 서버 프로그램에서 모듈의 사용 횟수를 카운팅하는 프로그램이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserProvider provider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> User found = provider.getById(id);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>모듈 호출시마다 사용 카운트 변수 <code>count</code> 를 1씩 증가시킨다. 언뜻 잘 동작할듯 싶지만 이 코드는 잘못된 통계를 내놓는다.</p><p><code>count++</code> 는 한줄로 써 있어 단일연산인 것처럼 보이지만, 실제로는</p><ul><li>count 값을 가져온다</li><li>1을 더한다</li><li>count 에 다시 할당한다</li></ul><p>라는 3단계의 작업이다.</p><p>다수의 요청 스레드가 저 메서드를 호출할 경우 한 스레드는 count 값을 가져온 상태에서 다른 스레드가 이미 값을 갱신한 상태가 될 수도 있다.</p><p>최신의 값을 반영하지 못한 상태에서 여러 스레드가 값을 갱신하기 시작하면 결국 저 count 는 실제 콜 횟수와는 다른 값을 보여줄 것이다.</p><p>하지만 JavaScript 에선 이런 일이 일어나지 않는다.</p><p>JavaScript 의 코드는 항상 <code>실행-완료 (Run-to-completion)</code> 을 보장하는데, 코드가 해석되고 수행될 때는 다른 코드의 실행이 되지 않는다는 실행 방식을 말한다.</p><p>위 코드를 javascript 버전이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">someModuleSystem</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> userProvider = someModuleSystem.require(<span class="string">&#x27;userProvider&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findUser</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> found = userProvider.findUser(id);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    someModuleSystem.export(<span class="string">&#x27;userStore&#x27;</span>, &#123;</span><br><span class="line">        findUser: findUser</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;)(someModuleSystem);</span><br></pre></td></tr></table></figure><blockquote><p>someModuleSystem 은 모듈 시스템(<a target="_blank" rel="external nofollow noopener noreferrer" href="http://requirejs.org/">RequireJS</a> 나 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://wiki.commonjs.org/wiki/CommonJS">commonjs</a> 등등…) 이라고 생각하자</p></blockquote><p>위 코드에서는 여러 타이머나 이벤트 등의 비동기성을 띈 코드에서 이 모듈의 <code>findUser</code> 를 호출해도 완벽하게 이 모듈의 콜 카운트를 보장할 것이다.</p><p>더 이해를 높이기 위해 다음 코드를 보자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.1초간 실행되는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workShortTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elapsed = (+<span class="keyword">new</span> <span class="built_in">Date</span>) + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>((+<span class="keyword">new</span> <span class="built_in">Date</span>) &lt; elapsed) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;workShortTime complete&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2초간 실행되는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLongTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elapsed = (+<span class="keyword">new</span> <span class="built_in">Date</span>) + (<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>((+<span class="keyword">new</span> <span class="built_in">Date</span>) &lt; elapsed) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;workLongTime complete&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(workShortTime, <span class="number">1</span>);</span><br><span class="line">    workLongTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setTimeout 으로 0.001초만 대기한 뒤에 <code>workShortTime</code> 를 수행하게 하고 다음 <code>workLongTime</code> 을 수행한다. 하지만 0.001초가 지났다고 해도 <code>workLongTime</code> 을 중단하고 <code>workShortTime</code> 가 먼저 실행되진 않는다.</p><p>2초 뒤 <code>workLongTime</code> 가 끝난 다음에야 <code>workShortTime</code> 이 수행될 것이다.<br>(실제 느린 PC 에서 이 코드를 브라우저가 화면을 그리고 있을때나, NodeJS 서버가 요청을 처리하는 도중 수행시키면 이 코드가 끝날 때까지 화면을 더이상 그리지 않고, NodeJS 서버라면 아무런 동작을 하지 않을 것이다.)</p><h2 id="javascript-의-친구들-몇명-소개"><a href="#javascript-의-친구들-몇명-소개" class="headerlink" title="javascript 의 친구들 몇명 소개"></a>javascript 의 친구들 몇명 소개</h2><h3 id="Call-Stack"><a href="#Call-Stack" class="headerlink" title="Call Stack"></a>Call Stack</h3><p>보통 프로그래밍 언어에서는 함수가 호출될 경우 함수들은 <strong>자신을 호출한 곳으로 되돌아갈 곳</strong> 을 알아야 한다. 이 정보는 대부분 stack 으로 관리된다.</p><blockquote><p>Java 프로그래머라면 이 정보를 보기 위한 Exception::printStacktrace 에 익숙할 것이다</p></blockquote><p>JavaScript 도 타 언어와 비슷한 Call Stack 이라는 게 존재하고, 메서드 수행 시마다 Stack 에 입력한 뒤 순차적으로 스택을 비워가며 실행한다.<br>스택이 다 비워질 경우 종료된다.</p><p>다음 코드를 보자. 먼저 스택을 보기 위한 코드부터 만들자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stacktrace 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stacktrace</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">        <span class="comment">// Error 구문을 지우기 위한 코드</span></span><br><span class="line">        <span class="built_in">console</span>.log(ex.stack.split(<span class="string">&#x27;\n&#x27;</span>).slice(<span class="number">1</span>).join(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 코드</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stepB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stepC();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    stacktrace();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;complete!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;시작합니다.&#x27;</span>, stacktrace())</span><br><span class="line"></span><br><span class="line">stepA();</span><br></pre></td></tr></table></figure><p>콘솔창에서 실행한다고 가정할 때 결과는 대충 아래와 같은 모습이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  at stacktrace (&lt;anonymous&gt;:3:15)</span><br><span class="line">  at &lt;anonymous&gt;:12:23</span><br><span class="line">시작합니다. undefined</span><br><span class="line">  at stacktrace (&lt;anonymous&gt;:3:15)</span><br><span class="line">  at stepC (&lt;anonymous&gt;:8:5)</span><br><span class="line">  at stepB (&lt;anonymous&gt;:5:5)</span><br><span class="line">  at stepA (&lt;anonymous&gt;:2:5)</span><br><span class="line">  at &lt;anonymous&gt;:14:1</span><br><span class="line">complete!</span><br></pre></td></tr></table></figure><p>제일 처음에는 호출 스택에는 아무것도 없다. 코드가 실행되면 그때 call stack 에 실행중인 함수(첫 코드 실행시에는 <code>runScript</code> 라고 하자) 가 삽입된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript ]</span><br></pre></td></tr></table></figure><p>첫 코드 실행후 만나는 함수(메서드)는 <code>stacktrace</code> 다. 이 함수가 실행되는 시점의 스택은</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript, stacktrace ]</span><br></pre></td></tr></table></figure><p>이다.</p><p>그리고 stacktrace 함수가 종료되면서 stacktrace 는 제거되고 다시 <code>console.log</code> 가 실행된다. 그 시점의 스택은 이렇다.</p><p>콘솔에는 다음과 같이 찍힐 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at stacktrace (&lt;anonymous&gt;:3:15)</span><br><span class="line">at &lt;anonymous&gt;:12:23</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript, <span class="built_in">console</span>.log ]</span><br></pre></td></tr></table></figure><p>그 다음 <code>console.log</code> 실행이 끝나고 콘솔에는 <code>시작합니다 undefined</code> 가 찍힌다. 그리고 스택은 다시 비워져 <code>runScript</code> 만 남는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript ]</span><br></pre></td></tr></table></figure><p>그 다음에는 <code>stepA</code> 함수가 실행되며 스택은 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript, stepA ]</span><br></pre></td></tr></table></figure><p>그 후 <code>stepB</code>, <code>stepC</code> 가 순차 실행되고 stepC 내부에서 <code>stacktrace</code> 를 실행하여 다음과 같이 된다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript, stepA, stepB, stepC, stacktrace ]</span><br></pre></td></tr></table></figure><p>stepC 에서 stacktrace, console.log 까지 실행한 뒤에 다시 stepB 로 돌아가는 시점의 stack 은 다음과 같을 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript, stepA, stepB ]</span><br></pre></td></tr></table></figure><p>그리고 순차적으로 함수가 종료되며, 스택이 모두 비워지고 더이상 수행할 코드도 없다면 <code>runScript</code> 까지 지워지며 프로그램은 끝난다!</p><p>javascript 실행기는 코드가 실행되면 Call Stack 을 조사한뒤 없어질 때까지 코드를 실행하고 스택이 전부 비워질 경우 실행을 종료하는 것이다. 중간에 새로운 함수 호출등으로 스택에 추가되어도 순차적으로 처리될 뿐, 작업 순서의 변동은 없다.</p><p>그렇다면 이벤트 핸들링 함수나 타이머 등의 작업, Ajax 등의 작업은 어떻게 일어날까.</p><h3 id="Event-Loop-Task-Queue"><a href="#Event-Loop-Task-Queue" class="headerlink" title="Event Loop, Task Queue"></a>Event Loop, Task Queue</h3><p>javascript 에는 여러 비동기성 작업들이 있다. 대충 목록을 나열하면 다음과 같은 것들이 있다</p><ul><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples">DOM 처리 (화면 갱신을 포함한다)</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/CSS/animation">애니메이션</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/AJAX">Ajax</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/en-US/Add-ons/Code_snippets/Timers">Timer</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/observe">Object Observer Callback</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a></li></ul><p>일련의 비동기 작업들은 Event Loop 와 엔진이 실행되는 한 무한정 도는 루프와 Task Queue 라는 것으로 처리된다.</p><p>코드로 표현하면 다음과 같다. (<em><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop">MDN 참고</a></em>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(queue.waitForMessage()) &#123;</span><br><span class="line">    queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Task Queue 를 감시하다가, Task가 있으면 꺼내서 javascript 의 Call Stack 에 추가한다.</p><p>javascript 는 Call Stack 에 작업이 추가되었으므로 그것을 실행하여 Call Stack 단락에서 본 같은 작업을 진행하게 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    timerA(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(stepB, <span class="number">100</span>) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepB</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stepC</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">stepA(); <span class="comment">// 1</span></span><br><span class="line">stepC(); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;complete!&quot;</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>위 코드는 주석에 쓰인 숫자 순서대로 실행된다.</p><p>3 부분이 실행되는 시점의 Call Stack 은 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript, stepA, timerA, <span class="built_in">setTimeout</span> ]</span><br></pre></td></tr></table></figure><p>이 되고 setTimeout 은 100 밀리세컨드 뒤의 타이머 작업 (<code>stepB</code> 함수를 Task Queue 에 넣는 작업) 을 준비한다.</p><p>그 뒤 6번째 주석의 코드가 수행 전 시점의 Call Stack 은 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript ]</span><br></pre></td></tr></table></figure><p>그리고 <code>console.log</code> 가 실행되고, 콘솔에 complete 를 출력한 뒤 종료되면 Call Stack 은 비워지고 일단 첫 코드 실행은 종료된다.</p><p>Event Loop 는 Call Stack 이 비워졌으므로 Task Queue 를 뒤져보지만 비어있는 상태이기에 다음 루프를 진행한다.(대기한다고 표현하는게 더 나을수도)</p><p>0,1초가 지난 뒤 (Event Loop는 그 동안에도 여러번의 루프가 진행되고 있었을 것이다) Task Queue 에 <code>stepB</code> 함수가 추가된다.</p><p>Call Stack 도 비어있는 상태이고 Job Queue 에도 작업이 있는 상태기에 Event Loop 는 Task Queue 에서 Task 을 하나 꺼내 실행시킨다.</p><p>실행된 함수는 Call Stack 에 추가되고 실행된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [ runScript, stepB ]</span><br></pre></td></tr></table></figure><p>최종적으로 <code>stepB</code> 도 종료되고 수행이 끝나면 더이상 수행할 게 없으므로 다시 javascript 실행을 중단하고 Event Loop 는 다시 Task Queue 에 새로운 Task 이 들어오는지 루프를 돌기 시작할 것이다.</p><p>이게 javascript가 비동기를 실행하는 방법이다.</p><p>재미있는 것은 이 Event Loop 는 ECMAScript 에 포함되는 스펙은 아니며 javascript 엔진을 구동하는 환경에서 제공한다는 점이다.</p><p>브라우저라면 브라우저에서 따로 구현된 모듈에서, NodeJS 의 경우에는 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://libuv.org/">libuv</a> 라는 라이브러리로 동작한다.</p><blockquote><p>이 이벤트 루프는 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://libuv.org/">libuv</a> 의 경우 다중 스레드로 구현되어 있다. ECMAScript 는 단일 스레드이고 javascript 환경은 다중 스레드라고 볼 수도 있겠다.</p></blockquote><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>타이머의 동작은 위에서 설명한 대로 지정된 밀리초 이후 작업을 수행하는 것이 아닌 Timer Api 에서 해당 시간만큼 지연된 뒤에 Job Queue 에 추가한다.</p><p>추가만 한다는게 중요한데, Task Queue 에 이미 적재된 Task 이 많거나 javascript 실행에서 상당한 지연이 발생할 경우 그 작업은 예정된 시간보다 늦게 실행될 수 있다.</p><p>setTimeout 과 setInterval 의 차이는 스케쥴링을 하느냐 안하느냐의 차이인데, <a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.bsidesoft.com/?p=399#%25ec%258b%25a4%25ed%2596%2589%25ed%2594%2584%25eb%25a0%2588%25ec%259e%2584">실제로는 미묘한 차이도 존재</a>하는 듯 하다.</p><h2 id="그렇다면-비동기-처리는"><a href="#그렇다면-비동기-처리는" class="headerlink" title="그렇다면 비동기 처리는"></a>그렇다면 비동기 처리는</h2><p>따로 준비된 비동기 처리구문은 결국 Task Queue 에 작업을 추가하고 Event Loop 의 한번의 루프에 처리되는 일을 여러 타이밍에 나눠 담는 것이 avascript 의 비동기 처리라고 볼 수 있다.</p><p>실제 javascript 의 Call Stack 에 추가되는 시점이 Event Loop 에 의해 여러 시점이 된다면 비동기 처리가 되는 것이다.</p><h2 id="장시간-수행-로직에-대한-비동기-처리-예제"><a href="#장시간-수행-로직에-대한-비동기-처리-예제" class="headerlink" title="장시간 수행 로직에 대한 비동기 처리 예제"></a>장시간 수행 로직에 대한 비동기 처리 예제</h2><p>가령 서버에서 100만개의 유저리스트를 가져왔고 이 User 리스트에 대해 색인이 필요한 상황이라고 해보자.(물론 클라이언트에서 이걸 처리하고 있는게 이상하긴 하다)</p><p>이걸 정직하게 처리하면 분명 사용자는 처리되기 전 까지 버튼을 클릭하거나 페이지를 이동하는 등의 작업을 하지 못하고 정지된 화면을 감상하게 될 것이다.</p><p>이럴 경우 비동기 처리를 활용하여 분산처리하는게 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userList = [ ... 백만개 ... ];</span><br><span class="line"><span class="keyword">var</span> indexed = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인덱싱 함수. 구현은 비워두었다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexing</span>(<span class="params">user</span>) </span>&#123;    </span><br><span class="line">    <span class="comment">// ... 어떤 인덱스 로직 구현 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실제 작업 진행 함수</span></span><br><span class="line"><span class="comment">// 유저리스트가 비어있다면 false 를 반환하고 있다면 인덱싱을 진행한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!userList.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> user = userList.pop();</span><br><span class="line">    indexing(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 작업자를 구동시키는 함수.</span></span><br><span class="line"><span class="comment">// 타이머를 0 밀리세컨드로 허용하는 최소 단위의 스케줄로 매번 주어진 인자를 수행한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">work</span>(<span class="params">fn, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> ret = fn();         </span><br><span class="line">            <span class="built_in">console</span>.log(ret ? <span class="string">&#x27;[&#x27;</span> + name + <span class="string">&#x27;] processed&#x27;</span> : <span class="string">&#x27;[&#x27;</span> + name + <span class="string">&#x27;] stop&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span>(ret) go();</span><br><span class="line">        &#125;, <span class="number">0</span>);    </span><br><span class="line">    &#125;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// work 함수로 분산 처리한다.</span></span><br><span class="line"><span class="comment">// 몇개를 더 수행해도 상관 없지만 지연 시간이 0초로 주어진 이상 그리 효율은 없을것 같다.</span></span><br><span class="line">work(process, <span class="string">&#x27;process-1&#x27;</span>);</span><br><span class="line"><span class="comment">// work(process, &#x27;process-2&#x27;);</span></span><br></pre></td></tr></table></figure><p>만일 인덱싱의 종료 조건을 알고 싶다면 <code>work</code> 함수의 종료 조건절 <code>if(ret) go()</code> 에 완료 콜백으로 처리하는 방법이 있다.</p><p><a href="/2016/11/09/javascript-async-promise-2/">다음 포스트</a> 에서 알아볼 Promise.all 과 같이 쓰면 코드가 더욱 간결해질 것이다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="/2016/11/08/javascript-async-promise-1/">비동기와 Promise 1</a></li><li><a href="/2016/11/09/javascript-async-promise-2/">비동기와 Promise 2</a></li><li><a href="/2016/11/12/javascript-async-promise-3/">비동기와 Promise 3</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.bsidesoft.com/?p=399">BsideSoft 공식 블로그 # 동기화 vs 비동기화 1</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.bsidesoft.com/?p=414">BsideSoft 공식 블로그 # 동기화 vs 비동기화 2</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.bsidesoft.com/?p=423">BsideSoft 공식 블로그 # 동기화 vs 비동기화 3</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/nhnent/fe.javascript/wiki/June-13-June-17,-2016">NHN Enter # 자바스크립트와 이벤트 루프</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.2ality.com/2014/09/es6-promises-foundations.html">2ality # ECMAScript 6 promises - foundations</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules">jakearchibald’s blog # Tasks, microtasks, queues and schedules</a></li></ul></div><div class="article-tags"><a class="tag-none-link" href="/tags/async/" rel="tag">async</a><a class="tag-none-link" href="/tags/ecmascript/" rel="tag">ecmascript</a><a class="tag-none-link" href="/tags/javascript/" rel="tag">javascript</a><a class="tag-none-link" href="/tags/promise/" rel="tag">promise</a></div><section id="comments" class="white-box"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></article><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5bf3f68d0a53e4d6"></script><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; <a href="https://blog.javarouka.me">NonBlock</a> Theme by <a href="http://artifact.me/" target="_blank" rel="external nofollow noopener noreferrer">Art Chen</a>.</div><div>Powered by <a target="_blank" href="https://hexo.io/" rel="external nofollow noopener noreferrer">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></aside></div><div class="site-sidebar"><div class="sidebar-switch clearfix show" style="display:block"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-bio" style="display:none"><div class="about-me clearfix"><div class="avatar"><img src="https://avatars2.githubusercontent.com/u/1438503?v=4&s=250"></div><div class="info"><a class="name dark-btn" href="/about">JavaRouka</a></div><div class="info"><span class="item desc">javarouka 의 기술블로그</span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="mailto:javarouka@gmail.com" class="mail" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-mail"></span> </a><a href="https://github.com/javarouka" class="github" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-github"></span> </a><a href="https://www.facebook.com/hanghui.i" class="facebook" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-facebook"></span></a></div><div class="shortcuts clearfix"><div class="bk"><a href="#header" class="dark-btn window-nav"><span class="icon icon-chevron-thin-up"></span> <span class="text">Back to Top</span></a></div><div class="bk"><a href="#footer" class="dark-btn window-nav"><span class="icon icon-chevron-thin-down"></span> <span class="text">Go to Bottom</span></a></div></div></div><div class="site-post-nav show" style="display:block"><div class="site-post-nav-box"><a href="/2016/11/09/javascript-async-promise-2/" class="icon icon-chevron-thin-left"><a href="/2016/11/09/javascript-async-promise-2/" class="site-post-nav-text">비동기와 Promise #2</a></a></div><div class="site-post-nav-box"><a href="/2016/03/31/let-const/" class="site-post-nav-text">ES2015 - var, const, let</a> <a href="/2016/03/31/let-const/" class="icon icon-chevron-thin-right"></a></div></div><div class="site-toc show" style="display:block"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Run-to-Completion"><span class="toc-number">1.</span> <span class="toc-text">Run to Completion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript-%EC%9D%98-%EC%B9%9C%EA%B5%AC%EB%93%A4-%EB%AA%87%EB%AA%85-%EC%86%8C%EA%B0%9C"><span class="toc-number">2.</span> <span class="toc-text">javascript 의 친구들 몇명 소개</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Call-Stack"><span class="toc-number">2.1.</span> <span class="toc-text">Call Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-Loop-Task-Queue"><span class="toc-number">2.2.</span> <span class="toc-text">Event Loop, Task Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timer"><span class="toc-number">2.3.</span> <span class="toc-text">Timer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EB%8A%94"><span class="toc-number">3.</span> <span class="toc-text">그렇다면 비동기 처리는</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%9E%A5%EC%8B%9C%EA%B0%84-%EC%88%98%ED%96%89-%EB%A1%9C%EC%A7%81%EC%97%90-%EB%8C%80%ED%95%9C-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC-%EC%98%88%EC%A0%9C"><span class="toc-number">4.</span> <span class="toc-text">장시간 수행 로직에 대한 비동기 처리 예제</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0"><span class="toc-number">5.</span> <span class="toc-text">참고</span></a></li></ol></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo"</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script type="text/javascript">var disqus_shortname="https-javarouka-github-io",disqus_url="https://blog.javarouka.me/2016/11/08/javascript-async-promise-1/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>