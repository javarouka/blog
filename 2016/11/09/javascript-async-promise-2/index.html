<!DOCTYPE html><html><head><meta charset="utf-8"><title>비동기와 Promise #2 | NonBlock</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="JavaScript 의 비동기와 Promise 에 대해 알아보자"><meta property="og:type" content="article"><meta property="og:title" content="비동기와 Promise #2"><meta property="og:url" content="https://blog.javarouka.me/2016/11/09/javascript-async-promise-2/index.html"><meta property="og:site_name" content="NonBlock"><meta property="og:description" content="JavaScript 의 비동기와 Promise 에 대해 알아보자"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://blog.javarouka.me/asset/images/js.jpg"><meta property="article:published_time" content="2016-11-08T15:00:00.000Z"><meta property="article:modified_time" content="2020-09-22T04:18:02.866Z"><meta property="article:author" content="JavaRouka"><meta property="article:tag" content="javascript"><meta property="article:tag" content="ecmascript"><meta property="article:tag" content="promise"><meta property="article:tag" content="async"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.javarouka.me/asset/images/js.jpg"><link rel="apple-touch-icon" sizes="57x57" href="/fav/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/fav/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/fav/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/fav/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/fav/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/fav/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/fav/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/fav/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/fav/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/fav/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/fav/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/fav/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/fav/favicon-16x16.png"><link rel="manifest" href="/fav/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/fav/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><meta name="keywords" content="javascript,ecmascript,promise,async"><link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-85661914-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-85661914-1")</script><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"><script type="text/javascript">var __sauron=__sauron||[];__sauron.push(["pageview"]),function(){var e="https://analy1.sauroneyes.com/";__sauron.push(["setTrackerUrl",e+"analytics/"]);var a=document,r=a.createElement("script"),s=a.getElementsByTagName("script")[0];r.type="text/javascript",r.async=!0,r.defer=!0,r.src=e+"js/sauron.js",s.parentNode.insertBefore(r,s)}()</script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="alternate" href="/atom.xml" title="NonBlock" type="application/atom+xml">
</head><body><div class="site-wrapper"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">N </span><span class="w">o </span><span class="b">n </span><span class="b">B </span><span class="b">l </span><span class="w">o </span><span class="b">c </span><span class="w">k </span></a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><aside class="category-wrapper"><div class="site-category"><a class="nav flex-column-link" href="/categories/effective-java/">Effective Java</a><a class="nav flex-column-link" href="/categories/review/">Review</a><a class="nav flex-column-link" href="/categories/tech/">Tech</a><a class="nav flex-column-link" href="/categories/tech/translate/">Translate</a><a class="nav flex-column-link" href="/categories/book/">book</a><a class="nav flex-column-link" href="/categories/java/">java</a><a class="nav flex-column-link" href="/categories/java/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/javascript/">javascript</a><a class="nav flex-column-link" href="/categories/javascript/react/">react</a><a class="nav flex-column-link" href="/categories/javascript/react/redux-saga/">redux-saga</a><a class="nav flex-column-link" href="/categories/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/kotlin/tech/">tech</a><a class="nav flex-column-link" href="/categories/kotlin/tech/translate/">translate</a></div><div class="search"><form name="searchform" id="searchform" class="u-search-form"><input type="text" id="searchinput" class="u-search-input st-default-search-input" data-list-highlight="true" data-list-value-completion="true" placeholder="Looking for something in this blog?"> <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit"><span class="icon icon-search"></span></button></form></div><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-javascript-async-promise-2" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">비동기와 Promise #2</h1><h2 class="article-sub-title">JavaScript 의 비동기와 Promise 에 대해 알아보자</h2><div class="article-meta">Posted on <time class="article-time" datetime="2016-11-08T15:00:00.000Z" itemprop="datePublished">2016-11-09</time></div></header><div class="article-entry" itemprop="articleBody"><p><a href="/2016/11/08/javascript-async-promise-1/">전 포스트</a> 에 이은 글이다.</p><h2 id="그동안-우리가-해오던-미래일의-처리"><a href="#그동안-우리가-해오던-미래일의-처리" class="headerlink" title="그동안 우리가 해오던 미래일의 처리"></a>그동안 우리가 해오던 미래일의 처리</h2><p>온라인 쇼핑을 하다보면 주문서에 택배기사에게 전할 말을 기록하는 공간이 있다. 보통 그곳에는 이렇게 적는 사람이 많을것이다 (나는 대부분 아래와 같이 적어둔다.)</p><blockquote><p>택배 완료전에 전화주세요.</p></blockquote><p>지금은 택배가 오지 않았지만 <code>택배가 올 미래</code> 에 <code>전화해달라</code> 는 처리를 부탁하고 있는 것이다.</p><p>물건을 주문한 사람은 택배가 올 때까지 마냥 기다릴 필요가 없고 다른일을 하다가 택배 도착 전 오는 전화를 받을 수 있다. 택배를 받으려고 택배직원을 아무것도 안하고 마냥 기다리려는 사람은 없을것이다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> goods = goodsOnDelivery(); <span class="comment">// 배달될 때까지 기다려야한다!</span></span><br><span class="line">enjoyLife(goods); <span class="comment">// 만일 배달되지 않는다면 인생을 못즐길 것이다.</span></span><br></pre></td></tr></table></figure><h3 id="콜백함수"><a href="#콜백함수" class="headerlink" title="콜백함수"></a>콜백함수</h3><p>보통 이런 경우에는 비동기 함수와 콜백을 같이 쓴다. 아래와 같은 방식이다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배달될 경우에 수행할 작업을 콜백으로 전달해둔다.</span></span><br><span class="line">goodsOnDeliveryAsync(<span class="function"><span class="keyword">function</span>(<span class="params">goods</span>) </span>&#123; <span class="comment">// 콜백!</span></span><br><span class="line">    enjoyLifeByGoods(goods);</span><br><span class="line">&#125;);</span><br><span class="line">enjoyLifeByExistsGoods();</span><br></pre></td></tr></table></figure><p>배송을 시키고, 다른걸로 놀다 (enjoyLifeByExistsGoods) 가 배송되면 배송된 걸로 노는 것 (enjoyLifeByGoods) 이다.</p><p>물론 실행 순서는 <code>goodsOnDeliveryAsync -&gt; enjoyLifeByExistsGoods -&gt; enjoyLifeByGoods</code>.</p><h3 id="콜백의-문제점"><a href="#콜백의-문제점" class="headerlink" title="콜백의 문제점"></a>콜백의 문제점</h3><p>여기서 조금 더 생각해보자.</p><p><code>goodsOnDeliveryAsync</code> 는 자신이 맡은 배송 외에도, 추가적으로 자신과는 전혀 관계가 없는 콜백 함수를 처리할 임무를 맡고 있다.</p><p>콜백으로 전달된 인자의 유효성 검증은 물론, 예외가 나든 오류가 나든 반드시 콜백을 호출해줘야 한다.</p><p>또, 콜백을 다수 처리해야 할 경우에도 문제가 된다.</p><p>이렇게 콜백을 지정할수도 있다. 하지만 별로 좋아보이진 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc(<span class="function"><span class="keyword">function</span>(<span class="params">goods</span>) </span>&#123;</span><br><span class="line">    callback1(goods);</span><br><span class="line">    callback2(goods);</span><br><span class="line">    callback3(goods);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>물론 콜백안에 함수 셋을 전달할 수도 있지만 가독성 면에서 그리 좋은 방법은 아니다. 게다가, callback1 에서 예외가 던져질 경우 나머지 콜백들은 수행조차 하지 못한다.</p><p>더 심각한건, 만일 콜백을 받는 함수에서 어떤 문제가 발생하여 콜백을 실행하지 않을수도 있다.</p><p>위에서 본 <code>goodsOnDeliveryAsync</code> 함수는 내가 만든 함수이기에 문제가 발생해도 수정이 가능하지만, 만일 타 팀이나 외부 라이브러리의 콜백을 사용한다면 그 함수를 신뢰할 수 있는지는 고민해볼 문제다.</p><p>콜백이라는 것은 결국 내 코드가 다른 로직에서 수행되는 조그만 제어의 역전 (IoC) 이 일어난다고 보면 된다.</p><ul><li>타겟 함수에 복수의 핸들러 전달이 깔끔하지 못하다.</li><li>타겟 함수에서 자신과는 관계없는 콜백 함수의 유효성 체크를 담당한다.</li><li>타겟 함수가 어떤 이유로 콜백을 한번도 호출하지 않을 수 있다.</li><li>타겟 함수가 어떤 이유로 콜백을 여러번 호출할수도 있다.</li><li>타겟 함수에서 발생하는 오류 처리 시 콜백을 주게 된다면 서로간 코드가 수정된다.</li></ul><p>이런걸 방지하기 위해 실행할 함수는 자신의 로직 외에도, 위의 내용을 전부 방어할 자신의 실제 업무와는 관계없는 코드들로 범벅이 될 것이다.</p><p>이럴땐 앞서간 선배들은 관심사의 분리 (<a target="_blank" rel="external nofollow noopener noreferrer" href="https://medium.com/@smartbosslee/%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98-%EB%B6%84%EB%A6%AC-separation-of-concerns-soc-8a8d09df066d#.5ky43hl7n">참고</a>) 를 이야기한다.</p><p>서로의 두 흐름 사이에 메신저 역할의 인터페이스나 매니저를 두는 방향으로 한번 구현해보자</p><p>수도 코드로는 대충 이런 식으로</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">실행기(실제로직).인터페이스(콜백).에러인터페이스(에러핸들러)</span><br></pre></td></tr></table></figure><p>아래는 구현 코드.</p><p>뭔가 장황해 보이고 장점이 없어 보이지만, 이 코드는 한번 잘 구현해둘 경우 다시는 볼일이 없으니 괜찮다(?).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>job 비동기 함수</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>callback 등록 인터페이스</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AsyncRunner</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ms = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">var</span> future = [];</span><br><span class="line">    <span class="keyword">var</span> errorHandler = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> executed = <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 비동기 함수에서 콜백을 실행한다.</span></span><br><span class="line">    <span class="comment">// 유효성 검사를 할 필요가 없이 확실한 함수를 전달한다.</span></span><br><span class="line">    job(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 이미 수행되었거나 실행할 작업이 없어도 중단한다.</span></span><br><span class="line">        <span class="keyword">if</span>(executed || !future.length) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Go.</span></span><br><span class="line">            future.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line">                job(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 에러가 나면 지정된 에러 핸들러를 실행하고 중단한다.</span></span><br><span class="line">            <span class="keyword">return</span> errorHandler(<span class="keyword">new</span> <span class="built_in">Error</span>(error));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            executed = <span class="literal">true</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">goods</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 미래에 처리할 작업을 등록하는 메서드를 반환한다</span></span><br><span class="line">          ok: <span class="function"><span class="keyword">function</span>(<span class="params">job</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(job) future.push(job);</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">          &#125;,</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 에러 핸들러를 등록한다.</span></span><br><span class="line">          error: <span class="function"><span class="keyword">function</span>(<span class="params">_errorHandler</span>) </span>&#123;</span><br><span class="line">              errorHandler = errorHandler || _errorHandler;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 사용해보자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 러너로 실행한다!</span></span><br><span class="line"><span class="keyword">new</span> AsyncRunner(goodsOnDeliveryAsync)</span><br><span class="line">    .ok(enjoyLifeByGoods)</span><br><span class="line">    .ok(presentGoods)</span><br><span class="line">    .error(crySadLife)</span><br></pre></td></tr></table></figure><p><code>asyncRunner</code> 함수의 신뢰성만 유지되는 한 타겟 함수와 콜백의 실행 로직은 서로 겹치지 않게 된다.</p><p>제어 역전 포인트를 아예 분리해버렸고, 한번 실행된 뒤 다시 콜백을 수행할일도 없이 방어로직을 넣어두었다.</p><p>코드가 읽기 간결해지는건 덤이다.</p><p>아, 위 코드에서는 <strong>한번도 실행하지 않음</strong> 에 대해서는 처리하지 않았는데, <code>ok</code>, <code>error</code> 이외에 <code>timeout</code> 같은 인터페이스를 공개해서 내부적으로 타이머를 돌려 executed 변수를 갱신하면서 오류 핸들러를 호출해주는 식으로 구현하면 될 것이다.</p><h2 id="그래서-Promise-는-뭔데"><a href="#그래서-Promise-는-뭔데" class="headerlink" title="그래서 Promise 는 뭔데?"></a>그래서 Promise 는 뭔데?</h2><p>사설이 길었다. 이제부터 제목에 맞는 내용이다.</p><p>Promise 는 JavaScript 에서 여러 방법으로 수행하던 비동기 처리에 대한 표준이다. 지금 (now) 은 아니지만 나중 (future) 에 처리될 것으로 생각되는 처리를 표현할 수 있다.</p><p>Promise 는 꽤 단순한(해 보이는) <a target="_blank" rel="external nofollow noopener noreferrer" href="https://promisesaplus.com/">Promise/A Plus</a> 스펙에 맞춰 구현되어 있으며, ES2015 에서 표준으로 정해지기 전에도 여러 오픈소스 라이브러리 들이 이 표준을 구현하였고 사용되는 것들도 꽤 많다.</p><p>ES2015 에서는 언어 자체에 Promise 를 Native 로 지원하게 되어서 위의 라이브러리를 쓰지 않고도 편하게 Promise 를 사용할 수 있고, 추가적으로 위 라이브러리를 써서 유틸성도 얻을 수 있다.</p><h3 id="기본"><a href="#기본" class="headerlink" title="기본"></a>기본</h3><p>기본 사용법은 다음과 같다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>([FactoryFunctionExpression])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FactoryFunctionExpression</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// implementation ...</span></span><br><span class="line">    <span class="comment">// call resolve([val]) or reject([val])</span></span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilledValue</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... fulfilled callback ...</span></span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">rejectedValue</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... reject callback ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>의 방식이다.</p><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p>예제는 이런 식이다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;약속해줘~&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val); <span class="comment">// 약속해줘~</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="string">&#x27;약속은 어기라고 있는 것&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val); <span class="comment">// 약속은 어기라고 있는 것</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>FactoryFunctionExpression</code> 에는 두가지 인자가 오는데, 첫번째 인자는 Promise 의 상태를 resolved 로 바꾸는 함수, 두번째 인자는 상태를 rejected 로 바꾸는 함수가 온다.</p><p>이 두 콜백에는 상태값을 인자로 줄 수 있으며 그 뒤의 then 이나 catch 등의 메서드의 처리 함수들이 그 값을 인자로 받는다.</p><p>인자는 하나만 허용되며, 두번째 인자는 무시되니, <strong>다수의 인자를 주고 싶다면 Object 타입을 사용</strong> 해야 한다.</p><h4 id="then-catch"><a href="#then-catch" class="headerlink" title="then, catch"></a>then, catch</h4><p>위에서 설명했듯이, Promise 생성자의 첫번째 인자는 함수이고</p><p>Promise 의 프로토타입은 다음과 같다.</p><p><img src="/images/promise/promise-internal.png" alt="Promise.prototype"></p><p><code>then</code>은 인자를 두개 받는다.</p><p>첫번째 인자는 resolved 상태에 대한 상태값을 받아 처리하는 콜백함수이고 두번째 함수는 rejected 상태에 대한 상태값을 받아 처리하는 콜백 함수이다.</p><p><code>catch</code> 는 인자를 하나만 받는데, rejected 상태에 대한 상태값을 받아 처리하는 콜백 함수가 인자가 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">somePromise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">somePromise.catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>단축 표현이라고 보면 정확하다.</p><h4 id="실전-예제"><a href="#실전-예제" class="headerlink" title="실전 예제"></a>실전 예제</h4><p>일정량의 딜레이 뒤에 수행되는 미래를 나타내는 Promise 을 만들어보자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ms 만큼 지연된 Promise 를 반환</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>ms 딜레이 밀리초</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>tid 타임아이디, ms 대기시간</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Promise 를 생성한다</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 주어진 ms로 Timer 를 예약한다</span></span><br><span class="line">        <span class="keyword">var</span> tid = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 대기가 끝나면 resolve 로 Promise 의 resolved 상태를 바꾸고 변화를 알림</span></span><br><span class="line">            resolve(&#123;</span><br><span class="line">                tid: tid, <span class="comment">// Timer 아이디</span></span><br><span class="line">                ms: ms <span class="comment">// 대기시간</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>주석으로 설명은 대체한다.</p><p>사용은 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">throttle(<span class="number">1000</span> * <span class="number">60</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;God is dead. - Friedrich Wilhelm Nietzsche&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="변하지-않아"><a href="#변하지-않아" class="headerlink" title="변하지 않아!"></a>변하지 않아!</h3><p>Promise 는 한번 상태가 결정되면 절대 변하지 않는다.</p><p>resolve 나 reject 함수를 호출하기 전을 <code>pending</code> 상태라고 한다. 이후 resolve 혹은 reject 가 수행되면 <code>resolved</code> 혹은 <code>rejected</code> 상태로 변한다.</p><p>한번 상태가 정해지면 다른 상태로는 변하지 않는다. 다시 then 을 호출한다고 해서 전 <code>pending</code> 상태의 로직이 다시 실행되거나 하지도 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(++outer);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="built_in">console</span>.log); <span class="comment">// 2</span></span><br><span class="line">promise.then(<span class="built_in">console</span>.log); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>몇번을 호출해도 결과는 같다.</p><p>한번 정해진 상태는 그대로 유지된다. 이건 기존의 콜백 로직과는 확실히 구분되는 강력함이라고 볼 수 있다.</p><p>또한, 한번 <code>resolved</code>, <code>rejected</code> 상태로 변경된 뒤에는 다른 상태 변환 시도는 무시된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일부러 두 콜백을 모두 호출해본다.</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolved 로 상태가 변경됨. </span></span><br><span class="line">    resolve(<span class="string">&#x27;완료되었어!&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// resolved 된 상태에서 reject 를 호출한다.</span></span><br><span class="line">    reject(<span class="string">&#x27;이런! 벌써 완료되었나!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="built_in">console</span>.log); <span class="comment">// 수행된다</span></span><br><span class="line">promise.catch(<span class="built_in">console</span>.log); <span class="comment">// 수행되지 않는다</span></span><br></pre></td></tr></table></figure><p>이 reject 를 먼저 호출하고 resolve 를 호출해도 마찬가지다. 아주 중요한 개념이니 잘 알아두자.</p><h3 id="여유로운-비동기-실행"><a href="#여유로운-비동기-실행" class="headerlink" title="여유로운 비동기 실행"></a>여유로운 비동기 실행</h3><p>Promise 의 then 과 catch 등의 콜백은 기본적으로 <strong>비동기로 실행</strong> 된다.</p><p>다음 예제를 보자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;시작합니다&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise 시작합니다&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;Promise 수행되었습니다&#x27;</span>) </span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;종료되었습니다&#x27;</span>);</span><br></pre></td></tr></table></figure><p>실행 순서는 어떻게 될까?</p><p>답을 보기 전 5초만 생각해보는걸 추천한다.</p><p>…</p><p>…</p><p>…</p><p>…</p><p>…</p><p>답은 아래와 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">시작합니다</span><br><span class="line">Promise 시작합니다</span><br><span class="line">종료되었습니다</span><br><span class="line">Promise 수행되었습니다</span><br></pre></td></tr></table></figure><p>그럼 Timer 함수들과는 어떨까?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;시작합니다&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Timer 설정합니다&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Timer 수행되었습니다&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Promise 시작합니다&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;Promise 수행되었습니다&#x27;</span>) </span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;종료되었습니다&#x27;</span>);</span><br></pre></td></tr></table></figure><p>이 문제는 배경 지식이 없으면 예측이 어렵다.</p><p>답은 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">시작합니다</span><br><span class="line">Timer 설정합니다</span><br><span class="line">Promise 시작합니다</span><br><span class="line">종료되었습니다</span><br><span class="line">Promise 수행되었습니다</span><br><span class="line">Timer 수행되었습니다</span><br></pre></td></tr></table></figure><p>같은 한번의 수행 프레임내에서 예약되는 Timer 와 Promise 는 언제나 Promise 의 실행이 우선되고, Timer 는 나중이 된다.</p><p>Timer 에 아주 짧은 시간을 설정해도 소용없다.</p><p>이 건에 대해서는 <a href="/2016/11/12/javascript-async-promise-3/">다음 포스트</a> 에서 다룬다. 지금은 Timer 보다 Promise 의 콜백이 내부적으로 실행 우선권을 가지고 있다고만 생각하자.</p><h3 id="체이닝"><a href="#체이닝" class="headerlink" title="체이닝!"></a>체이닝!</h3><p>Promise 의 then 과 reject 메서드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Method_chaining">체이닝 메서드</a> 로서 다음과 같이 코딩할 수도 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somePromiseInstance</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ... fulfilled callback ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ... reject callback ...</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>중요한 건 then 을 연결할 경우 앞선 promise 의 반환값이 다음 then 의 인자로 전달되며 순차적으로 실행된다.</p><p>다음 코드를 보자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">100</span>); <span class="comment">// resolved!</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="comment">// 앞선 결과를 연결한다.</span></span><br><span class="line">        <span class="keyword">return</span> value * <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value - <span class="number">10</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="number">60</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="built_in">console</span>.log); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>then 을 호출한 순서 차례대로 실행되며 이전 then 의 결과를 다음 then 이 받는다.</p><p>만일 then 에서 아무것도 반환하지 않을 경우 undefined 가 전달된다. (이걸 자주 잊어 실수하는 프로그래머들이 종종 있다. 잘 기억하자)</p><h4 id="chaining-VS-forking"><a href="#chaining-VS-forking" class="headerlink" title="chaining VS forking"></a>chaining VS forking</h4><p>메서드 체이닝 시 주의할 점이 있다.</p><p>체이닝으로 사용할 때가 있고 사용하지 않아야 할 때가 있다. 아래 예제에서 위 코드와 아래의 코드는 전혀 다른 동작을 유발한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">val</span>) </span>&#123; <span class="keyword">return</span> val * val &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CASE 1</span></span><br><span class="line">promise.then(pow);</span><br><span class="line">promise.then(pow).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CASE 2</span></span><br><span class="line">promise.then(pow).then(pow).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p><strong>CASE 1</strong> 의 코드는 resolved 상태의 값이 한번만 곱해지지만, <strong>CASE 2</strong> 는 resolved 상태의 값이 두번 곱해지며 전혀 다른 결과를 내놓는다.</p><p>단순하지만 종종 헷갈릴 수 있으니 조심하자.</p><h4 id="약속에서-다른-약속을-잡을-때"><a href="#약속에서-다른-약속을-잡을-때" class="headerlink" title="약속에서 다른 약속을 잡을 때"></a>약속에서 다른 약속을 잡을 때</h4><p>재미있는건 반환값이 일반적인 표현식이 아닌 Promise 를 반환할 경우 그 Promise 로 다음 then 값이 대체된다는 점이다. 이걸 활용하면 여러가지 재미있는 일들을 할 수 있다.</p><p>앞으로의 글의 이해를 더 돕기 위해 포스트 내에서 계속 사용될 유틸성 함수 두개를 작성하자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 지연 함수</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>action 실행 작업 함수</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>ms 작업 지연 밀리초</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>promise 객체</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">ms, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(action &amp;&amp; action());</span><br><span class="line">        &#125;, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 로깅 Thunk 함수.</span></span><br><span class="line"><span class="comment"> * Thunk 는 일단 [아직 평가되지 않은 값(value that is yet to be evaluated)] 을 말한다.</span></span><br><span class="line"><span class="comment"> * js 에서는 보통 함수로 호출될 코드 조각을 말한다.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * logThunk 함수는 메시지를 받으면 그 메시지를 호출하는 함수를 반환하는 Thunk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>message 로깅할 함수</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logThunk</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>delay</code> 함수는 특정 시간이 지난 뒤에 resolve 되는 Promise 를 반환한다. 인자는 두개로 첫번째 인자는 대기시간, 두번째 인자는 선택적으로, 지연 뒤 수행할 함수를 받는다. 이 함수의 실행 결과는 resolve 에 전달된다.</li><li><code>logThunk</code> 는 logging <a target="_blank" rel="external nofollow noopener noreferrer" href="http://stackoverflow.com/questions/2641489/what-is-a-thunk">thunk</a> 를 반환하는 함수다.</li></ul><p>이제 이 두 함수로 Promise resolve 에서 Promise 를 반환하게 해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delay(<span class="number">1000</span>, logThunk(<span class="string">&#x27;첫번째&#x27;</span>))</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delay(<span class="number">1000</span>, logThunk(<span class="string">&#x27;두번째&#x27;</span>));</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delay(<span class="number">1000</span>, logThunk(<span class="string">&#x27;세번째&#x27;</span>));</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>대략 1초 간격으로 <code>첫번째 두번째 세번째</code> 가 콘솔에 출력될 것이다.</p><p>Promise 를 반환하여 그 뒤의 then 메서드의 컨텍스트가 반환된 Promise 로 교체된 것이다.</p><p>비동기 로직인데도, 순차 실행되는 것을 확인할 수 있다.</p><h3 id="에러-처리도-간단"><a href="#에러-처리도-간단" class="headerlink" title="에러 처리도 간단"></a>에러 처리도 간단</h3><p>Promise 의 예외 처리를 하고 싶어서 다음과 같은 코드를 작성했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    delay(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Oops&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ex.stack); <span class="comment">// Oops?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드의 catch 블럭안의 stack 은 찍히지 않는다. <a href="/2016/11/12/javascript-async-promise-3/">다음 포스트</a> 의 Task 와 MicroTask 에서 다루겠지만, Promise 는 이런식의 예외 처리는 불가능하다.</p><p>Promise 는 Timer 와 비슷하면서도 다른 비동기 처리를 하며 Promise 의 콜백들은 그룹화된 <strong>Task Queue</strong> 로 관리된다. (MicroTask 라고 한다)</p><p>실제 Promise 콜백이 실행되는 시점은 try/catch 구문이 끝난 뒤다.</p><p>그럼 예외가 날 경우 어떻게 하지?!</p><p>걱정하지 않아도 괜찮다. 간단하게 처리할 수 있게 Promise 가 만들어져 있다.</p><p>Promise 는 흐름 중에 예외가 발생할 시 내부적으로 상태가 <strong>rejected</strong> 상태로 변경되고 reject 콜백으로 전달된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delay(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Oops&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message); <span class="comment">// Oops</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;에러 처리 완료&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>catch 를 사용하여 일관되게 에러를 핸들링이 가능하다.</p><p>catch 콜백도 체이닝되므로 catch 뒤에 then 을 붙이면 안전하게 Promise 체이닝을 이어가는것도 가능하다.</p><h2 id="기타-정적-메서드들"><a href="#기타-정적-메서드들" class="headerlink" title="기타 정적 메서드들"></a>기타 정적 메서드들</h2><h3 id="Promise-resolve-statusValue"><a href="#Promise-resolve-statusValue" class="headerlink" title="Promise.resolve([statusValue]);"></a>Promise.resolve([statusValue]);</h3><p>즉발로 상태값이 <strong>resolved</strong> 으로 설정된 Promise 인스턴스를 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">100</span>).then(<span class="built_in">console</span>.log) <span class="comment">// 100;</span></span><br></pre></td></tr></table></figure><p>이 함수는 아주 강력한 기능이 있다.</p><p>Promise.resolve 는 상태값으로 넘기는 인자가 Promise 인 경우 Promise 그대로 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise2 = <span class="built_in">Promise</span>.resolve(promise1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise1 === promise2); <span class="comment">// true. 같다!</span></span><br></pre></td></tr></table></figure><p>아래 코드의 Promise 들은 전부 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> promise2 = <span class="built_in">Promise</span>.resolve(promise1);</span><br><span class="line"><span class="keyword">var</span> promise3 = <span class="built_in">Promise</span>.resolve(promise1);</span><br><span class="line"><span class="keyword">var</span> promise4 = <span class="built_in">Promise</span>.resolve(promise2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise1 === promise2);</span><br><span class="line"><span class="built_in">console</span>.log(promise2 === promise3);</span><br><span class="line"><span class="built_in">console</span>.log(promise1 === promise3);</span><br><span class="line"><span class="built_in">console</span>.log(promise1 === promise4);</span><br></pre></td></tr></table></figure><p>이것만으로는 별 특별한게 없다.</p><p>하지만 resolve 에는 <strong>Promise 정규화</strong> 라는 아주 강력한 기능이 있다.</p><p>Promise 가 아닌 then 함수를 가진 객체 (보통 <strong><em>thenable</em></strong> 이라고 부른다) 를 인자로 넘길 경우 Promise 로 정규화한 뒤 반환한다!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thenable = &#123;</span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">        resolve(<span class="string">&#x27;안녕? 난 thenable 이야.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(thenable).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 안녕? 난 thenable 이야.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 심지어 이런 중첩된 thenable 도 정규화해버린다!</span></span><br><span class="line"><span class="keyword">var</span> nestedThenable = &#123;</span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(thenable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(nestedThenable).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 안녕? 난 thenable 이야.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise.resolve 내부적으로 주어진 인자에 then 이라는 이름의 메서드가 있는지 판단하여, 있다면 그것을 Promise 로 정규화해버린다. 강력하다.</p><p>앞서 Promise 상태는 불변이라고 한거 기억나는가?</p><p>Promise.resolve 는 그것까지 정규화한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반적인 thenable 이다.</span></span><br><span class="line"><span class="keyword">var</span> thenable = &#123;</span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 두 콜백을 전부 호출해버린다.</span></span><br><span class="line">        resolve(<span class="string">&#x27;안녕? 난 thenable 이야.&#x27;</span>);</span><br><span class="line">        reject(<span class="string">&#x27;핫핫핫! 거부한다&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 하지만 정규화.</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value); <span class="comment">// 안녕? 난 thenable 이야.</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value); <span class="comment">// 실행되지 않는다.</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>만일 어떤 값이 Promise 인지 아닌지 판단할 수 없을 경우, Promise.resolve 로 감싸면 안전하게 그 값을 Promise 취급할 수 있게 해주는 아주 고마운 함수이다.</p><p>이 방법은 특히 Promise API 가 나오기 전의 비슷한 Promise 구현들 (<a target="_blank" rel="external nofollow noopener noreferrer" href="https://api.jquery.com/category/deferred-object/">jQuery Deferred Object</a>, <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kriskowal/q">q</a>, <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/petkaantonov/bluebird/">bluebird</a>) 을 Promise 표준에 맞춰 일관되게 사용할때 매우 유용하다.</p><p>전달받은 인자가 의심쩍을 경우 Promise 로 래핑해버리자. 그게 Promise 라면 그냥 반환하니까 좋고, 아닐 경우에도 Promise 로 바꿔준다.</p><p>정말 사랑스러운 메서드다.</p><h3 id="Promise-reject-statusValue"><a href="#Promise-reject-statusValue" class="headerlink" title="Promise.reject([statusValue]);"></a>Promise.reject([statusValue]);</h3><p>Promise.resolve 에서 상태값만 rejected 로 바뀐 대칭적인 메서드다.</p><p>Promise.resolve 가 인자를 내부적으로 정규화해봐야 resolved 인지 rejected 인지 알 수 있다면, 이 메서드는 값이 무엇이든 그냥 rejcted 상태로 바꿔버린다는것만 다르다.</p><h3 id="Promise-all-…promise"><a href="#Promise-all-…promise" class="headerlink" title="Promise.all([ …promise ]);"></a>Promise.all([ …promise ]);</h3><p>Promise 의 배열을 인자로 받고 Promise 가 전부 resolve 되면 <code>resolved</code>, 혹은 promise 배열중 하나라도 rejected 되면 <code>rejected</code> 가 되는 Promise 를 반환한다.</p><p>then 의 콜백에 전달되는 인자는 Promise.all 에 전달된 promise 의 순서대로 상태값의 배열로 전달된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> normalPm = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;ok-1&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> asyncPm = delay(<span class="number">2000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;ok-2&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> immidiatePm = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;ok-3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([ normalPm, asyncPm, immidiatePm ]).then(<span class="function"><span class="keyword">function</span>(<span class="params">resolvedArr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resolvedArr); <span class="comment">// [ &#x27;ok-1&#x27;, &#x27;ok-2&#x27;, &#x27;ok-3&#x27; ]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-race-…promise"><a href="#Promise-race-…promise" class="headerlink" title="Promise.race([ …promise ]);"></a>Promise.race([ …promise ]);</h3><p>Promise.all 이 전부 resolved 혹은 하나라도 rejected 를 처리한다면 이 메서드는 인자로 전달된 promise 중 하나의 상태변화만을 처리한다.</p><p>Promise 중 하나라도 상태가 변할 경우 즉시 그 Promise 의 상태값을 처리한다. 이름 그대로 경합이라고 볼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rabbit = delay(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;토끼&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> turtle = delay(<span class="number">2000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;거북이&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([ rabbit, turtle ]).then(<span class="function"><span class="keyword">function</span>(<span class="params">resolved</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resolved); <span class="comment">// &#x27;토끼&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 예제의 실행 결과는 언제나 <strong>토끼</strong> 가 된다.</p><p>이 메서드가 일반적으로 유용하게 쓰이는 부분은 타임아웃 처리가 필요한 부분이다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> userRequest = ajaxRequest(<span class="string">&#x27;/api/user/list&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> timeout = delay(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;서버 응답이 늦습니다&#x27;</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([ userRequest, timeout ])</span><br><span class="line">    .then(handleUserList)</span><br><span class="line">    .catch(handleServerTimeout)</span><br></pre></td></tr></table></figure><p>서버 통신, WebSql 등의 작업, WebWorker 연계 등 사용처는 많다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>ES2015 이후 ECMAScript 에서는 차차 모든 비동기 건에 대해 Promise 인터페이스로 가는 중이다.</p><p>Promise 를 한번 익혀둔다면 앞으로의 프로그래밍에 봄날이 오리라는 건 확실하다.</p><p>Promise 에 대해 글을 쓰려고 마음먹은건 몇달 전이다.</p><p>지지부진했던 이유가 부분이 가볍게 설명하자니 너무 간단하고 성의없어지고, 조금만 살을 붙여도 너무 많아지는 거였다.</p><p>결국 써놓고 보니 장문의 포스트가 되어버렸다. 읽는데 굉장한 불편함이 있을거라 생각된다. :)</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="/2016/11/08/javascript-async-promise-1/">비동기와 Promise 1</a></li><li><a href="/2016/11/09/javascript-async-promise-2/">비동기와 Promise 2</a></li><li><a href="/2016/11/12/javascript-async-promise-3/">비동기와 Promise 3</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.bsidesoft.com/?p=399">BsideSoft 공식 블로그 # 동기화 vs 비동기화 1</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.bsidesoft.com/?p=414">BsideSoft 공식 블로그 # 동기화 vs 비동기화 2</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.bsidesoft.com/?p=423">BsideSoft 공식 블로그 # 동기화 vs 비동기화 3</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/nhnent/fe.javascript/wiki/June-13-June-17,-2016">NHN Enter # 자바스크립트와 이벤트 루프</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.2ality.com/2014/09/es6-promises-foundations.html">2ality # ECMAScript 6 promises - foundations</a></li><li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules">jakearchibald’s blog # Tasks, microtasks, queues and schedules</a></li></ul></div><div class="article-tags"><a class="tag-none-link" href="/tags/async/" rel="tag">async</a><a class="tag-none-link" href="/tags/ecmascript/" rel="tag">ecmascript</a><a class="tag-none-link" href="/tags/javascript/" rel="tag">javascript</a><a class="tag-none-link" href="/tags/promise/" rel="tag">promise</a></div><section id="comments" class="white-box"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></article><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5bf3f68d0a53e4d6"></script><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; <a href="https://blog.javarouka.me">NonBlock</a> Theme by <a href="http://artifact.me/" target="_blank" rel="external nofollow noopener noreferrer">Art Chen</a>.</div><div>Powered by <a target="_blank" href="https://hexo.io/" rel="external nofollow noopener noreferrer">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></aside></div><div class="site-sidebar"><div class="sidebar-switch clearfix show" style="display:block"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-bio" style="display:none"><div class="about-me clearfix"><div class="avatar"><img src="https://avatars2.githubusercontent.com/u/1438503?v=4&s=250"></div><div class="info"><a class="name dark-btn" href="/about">JavaRouka</a></div><div class="info"><span class="item desc">javarouka 의 기술블로그</span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="mailto:javarouka@gmail.com" class="mail" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-mail"></span> </a><a href="https://github.com/javarouka" class="github" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-github"></span> </a><a href="https://www.facebook.com/hanghui.i" class="facebook" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-facebook"></span></a></div><div class="shortcuts clearfix"><div class="bk"><a href="#header" class="dark-btn window-nav"><span class="icon icon-chevron-thin-up"></span> <span class="text">Back to Top</span></a></div><div class="bk"><a href="#footer" class="dark-btn window-nav"><span class="icon icon-chevron-thin-down"></span> <span class="text">Go to Bottom</span></a></div></div></div><div class="site-post-nav show" style="display:block"><div class="site-post-nav-box"><a href="/2016/11/12/javascript-async-promise-3/" class="icon icon-chevron-thin-left"><a href="/2016/11/12/javascript-async-promise-3/" class="site-post-nav-text">비동기와 Promise #3</a></a></div><div class="site-post-nav-box"><a href="/2016/11/08/javascript-async-promise-1/" class="site-post-nav-text">비동기와 Promise #1</a> <a href="/2016/11/08/javascript-async-promise-1/" class="icon icon-chevron-thin-right"></a></div></div><div class="site-toc show" style="display:block"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B7%B8%EB%8F%99%EC%95%88-%EC%9A%B0%EB%A6%AC%EA%B0%80-%ED%95%B4%EC%98%A4%EB%8D%98-%EB%AF%B8%EB%9E%98%EC%9D%BC%EC%9D%98-%EC%B2%98%EB%A6%AC"><span class="toc-number">1.</span> <span class="toc-text">그동안 우리가 해오던 미래일의 처리</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BD%9C%EB%B0%B1%ED%95%A8%EC%88%98"><span class="toc-number">1.1.</span> <span class="toc-text">콜백함수</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%BD%9C%EB%B0%B1%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90"><span class="toc-number">1.2.</span> <span class="toc-text">콜백의 문제점</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B7%B8%EB%9E%98%EC%84%9C-Promise-%EB%8A%94-%EB%AD%94%EB%8D%B0"><span class="toc-number">2.</span> <span class="toc-text">그래서 Promise 는 뭔데?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EA%B8%B0%EB%B3%B8"><span class="toc-number">2.1.</span> <span class="toc-text">기본</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#example"><span class="toc-number">2.1.1.</span> <span class="toc-text">example</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#then-catch"><span class="toc-number">2.1.2.</span> <span class="toc-text">then, catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C"><span class="toc-number">2.1.3.</span> <span class="toc-text">실전 예제</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EB%B3%80%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%84"><span class="toc-number">2.2.</span> <span class="toc-text">변하지 않아!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%AC%EC%9C%A0%EB%A1%9C%EC%9A%B4-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%8B%A4%ED%96%89"><span class="toc-number">2.3.</span> <span class="toc-text">여유로운 비동기 실행</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%B2%B4%EC%9D%B4%EB%8B%9D"><span class="toc-number">2.4.</span> <span class="toc-text">체이닝!</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chaining-VS-forking"><span class="toc-number">2.4.1.</span> <span class="toc-text">chaining VS forking</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EC%95%BD%EC%86%8D%EC%97%90%EC%84%9C-%EB%8B%A4%EB%A5%B8-%EC%95%BD%EC%86%8D%EC%9D%84-%EC%9E%A1%EC%9D%84-%EB%95%8C"><span class="toc-number">2.4.2.</span> <span class="toc-text">약속에서 다른 약속을 잡을 때</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC%EB%8F%84-%EA%B0%84%EB%8B%A8"><span class="toc-number">2.5.</span> <span class="toc-text">에러 처리도 간단</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B8%B0%ED%83%80-%EC%A0%95%EC%A0%81-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4"><span class="toc-number">3.</span> <span class="toc-text">기타 정적 메서드들</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-resolve-statusValue"><span class="toc-number">3.1.</span> <span class="toc-text">Promise.resolve([statusValue]);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-reject-statusValue"><span class="toc-number">3.2.</span> <span class="toc-text">Promise.reject([statusValue]);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-all-%E2%80%A6promise"><span class="toc-number">3.3.</span> <span class="toc-text">Promise.all([ …promise ]);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-race-%E2%80%A6promise"><span class="toc-number">3.4.</span> <span class="toc-text">Promise.race([ …promise ]);</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EA%B2%B0%EB%A1%A0"><span class="toc-number">4.</span> <span class="toc-text">결론</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EC%B0%B8%EA%B3%A0"><span class="toc-number">5.</span> <span class="toc-text">참고</span></a></li></ol></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo"</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script type="text/javascript">var disqus_shortname="https-javarouka-github-io",disqus_url="https://blog.javarouka.me/2016/11/09/javascript-async-promise-2/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>