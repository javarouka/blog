<!DOCTYPE html><html><head><meta charset="utf-8"><title>ES2015 - var, const, let | NonBlock</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="var, const, let"><meta property="og:type" content="article"><meta property="og:title" content="ES2015 - var, const, let"><meta property="og:url" content="https://blog.javarouka.me/2016/03/31/let-const/index.html"><meta property="og:site_name" content="NonBlock"><meta property="og:description" content="var, const, let"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://blog.javarouka.me/asset/images/js.jpg"><meta property="article:published_time" content="2016-03-30T15:00:00.000Z"><meta property="article:modified_time" content="2020-09-22T04:18:02.865Z"><meta property="article:author" content="JavaRouka"><meta property="article:tag" content="javascript"><meta property="article:tag" content="ecmascript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.javarouka.me/asset/images/js.jpg"><link rel="apple-touch-icon" sizes="57x57" href="/fav/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/fav/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/fav/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/fav/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/fav/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/fav/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/fav/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/fav/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/fav/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/fav/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/fav/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/fav/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/fav/favicon-16x16.png"><link rel="manifest" href="/fav/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/fav/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><meta name="keywords" content="javascript,ecmascript"><link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-85661914-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-85661914-1")</script><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"><script type="text/javascript">var __sauron=__sauron||[];__sauron.push(["pageview"]),function(){var e="https://analy1.sauroneyes.com/";__sauron.push(["setTrackerUrl",e+"analytics/"]);var a=document,r=a.createElement("script"),s=a.getElementsByTagName("script")[0];r.type="text/javascript",r.async=!0,r.defer=!0,r.src=e+"js/sauron.js",s.parentNode.insertBefore(r,s)}()</script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="alternate" href="/atom.xml" title="NonBlock" type="application/atom+xml">
</head><body><div class="site-wrapper"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">N </span><span class="b">o </span><span class="b">n </span><span class="b">B </span><span class="b">l </span><span class="w">o </span><span class="b">c </span><span class="w">k </span></a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><aside class="category-wrapper"><div class="site-category"><a class="nav flex-column-link" href="/categories/effective-java/">Effective Java</a><a class="nav flex-column-link" href="/categories/review/">Review</a><a class="nav flex-column-link" href="/categories/tech/">Tech</a><a class="nav flex-column-link" href="/categories/tech/translate/">Translate</a><a class="nav flex-column-link" href="/categories/book/">book</a><a class="nav flex-column-link" href="/categories/java/">java</a><a class="nav flex-column-link" href="/categories/java/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/javascript/">javascript</a><a class="nav flex-column-link" href="/categories/javascript/react/">react</a><a class="nav flex-column-link" href="/categories/javascript/react/redux-saga/">redux-saga</a><a class="nav flex-column-link" href="/categories/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/kotlin/tech/">tech</a><a class="nav flex-column-link" href="/categories/kotlin/tech/translate/">translate</a></div><div class="search"><form name="searchform" id="searchform" class="u-search-form"><input type="text" id="searchinput" class="u-search-input st-default-search-input" data-list-highlight="true" data-list-value-completion="true" placeholder="Looking for something in this blog?"> <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit"><span class="icon icon-search"></span></button></form></div><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-let-const" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">ES2015 - var, const, let</h1><h2 class="article-sub-title">var, const, let</h2><div class="article-meta">Posted on <time class="article-time" datetime="2016-03-30T15:00:00.000Z" itemprop="datePublished">2016-03-31</time></div></header><div class="article-entry" itemprop="articleBody"><h2 id="Hello-let"><a href="#Hello-let" class="headerlink" title="Hello, let?"></a>Hello, let?</h2><p>ES2015 에는 새로운 변수 선언법이 추가되었다.</p><p>예전에는 현재의 스코프에 ‘변수’를 ‘선언’ 하는 방법은 var 와 function 뿐이었다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">// 전역 스코프에 변수 a 선언</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 전역 스코프에 함수 b 선언</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>; <span class="comment">// 함수 c 스코프에 변수 a 선언</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제는 새로운 변수 선언법인 const와 let 이 생겼다. 이 둘은 ES2015에 새로이 추가된 블럭 스코프에 묶이는 변수들이다.<br>(사실 ES2015 에서는 var 를 쓰는건 문법면에서 추천하지 않고 있다.)</p><p>const 는 불변 변수, let은 가변 변수를 선언할 때 쓰이며, 당연히 const 는 선언과 동시에 할당하지 않으면 TypeError가 발생한다.</p><p>기존에는 변수를 특정한 스코프에 묶으려면 이렇게 해야 했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// IIFE function scope</span></span><br><span class="line">  <span class="keyword">var</span> hello = <span class="string">&quot;안녕&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(hello) <span class="comment">// 안녕 </span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>하지만 이젠 아주 간단히 해결된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hello = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block scope</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">&quot;안녕&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(hello) <span class="comment">// 안녕 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hello); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>그리고 const 키워드는 코드를 읽는데도 큰 도움을 준다.</p><p>변수의 불변성(immutable) 이라는 건 가독성 뿐 아니라 여러 면에서 장점이 많기 때문이다.</p><p>코드 블럭에 남발된 가변 변수의 존재는 자신의 어지간히 머리가 좋지 않은 이상 코드를 읽을 때 방해물이 되기 쉽다.</p><p>어떤 때 let 을 사용하고, 어떤때 const를 사용해야 할까<br>결론부터 이야기하면, 일단 모든 변수에는 const 를 사용하고 본다. 그리고 어쩔 수 없이 가변값을 다루거나 특정 변수가 미래에 변할 가능성이 있을 때만 (좀 더 정확히는 TypeError 발생 시) let 을 사용하면 된다.</p><p>실제 const만을 사용하여 코딩해보면 let을 사용할 기회가 많지 않다는 사실에 놀랄 것이다.</p><p>혹시 loop 인덱스 변수에는 사용해야 하지 않나요? 라고 물을 수 있는데, ES2015 에서는 loop 마다 새로운 변수 바인딩을 생성하기에 아무 문제가 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = &#123; <span class="string">&#x27;사과&#x27;</span>: <span class="string">&#x27;맛있다&#x27;</span>, <span class="string">&#x27;바나나&#x27;</span>: <span class="string">&#x27;역시맛있다&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> fruit) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, fruit[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>루프마다 ‘새로운 바인딩’ 이라는게 중요하다.</p><p>그렇다면 바로 다음 코드를 보자. 이건 어떻게 동작할까?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> indexMap = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  indexMap.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> i; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  indexMap.map(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123; <span class="keyword">return</span> val(); &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>결과는</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p>반면, 앞선 i 를 var 로 바꾸면, 결과는 완전히 달라진다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> indexMap = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  indexMap.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> i; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  indexMap.map(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123; <span class="keyword">return</span> val(); &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]</span></span><br></pre></td></tr></table></figure><p>var의 경우는 새로운 스코프 없이 한 변수에 인덱스가 추가되며 바인딩되었고, 결국 indexMap 에 순차적으로 추가한 함수들이 같은 스코프의 var 를 참조하면서(이걸 Closure 라고 부른다) 전부 10이 찍히게 된다.</p><p>이걸 막으려면 ES5 에서는</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 새 스코프를 생성하기 위해 즉시 실행 함수 호출(IIFE) 로 둘러싼다</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    indexMap.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> i; &#125;);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>라는 다소 보기 좀 불편(?) 한 코드를 사용해서 먼저 함수 스코프로 감싸야 했다.</p><p>let과 const를 쓰면 이젠 이런 코드로부터 해방이다~!</p><p>아, 혹시 위에 지나간 예제중에 let 을 const로 바꾸면 어떨까 하는 다음과 같은 코드를 생각했다면,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  indexMap.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="keyword">return</span> i; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이것은 동작하지 않는다. 루프마다 새 바인딩이 되는 것은 맞아서 앞의 const i = 0; 부분은 문제가 없지만, i++ 이 부분이 문제가 된다. const 는 불변이기 때문이다.</p><p>전역 변수와 전역 프로퍼티<br>JavaScript 를 어느정도 다뤄본 사람이라면 전역 변수에 대해 여러 생각이 있지만, 공통된 생각은 해롭다는 것에 동감할 것이다.</p><p>var 를 사용해서 전역에 변수를 선언할 경우, 전역에 변수를 선언한다. 이건 당연하다.</p><p>하지만 여기서 끝나는게 아니라 전역객체의 프로퍼티에도 이 변수가 프로퍼티로 잡힌다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// 1. 전역 객체(window) 에 프로퍼티로 자동으로 잡혔다</span></span><br><span class="line">하지만 <span class="keyword">let</span>과 <span class="keyword">const</span>는 전역에서 변수를 선언 시 전역 스코프에는 변수를 할당하나, 전역 프로퍼티에는 변수를 할당하지 않는다. 아래 코드를 보자.</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a) <span class="comment">// undefined. 전역 객체(window) 에 프로퍼티로 잡히지 않는다.</span></span><br></pre></td></tr></table></figure><p>사실 ES2015의 특성 (모듈 및 블럭 스코프) 과 맞물려 전역객체에 뭔가를 할당할 일은 전혀라고 좋을 정도로 없어져 버렸기에, var는 더욱 쓸 일이 없어졌다.</p><p>호이스팅과 TDZ(Temporal Dead Zone)<br>호이스팅은 간단히 설명하면 이런 현상을 말한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// undefined. 코드 실행 전 함수 내부 스코프의 a가 먼저 선언되고 undefined 상태가 된다.</span></span><br><span class="line">  <span class="comment">// 상위 스코프의 a는 shadow.</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이제야 3이 찍힌다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES2015 이전에선 var 기반 변수 선언과 JavaScript의 함수 스코프의 특성으로 현재 스코프의 모든 변수 선언을 실행 전 먼저 선언하고 undefined 를 할당해두는 동작을 했다. 이걸 보통 사람이 코드를 위에서 아래로 읽어나갈 때 변수들이 현재 스코프의 최상단으로 끌어올려진다(Hoisted) 다고 하여 호이스팅이라고 부른다.</p><p>let과 const 도 물론 호이스팅이 된다. 하지만 세부 내용은 좀 다르다.</p><p>var 의 함수 스코프 단위의 호이스팅이 아닌 블럭 스코프 호이스팅이며, 선언만 할뿐 실행기가 undefined 등을 할당해주는 친절함 따위도 없다. 그리고 그 변수가 완전히 할당되기 전 사용하려 하면 오류가 난다.</p><p>코드를 보자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>뭔가 1 다음 10이 출력될 것 같지만, 이 코드는 <code>ReferenceError</code> 를 낸다. 일단 코드가 실행되면 바깥 스코프에 a 가 10으로 선언된다. 블럭에 진입해서 새로운 스코프가 만들어지고, 블럭 안의 a 역시 호이스팅되어 바깥 스코프의 a를 가리지만, 아직 이 변수는 사용할 수 없는 상태이다.</p><p>이것을 ES2015 에서는 <code>TDZ - Temporal Dead Zone</code> 이라고 부른다.</p><p>코드가 실행되서 호이스팅과는 별개로 실제 코드의 선언문을 실행하게 되면 그때서야 변수가 성공적으로 초기화되고 할당 구문이 있다면 값이 할당되고 없다면 undefined 가 할당될 것이다.</p><p>특히 ES2015에 새로 추가된 변수 해체나 파라미터 기본값 처리 시 실수의 여지가 있다.</p><p>코드를 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a = b, b = <span class="number">4</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// ReferenceError.</span></span><br></pre></td></tr></table></figure><p>이건 실제로는 기본값 할당이 다음과 같이 처리되기에 TDZ 에 따라 ReferenceError 이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = b; <span class="comment">// TDZ!</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></div><div class="article-tags"><a class="tag-none-link" href="/tags/ecmascript/" rel="tag">ecmascript</a><a class="tag-none-link" href="/tags/javascript/" rel="tag">javascript</a></div><section id="comments" class="white-box"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></article><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5bf3f68d0a53e4d6"></script><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; <a href="https://blog.javarouka.me">NonBlock</a> Theme by <a href="http://artifact.me/" target="_blank" rel="external nofollow noopener noreferrer">Art Chen</a>.</div><div>Powered by <a target="_blank" href="https://hexo.io/" rel="external nofollow noopener noreferrer">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></aside></div><div class="site-sidebar"><div class="sidebar-switch clearfix" style="display:none"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-bio show" style="display:block"><div class="about-me clearfix"><div class="avatar"><img src="https://avatars2.githubusercontent.com/u/1438503?v=4&s=250"></div><div class="info"><a class="name dark-btn" href="/about">JavaRouka</a></div><div class="info"><span class="item desc">javarouka 의 기술블로그</span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="mailto:javarouka@gmail.com" class="mail" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-mail"></span> </a><a href="https://github.com/javarouka" class="github" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-github"></span> </a><a href="https://www.facebook.com/hanghui.i" class="facebook" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-facebook"></span></a></div><div class="shortcuts clearfix"><div class="bk"><a href="#header" class="dark-btn window-nav"><span class="icon icon-chevron-thin-up"></span> <span class="text">Back to Top</span></a></div><div class="bk"><a href="#footer" class="dark-btn window-nav"><span class="icon icon-chevron-thin-down"></span> <span class="text">Go to Bottom</span></a></div></div></div><div class="site-post-nav show" style="display:block"><div class="site-post-nav-box"><a href="/2016/11/08/javascript-async-promise-1/" class="icon icon-chevron-thin-left"><a href="/2016/11/08/javascript-async-promise-1/" class="site-post-nav-text">비동기와 Promise #1</a></a></div><div class="site-post-nav-box"><a href="/2014/05/24/handlebars-server-client-multiple-useing/" class="site-post-nav-text">Handlebars (for Java) 서버, 클라이언트 동시에 사용하기</a> <a href="/2014/05/24/handlebars-server-client-multiple-useing/" class="icon icon-chevron-thin-right"></a></div></div><div class="site-toc" style="display:none"><div class="no-index">No Index</div></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo"</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script type="text/javascript">var disqus_shortname="https-javarouka-github-io",disqus_url="https://blog.javarouka.me/2016/03/31/let-const/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>