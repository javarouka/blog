<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>ES7 Decorator</title>
</head>
<body>

    <header>
        <h1>JavaRouka Github Blog</h1>
        <h2>## ES7 Decorator 탐구생활</h2>
        <p class="header-summary">2016년 9월 30일.</p>
        <p class="header-summary">ES7의 Decorator 에 대해 이모저모 알아보자.</p>
    </header>

    <section>

        <h2>Decorator?</h2>
        <div>
            <em>함수(function)</em> <em>표현식(expression)</em> 에 해당한다.
            <em>@</em>와 같이 써서 표현식 뒤에 오는 대상 (보통 target 이라고 함...같은 말이군.)에 더욱 기능적으로 추가하거나(decarating) 하는 일들을 할 수 있다.
            <br/>
            <br/>
            보통 다음의 경우에 많이 적용 (되는 것 같이 보이긴) 한다
            <ul>
                <li>함수에 Interceptor 성의 기능 추가. 로깅 등이나 인자 유효성 검사 등</li>
                <li>예외 처리나 로깅 등의 종단관심사 처리. AOP 라 부르는 것들</li>
                <li>
                    <span>믹스인 생성 및 적용</span>
                    <a href="//medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#22de">예제 #1</a>
                </li>
                <li>property descriptor 를 조작하여 get/set 조작 및 열거 등의 조작</li>
                <li>인자에 따른 Proxy 처리</li>
                <li>기타등등...생각하기에 따라</li>
            </ul>
            <blockquote>ES2015 스펙에는 일단 없지만, 아마 다음 스펙엔 추가될 것 같다.</blockquote>
        </div>

        <h2>일단 타이핑</h2>
        <h3>메서드에 실행 권한 추가하기</h3>
        <div>
            일단 다음과 같은 class 를 정의해보자
            <pre><code class="language-javascript">class Something {
    firstLove() {
      console.log("첫번째 사랑");
    }

    secondLove() {
      console.log("두번째 사랑");
    }
}</code></pre>
            <br/>
            위의 class 의 첫사랑 (<em>firstLove</em>) 메서드에 권한 기능을 추가한다고 해보자. 권한이 있는 사용자만 수행(..)을 할 수 있게 하는 거다.
            <br/>
            일단 전용 에러 객체부터 생성하자
            <pre><code class="language-javascript">// 권한 에러 정의
class NotAllowedError extends Error {}</code></pre>
            <br/>
            이제 발생하는 에러들은 저 에러를 던지도록 한다.
            <br/>
            그 다음은 적용 코드 작성.
            <pre><code class="language-javascript">class Something {
    firstLove() {
        if(!isAllowed()) throw new NotAllowedError('권한이 없습니다');
        console.log("첫번째 사랑");
    }

    secondLove() {
        console.log("두번째 사랑");
    }
}</code></pre>
            <br/>
            간단하다. 하지만 두번째 사랑에도 제약이 필요하다면...?
            <br/>
            <h3>중복이 많다!</h3>
            하지만 보통 권한은 다수의 작업에 적용되기에 저 만일 <em>firstLove</em> 메서드 외에도 여러 다른 함수에 적용하려고 하면, <strong>그 수만큼 코드를 추가해야</strong> 할 것이다.
            <pre><code class="language-javascript">class Something {
    firstLove() {
        if(!isAllowed()) throw new NotAllowedError('권한이 없습니다');
        console.log("첫번째 사랑");
    }

    secondLove() {
        if(!isAllowed()) throw new NotAllowedError('권한이 없습니다');
        console.log("두번째 사랑");
    }

    marry() {
        if(!isAllowed()) throw new NotAllowedError('권한이 없습니다');
        console.log("결혼");
    }
}</code></pre>
            <br/>
            이런건 원하지 않을 것이다.
            <pre><code class="language-javascript">// 이 코드가 권한을 부여할 메서드 바디안에 중복된다!
if(!isAllowed()) throw new NotAllowedError('수행 권한이 없습니다');</code></pre>
            <br/>
            어떻게 해야 할까...
            <br/>
            <h3>해결책 : 래핑 함수로 실행 전에 끼어들자.</h3>
            먼저 다음과 같은 권한 체크 함수를 만든다
            <pre><code class="language-javascript">// 미리 예외 객체를 생성해두고 재활용한다
const notAllowedErr = new NotAllowedError('수행 권한이 없습니다');
const checkAllowExecution = () => {
    if(!isAllowed()) throw notAllowedErr;
}</code></pre>
            <br/>
            이제 래핑이다.
            <br/>
            <pre><code class="language-javascript">function allowedExecution(klass) {

    // 기존의 메서드들을 전부 가져오기 위해 사용 될 prototype 을 캐시해둠
    const proto = klass.prototype;

    // 메서드만 전부 뽑는다
    const declaredMethodNames = Object.getOwnPropertyNames(proto)
                  .filter(method => (typeof proto[props] === 'function'));

    // 래핑 함수 선언
    const wrap = (obj, name, descriptor) => {
        const origMethod = descriptor.value;
        Object.defineProperty(proto, methodName, {
            value() {
                checkAllowExecution();
                return origMethod.apply(this, arguments);
            }
        }
    }

    // 이제 루프를 돌며 메서드를 래핑한다.
    declaredMethodNames.forEach(methodName => {

        // 속성 디스크립터를 얻는다
        const descriptor = Object.getOwnPropertyDescriptor(proto, methodName);

        // 얻은 디스크립터로 해당 메서드를 래핑
        wrap(proto, methodName, descriptor);
    });
}</code></pre>
            <br/>
            이제 적용하자.
            <pre id="wrapping"><code class="language-javascript">const wrapClass = allowedExecution(Something);
const myLove = new wrapClass();
myLove.firstLove(); // throw !! ㅠ.ㅠ</code></pre>
            <br/>
            자 이제...
            <h3>답은 '@'</h3>
            이제 Decorator 표현식을 써보자.
            <br/>
            <br/>
            사용은 간단하다. 위의 랩 함수 호출부를 @캐릭터와 함께 써주는 방식으로 바꾸기만 하면 된다
            <pre><code class="language-javascript">@allowedExecution // here
class Something {
    firstLove() {
        console.log("첫번째 사랑");
    }

    secondLove() {
        console.log("두번째 사랑");
    }

    marry() {
        console.log("결혼");
    }
}</code></pre>
            효과는 위의 <a href="#wrapping">명시적 래핑</a> 과 동일하다.
      </div>

      <h2>적용 대상에 따른 시그니처</h2>
      <div>
          위에서는 class 의 경우만 해당되었는데, 사실 적용 대상에 따라 decorator 의 시그니처가 달라진다.
          <h3>Class 일 경우</h3>
          <div>
              <pre><code class="language-javascript">function decorator(target) { /* ... */ }</code></pre>
              <br/>
              위에서 우리가 구현했던 내용과 같다.
              <br/>
              decorating 할 target 의 constructor 가 첫번째 인자로 오는 시그니처가 된다.
              <pre><code class="language-javascript">function decorator(target) {
    console.log(target.name); // drive
    console.log(target.prototype); // object
    console.log(Object.getOwnPropertyNames(target.prototype)); // [ drive, stop ]
}

@decorator
class Car {
    drive(){}
    stop(){}
}</code></pre>
          </div>
          <h3 id="class-method">Class Method 일 경우</h3>
          <div>
              <pre><code class="language-javascript">function decorator(target, name, descriptor) { /* ... */ }</code></pre>
              <br/>
              이 경우에는 인자가 3개이다.
              <dl>
                  <dt>target</dt>
                  <dd>- 메서드의 소유자. Class 라면 해당 Class의 prototype 이 될 것이다.</dd>
                  <dt>name</dt>
                  <dd>- 메서드의 이름.</dd>
                  <dt>descriptor</dt>
                  <dd>- 메서드의 프로퍼티 디스크립터. 디스크립터에 대한 내용은 여기서 다루긴 많으므로 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description" target="_blank">여기</a>를 참조한다</dd>
              </dl>

              <pre><code class="language-javascript">function decorator(target, name, descriptor) {
    // Car
    console.log(target.name);

    // drive
    console.log(name);

    // { value: function(){}, writable: true, enumerable: false, configurable: true }
    console.log(descriptor);
}
class Car {
    @decorator
    drive(){}
    stop(){}
}</code></pre>
              <br/>
              물론 이 속성들을 활용해서 여러 처리가 가능하다.
              <br/>
              <br/>
              이 작업을 위해서는 앞서 말한 ES5의 신규 Spec 이었던 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Description" target="_blank">Object 프로퍼티</a> 관련 이해가 어느정도 필요하긴 하다.
          </div>
          <h3>Plain Object 의 Method 일 경우</h3>
          <div>Plain Object 의 Method 라는 건 객체 속성에 할당된 함수를 말한다. 이 경우는 위의 <a href="#class-method">Class Method 의 경우</a>와 같다</div>
      </div>

      <h2>몇가지 Examples</h2>
      <div>
          실행 전에 특정 함수를 실행하는 decorator 를 만들어보자
          <br/>
          먼저 사용법은 이런 형식으로 될 것이다.
          <br/>
          <pre><code class="language-javascript">class Programer {

    @before(name => console.log(`${name} executed.`))
    makeCode() {
        console.log('코드를 만듭니다.');
    }

    makeIncident() {
        console.log('장애를 냅니다.');
    }
}
const chobo = new Programer();

chobo.makeCode();
// makeCode executed
// 코드를 만듭니다

chobo.makeIncident();
// 장애를 냅니다.</code></pre>
          <br/>
          그럼 다음은 실제 코딩
          <br/>
          코드의 설명은 주석에 달아두었다.
          <pre><code class="language-javascript">// 함수 구별 유틸 함수
const isFunction = v => (typeof v === 'function');

// 인자로 작업 전 수행할 액션을 받는다.
function before(action) {

    // 데코레이터는 함수이므로 실행 결과로 함수가 반환되어야 한다.
    return (target, name, descriptor) => {

        // descriptor 에서 현재 value 를 꺼낸다
        const value = descriptor.value;

        // action 이나 value 가 함수가 아니면 의미가 없다.
        if (!isFunction(action) || !isFunction(value)) return;

        // 액션을 실행 전 수행하도록 재 정의한다.
        Object.defineProperty(target, name, {
            ...descriptor,
            value() {

                action(name, arguments, this); // 이부분!

                // 실행 컨텍스트를 보정해준다
                return value.apply(this, arguments);
            }
        });
    }
}</code></pre>
      </div>

  </section>

  <footer>
      <section class="contributor">

          <div class="gravata">
              <a href="http://ko.gravatar.com/javarouka" target="_blank">
                  <img src="http://2.gravatar.com/avatar/ea49d570a6a8654adf6c0b8d90e51290?size=160" alt="javarouka profile image">
              </a>
          </div>

          <ul>
              <li>
                  <span>Other Blog: </span>
                  <a href="http://blog.javarouka.me/">http://blog.javarouka.me</a>
              </li>
              <li>
                  <span>Mail: </span>
                  <a href="mailto:javarouka@gmail.com">javarouka@gmail.com</a>
              </li>
              <li>
                  <span>Github: </span>
                  <a href="https://github.com/javarouka" target="_blank">https://github.com/javarouka</a>
              </li>
              <li>
                  <span>Facebook: </span>
                  <a href="https://www.facebook.com/hanghui.i" target="_blank">https://www.facebook.com/hanghui.i</a>
              </li>
          </ul>
      </section>
  </footer>

</body>
</html>