---
layout: post
title: "ES2015 Promise"
description: "ES2015 의 Promise 에 대해 알아보자"
date: 2016-10-29
tags: [ecmascript, javascript, promise, async]
comments: true
share: true
draft: true
image: 'images/ecmascript.jpg'
thumbnail: '/images/ecmascript.jpg'
categories: ['Tech']
---

이 글은 작성중이며 지속적으로 업데이트됩니다.

## 그동안 우리가 해오던 미래일의 처리

온라인 쇼핑을 하다보면 주문서에 택배기사에게 전할 말을 기록하는 공간이 있다. 보통 그곳에는 이렇게 적는 사람이 많을것이다 (나는 대부분 아래와 같이 적어둔다.)

> 택배 완료전에 전화주세요.

지금은 택배가 오지 않았지만 `택배가 올 미래` 에 `전화해달라` 는 처리를 부탁하고 있는 것이다.

물건을 주문한 사람은 택배가 올 때까지 마냥 기다릴 필요가 없고 다른일을 하다가 택배 도착 전 오는 전화를 받을 수 있다. 택배를 받으려고 택배직원을 아무것도 안하고 마냥 기다리려는 사람은 없을것이다

```javascript
var goods = goodsOnDelivery(); // 배달될 때까지 기다려야한다!
enjoyLife(goods); // 만일 배달되지 않는다면 인생을 못즐길 것이다.
```

...이러고 싶진 않을것이다. 배송 함수를 비동기로 하고 콜백을 받게 수정했다고 가정한다. 그리고 배송 뒤 수행할 일을 함수 인자로 받는 식으로.

함수 이름은 적당히 `goodsOnDeliveryAsync` 라고 붙이자.

```javascript
// 배달될 경우에 수행할 작업을 콜백으로 전달해둔다.
goodsOnDeliveryAsync(function(goods) { // 콜백!
    enjoyLifeByGoods(goods);
});
enjoyLifeByExistsGoods();
```

배송을 시키고, `다른걸로 놀다 (enjoyLifeByExistsGoods)` 가 배송되면 `배송된 걸로 노는 것 (enjoyLifeByGoods)` 이다.

물론 실행 순서는 ``goodsOnDeliveryAsync -> enjoyLifeByExistsGoods -> enjoyLifeByGoods``. 인생은 아름답다.

여기서 조금 더 생각해보자.

`goodsOnDeliveryAsync` 는 자신이 맡은 배송 외에도, 추가적으로 자신과는 전혀 관계가 없는 콜백 함수를 처리할 임무를 맡고 있다.
콜백으로 전달된 인자의 유효성 검증은 물론, 예외가 나든 오류가 나든 반드시 콜백을 호출해줘야 한다. 그리고 작업을 여러개 처리해야 할 경우에도 문제가 된다.

물론 콜백안에 함수 셋을 전달할 수도 있지만 가독성 면에서 그리 좋은 방법은 아니다.

이쯤 뭔가 이상한 냄새가 난다고 생각하지 않는가?

이럴때 앞선 선배 개발자들은 책임을 분리하라고들 한다.

이렇게 코드를 고쳐보자

```javascript
// 콜백 인자를 받지 않는다
function goodsOnDeliveryAsyncFuture() {

    var future = [];
    var executed = false;

    // ... 뭔가 열심히 비동기 처리하고 처리 후 future 를 뒤진다
    // asyncRunner 은 비동기 처리를 하는 유틸리티라고 가정해두자.
    asyncRunner(function(error, goods) {
    
        if(executed || error || !future.length) return;
        
        future.forEach(function(job) {
            job(goods);
        });
            
        executed = true;
    });
    
    return {
    
        // 미래에 처리할 작업을 등록하는 메서드를 반환한다
        delivered: function(job) {
            future.push(job);
            return this;
        }
    }
}

// 등록! 
goodsOnDeliveryAsyncFuture().delivered(enjoyLifeByGoods);
```

`goodsOnDeliveryAsyncFuture` 함수는 이제 콜백과 다소 멀어진 사이가 되었다.

예전이 반드시 호출해야할 콜백의 의무를 가졌다면 코드를 수행하는 지금은 배송을 지시하는 코드(`goodsOnDeliveryAsyncFuture` 를 호출하는 코드) 에서 미래의 일을 예약한다.

`goodsOnDeliveryAsyncFuture` 는 단지 자신의 할일을 처리하고, 만일 배송 뒤의 작업이 등록되어 있다면 그게 무언지 생각하지 않고 처리해준다.

## JavaScript 의 미래에 대한 작업 처리

앞서 간단한 코드에서 얼렁뚱땅 넘어간 부분이 있다 *"배송 함수를 비동기로 하고 콜백을 받게 수정했다"* 라고 언급한 부분이다.

다음 어떤 프로그램의 일부 코드가 있다. `Java Code` 이다.

```java
public class FirstAttack {

    private List<Hero> avengers = new List<>;

    // ... some implements ...

    public void hereComesNewAvengersAssemble() {

        int prevAvengersCount = heros.length;

        Hero newHero = createAvenger('Dr Strange');
        avengers.add(newHero);

        if((prevAvengersCount + 1) != avengers.size()) {
            throw new IllegalStateException("don't avengers assemble!");
        }

        // implements attack ...
    }

      // ... some implements ...
}
// ... blah ...

```

얼핏 보면 어벤저스는 다행히 집합에 성공할 것이다. 기존 Avengers 의 숫자에서 새로운 Avenger 가 등장했고, 숫자가 1 늘어났다.
그리고 기존 Avengers 에 1을 더한 숫자는 현재의 Avengers 의 숫자와 같을것이다.

하지만 Java 에서는 위 코드에서 현재 Class 에 선언된 멤버변수 avengers 를 다른 스레드가 수정할 수 있으며, 혹시라도 새로운 Avenger 를 추가하던 도중 다른 스레드에서 avengers 조작했다면 예외가 던져질지도 모른다.

그래서 위의 코드는 운이 좋다면 잘 실행되고, 운이 나쁘다면 예외가 던져지는 불쌍한 코드이다.

하지만 JavaScript 에선 이런 일이 일어나지 않는다.

JavaScript 의 코드는 항상 `실행-완료 (Run-to-completion)` 을 보장한다. 무슨 뜻인고 하면 위의 Java Code 를 JavaScript 로 변환한다고 하면 절대 오류가 일어나지 않는다!

JavaScript 는 코드가 해석되고 수행될 때는 다른 코드의 실행이 되지 않는다. 어떠한 방법으로도 한번 수행되는 코드 사이에 다른 작업이 개입할 수 없다.

## 그래서 Promise 는 뭔데?

사설이 길었다. 이제부터 제목에 맞는 내용이다.

Promise는 JavaScript 에서 여러 방법으로 수행하던 비동기 처리에 대한 표준이다. 지금 (now) 은 아니지만 나중 (future) 에 처리될 것으로 생각되는 처리를 표현할 수 있다.

Promise 는 꽤 단순한(해 보이는) [Promise/A Plus](https://promisesaplus.com/) 스펙에 맞춰 구현되어 있으며, ES2015 에서 표준으로 정해지기 전에도 여러 오픈소스 라이브러리 들이 이 표준을 구현하였고 사용되는 것들도 꽤 많다.

ES2015 에서는 언어 자체에 Promise 를 Native 로 지원하게 되어서 위의 라이브러리를 쓰지 않고도 편하게 Promise 를 사용할 수 있고, 추가적으로 위 라이브러리를 써서 유틸성도 얻을 수 있다.

기본 사용법은 다음과 같다

```javascript
var promise = new Promise(function(resolve, reject) {
    // implementation ...
});
promise.then(function(data) {
        // ... fulfilled callback ...
})
promise.catch(function() {
    // ... reject callback ...
});
```

Promise 의 then 과 reject 메서드는 [체이닝 메서드](https://en.wikipedia.org/wiki/Method_chaining) 로서 다음과 같이 코딩할 수도 있다

```javascript
promise
    .then(function(data) {
            // ... fulfilled callback ...
    })
    .catch(function() {
        // ... reject callback ...
    });
```

### 체이닝

앞서 말했지만 then 을 연결할 경우 앞선 promise 의 결과가 다음 then 의 인자로 연결된다는 점이다.

다음 코드를 보자

```javascript
new Promise(function(resolve, reject) {
        resolve(100); // resolved!
    })
    .then(function(value) { // 앞선 결과를 연결한다.
        return value * 2
    })
    .then(function(value) {
        return value - 10
    })
    .then(function(value) {
        return value + 60
    })
    .then(function(value) {
        console.log(value); // 결과는 250.
    });
```

만일 then 에서 아무것도 반환하지 않을 경우 undefined 가 전달된다

더 재미있는건 Promise 를 반환할 경우 그 Promise 로 다음 then 값이 대체된다는 점이다.

## 상태

Promise 는 반드시 3개의 상태를 가지며 각 상태들에 진입하면 전의 상태로는 돌이킬 수 없다.

3개의 상태는

- pending
- fulfilled
- rejected

가 있다.

## setTimeout, setInterval VS Promise

## jQuery Deferred 와의 비교

## 응용

## 결론

## 참고
- [BsideSoft 공식 블로그 # 동기화 vs 비동기화 1](http://www.bsidesoft.com/?p=399)
- [BsideSoft 공식 블로그 # 동기화 vs 비동기화 2](http://www.bsidesoft.com/?p=414)
- [BsideSoft 공식 블로그 # 동기화 vs 비동기화 3](http://www.bsidesoft.com/?p=423)

#### ES5 용 구현체들 (중 많이 쓰이는 것들)

- [jQuery Deferred](https://api.jquery.com/category/deferred-object/)
- [bluebird](https://github.com/petkaantonov/bluebird/)
- [q](https://github.com/kriskowal/q)
