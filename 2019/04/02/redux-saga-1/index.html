<!DOCTYPE html><html><head><meta charset="utf-8"><title>Redux-Saga 소개 | NonBlock</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Redux-Saga 소개"><meta property="og:type" content="article"><meta property="og:title" content="Redux-Saga 소개"><meta property="og:url" content="https://blog.javarouka.me/2019/04/02/redux-saga-1/index.html"><meta property="og:site_name" content="NonBlock"><meta property="og:description" content="Redux-Saga 소개"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://blog.javarouka.me/asset/images/js.jpg"><meta property="article:published_time" content="2019-04-01T15:00:00.000Z"><meta property="article:modified_time" content="2020-09-22T04:18:02.875Z"><meta property="article:author" content="JavaRouka"><meta property="article:tag" content="javascript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.javarouka.me/asset/images/js.jpg"><link rel="apple-touch-icon" sizes="57x57" href="/fav/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/fav/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/fav/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/fav/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/fav/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/fav/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/fav/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/fav/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/fav/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/fav/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/fav/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/fav/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/fav/favicon-16x16.png"><link rel="manifest" href="/fav/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/fav/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><meta name="keywords" content="javascript"><link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-85661914-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-85661914-1")</script><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"><script type="text/javascript">var __sauron=__sauron||[];__sauron.push(["pageview"]),function(){var e="https://analy1.sauroneyes.com/";__sauron.push(["setTrackerUrl",e+"analytics/"]);var a=document,r=a.createElement("script"),s=a.getElementsByTagName("script")[0];r.type="text/javascript",r.async=!0,r.defer=!0,r.src=e+"js/sauron.js",s.parentNode.insertBefore(r,s)}()</script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="alternate" href="/atom.xml" title="NonBlock" type="application/atom+xml">
</head><body><div class="site-wrapper"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">N </span><span class="b">o </span><span class="b">n </span><span class="w">B </span><span class="b">l </span><span class="w">o </span><span class="b">c </span><span class="b">k </span></a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><aside class="category-wrapper"><div class="site-category"><a class="nav flex-column-link" href="/categories/effective-java/">Effective Java</a><a class="nav flex-column-link" href="/categories/review/">Review</a><a class="nav flex-column-link" href="/categories/tech/">Tech</a><a class="nav flex-column-link" href="/categories/tech/translate/">Translate</a><a class="nav flex-column-link" href="/categories/book/">book</a><a class="nav flex-column-link" href="/categories/java/">java</a><a class="nav flex-column-link" href="/categories/java/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/javascript/">javascript</a><a class="nav flex-column-link" href="/categories/javascript/react/">react</a><a class="nav flex-column-link" href="/categories/javascript/react/redux-saga/">redux-saga</a><a class="nav flex-column-link" href="/categories/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/kotlin/tech/">tech</a><a class="nav flex-column-link" href="/categories/kotlin/tech/translate/">translate</a></div><div class="search"><form name="searchform" id="searchform" class="u-search-form"><input type="text" id="searchinput" class="u-search-input st-default-search-input" data-list-highlight="true" data-list-value-completion="true" placeholder="Looking for something in this blog?"> <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit"><span class="icon icon-search"></span></button></form></div><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-redux-saga-1" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">Redux-Saga 소개</h1><h2 class="article-sub-title">Redux-Saga 소개</h2><div class="article-meta">Posted on <time class="article-time" datetime="2019-04-01T15:00:00.000Z" itemprop="datePublished">2019-04-02</time></div></header><div class="article-entry" itemprop="articleBody"><h2 id="Redux-와-부수효과"><a href="#Redux-와-부수효과" class="headerlink" title="Redux 와 부수효과"></a>Redux 와 부수효과</h2><p>Redux 는 상태 관리를 도와주는 간단한 라이브러리이다. 실제로도 소스코드 용량은 매우 작고, 해주는 일도 매우 단순하다.</p><h3 id="Redux-복습"><a href="#Redux-복습" class="headerlink" title="Redux 복습"></a>Redux 복습</h3><p>Redux 를 다들 잘 알겠지만 복습해보자.</p><ul><li>스토어</li><li>액션</li><li>리듀서</li></ul><p>Redux 는 자신이 관리하는 데이터 모음인 <code>상태(state)</code> 를 <code>스토어(Store)</code> 라는 저장소에 두고 이 상태를 변경할 수 있는 것은 <code>액션(action)</code> 으로 제한한다.</p><p>액션은 단순한 문자열이며 이 액션으로 상태를 변경하기 위해서는 <code>스토어(Store)</code> 에 <code>디스패치(dispatch)</code> 하는 행위가 필요하다.</p><p><code>디스패치(dispatch)</code> 할 때 전달할 정보는 다음과 같은 인터페이스를 가지는 일반 자바스크립트 객체이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReduxDispatchAction &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>, <span class="comment">// required 액션은 반드시 문자열이어야 한다.</span></span><br><span class="line">    [prop:<span class="built_in">any</span>]?: <span class="built_in">any</span> <span class="comment">// optional N. 나머지는 옵셔널이며 객체에 할당할 수 있는 모든 키/값이 올 수 있다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>디스패치 함수는 스토어가 가지고 있고, 시그니쳐는 다음과 같다</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReduxStore &#123;</span><br><span class="line"></span><br><span class="line">    dispatch(action: ReduxDispatchAction) =&gt; <span class="built_in">void</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 스토어 기타 함수, subscribe 등</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제 사용 코드는 다음과 같다.</p><p><code>doAmazingShow</code> 라는 액션을 payload 속성과 같이 디스패치하는 코드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 액션</span></span><br><span class="line"><span class="keyword">const</span> doAmazingShow = <span class="string">&#x27;doAmazingShow&#x27;</span></span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    action: doAmazingShow,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        invited: [ <span class="string">&#x27;Cool&#x27;</span>, <span class="string">&#x27;Hot&#x27;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>디스패치의 결과로 <code>reducer</code>가 실행된다. <code>reducer</code> 는 모든 액션이 디스패치 될 때마다 액션과 현재 상태를 받는 단순한 함수다.</p><p>reducer 의 시그니처는 다음과 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Reducer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param currentState 현재 상태</span></span><br><span class="line"><span class="comment">     * @param action 디스패치를 통해 전달된 액션</span></span><br><span class="line"><span class="comment">     * @return 새로운 상태 객체</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    (currentState): <span class="built_in">object</span>, action: ReduxDispatchAction) =&gt; <span class="built_in">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 흐름은 한번의 실행 스택으로 수행되는데, 이 뜻은 다수의 액션 수행을 해도 그 순서를 보장한다는 뜻이다. 스크립트의 동작이 원래 그렇듯이 말이다.</p><p>여기까지가 Redux 의 간단한 흐름이다. 더 자세한 설명을 원하면 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://lunit.gitbook.io/redux-in-korean/">공식 사이트</a>를 보자.</p><blockquote><p>Reducer 라는 네이밍은 Redux 제작자의 네이밍인데, 개인적으로는 액션처리기 같은 직관적 네이밍이 어땠을까 한다. 그럼 Redux 가 아니라 Execer 가 되었을지도 모르겠다. 그렇지만 액션을 누적해 하나의 상태로 처리하는 <code>reduce</code> 측면에서는 원래 이름인 Redux 가 더 어울린다.</p></blockquote><h3 id="Side-Effect"><a href="#Side-Effect" class="headerlink" title="Side Effect"></a>Side Effect</h3><p>실무에서 Redux 를 쓰다보면 액션이 동시다발적으로 발생되며, 액션 중간에 실제 Redux 액션이 아닌 일반 로직이 수행되거나 Ajax Call 등의 서버 리퀘스트도 발생한다. 그 와중에 여러 액션의 실행 보장도 해줘야 하는데, 자칫 코드가 상당히 난해해질 수 있다.</p><p>이럴때 사용을 고려해볼만한 라이브러리들이 몇개 있는대 대표적으로 Redux-Saga, Rx-Observable, MobX 등이다.</p><p>Redux-Saga 나 Rx-Observable 등을 Redux 와 같이 사용할때 이점으로 보통 비동기 처리가 손쉽다…라는 문구로 광고가 보통 되지만, 구조화된 Redux 설계를 했다면 비동기 처리도 그렇게 더러워지진 않는다. (다시 말하면 설계가 좋지 않다면 유지보수가 힘든 스파게티가 나온다는 뜻이다)</p><p>사실 단순 비동기 처리보다 더 큰 어려움은 액션이 여러 의미를 가지게 되고 그에 맞춰 기능이 확장되면서 액션이 다른 액션과 체이닝되기 시작할 때이다.</p><p>이런 기능들을 기존의 Redux 로 일일해 대응하다보면 코드가 순식간에 누더기가 된다. 순진하게 액션 처리 후 다른액션, 그리고 그 액션 성공 후 다른 액션… 으로 이어지는 코드는 대부분 스파게티맛을 맛본다.</p><p>예를 들어 회원 정보 페이지가 있다고 해보자. 다음은 액션을 디스패치하는 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;START_USER_LOADING&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;FAIL_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 앱에 새로운 기능이 추가되어 유저 로딩 후 사용자의 팔로워를 같이 로딩해야 한다고 해보자.</p><p>코드는 다음과 같이 변경할 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadFollowersFrom = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;START_FOLLOWER_LOADING&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">await</span> Users.loadFollowersFrom(userId);</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;END_FOLLOWER_LOADING&#x27;</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;FAIL_FOLLOWER_LOADING&#x27;</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;START_USER_LOADING&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 이 부분이 추가되었다. 유저 정보 로딩 후 실행한다.</span></span><br><span class="line">        loadFollowersFrom()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;FAIL_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>별로 나빠보이지 않는다. 그러나 이 코드는 앞으로의 코드 변경에 꽤나 힘들어질 수 있는 스타트를 끊은 코드다.</p><p>지금은 유저 정보 로딩 후 팔로워 로딩만 추가했지만 앞으로 이후 수많은 유저 관련 정보가 로딩될 수 있다.</p><p>예를 들면 추가적으로 유저 정보 로딩 후, 그 정보의 유무에 따라 현금성 결제 포인트와 이 유저를 방문한 유저를 로딩해야 할 수 있다. 그리고 사용성 트래킹을 위해 로그를 서버에 전송할 수도 있다.</p><p>그 호출 책임은 전부 <code>loadUser</code> 라는 함수가 담당하고 있다.</p><p>원래의 목적은 유저를 로딩한다는 목적으로 만들었지만, 이제는 유저도 로딩하고, 포인트도 로딩하고, 팔로워도 로딩하고 … 하는 함수가 되었다. 이쯤되면 이름을 <code>loadUserThenFollowers</code> 같은 이름으로 바꿔야 할지도 모르겠다.</p><p>더욱 힘들게 하는 건 만일 유저 정보 로딩 후 실행되는 부수 액션들(팔로워, 포인트…) 중 하나가 오류가 났을 때 각 부수 액션들끼리도 서로 영향을 줄 수 있다. 만일 비즈니스적으로 어떤 액션은 주변의 오류와 상관없이 진행해야 할 수도 있고 중단해야 할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;START_USER_LOADING&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FIXME 거슬리는 부분 1</span></span><br><span class="line">        <span class="comment">// 비즈니스에 따라 처리해야 할 로직이 직접적으로 박힌다.</span></span><br><span class="line">        <span class="comment">// 이쯤 되면 함수 이름을 loadUser 가 아닌 다른걸로 바꾸는 걸 정말로 고려하는게 좋겠다.</span></span><br><span class="line">        <span class="keyword">await</span> loadFollowersFrom(userId)</span><br><span class="line">        <span class="keyword">await</span> loadPoint(userId)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;FAIL_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// FIXME 거슬리는 부분 2</span></span><br><span class="line">        <span class="comment">// 오류 여부에 관계없이 실행해야 한다.</span></span><br><span class="line">        <span class="keyword">await</span> writeUserActionLogging(userId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 본래 액션 말고도 그 액션에 따라 다른 액션이나 이벤트가 파생되는건 꽤나 흔한 일이다.</p><p>이런 일을 <code>부수효과 (Side-Effect)</code> 라고 한다.</p><ul><li>Ajax 콜</li><li>비동기 타이머</li><li>애니메이션 후 콜백</li><li>요청 중 취소</li><li>스로틀링</li><li>디바운싱</li><li>페이지 이동</li></ul><p>이러한 것은 일반적인 Redux의 액션 흐름으로는 나타내기가 조금 어렵고, 비동기 수행시에는 어디엔가 dispatch 함수의 레퍼런스를 가지고 있다가 필요할때에 호출하면서 수행해야 한다.</p><p>이러한 부수 효과들은 Redux-Saga 를 쓴다면 꽤 단순하고 직관적으로 풀어낼 수 있다.</p><h3 id="Redux-Saga-적용"><a href="#Redux-Saga-적용" class="headerlink" title="Redux Saga 적용"></a>Redux Saga 적용</h3><p>다음은 Redux-Saga 로 위의 문제를 다시 작성해본 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 유저 현금성 포인트를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadPoint = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">yield</span> call(Point.load, userId);</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;END_USER_POINT_LOADING&#x27;</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;FAIL_USER_POINT_LOADING&#x27;</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 특정 유저의 팔로워를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadFollowers = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">yield</span> call(Users.loadFollowersFrom, userId);</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;END_FOLLOWER_LOADING&#x27;</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;FAIL_FOLLOWER_LOADING&#x27;</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 유저 정보를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadUser = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">yield</span> call(Users.loadUser, userId)</span><br><span class="line">        <span class="keyword">yield</span> put((&#123; <span class="attr">type</span>: <span class="string">&#x27;END_USER_LOADING&#x27;</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put((&#123; <span class="attr">type</span>: <span class="string">&#x27;FAIL_USER_LOADING&#x27;</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 각 워커의 시작점을 관리</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> watcher = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;START_USER_LOADING&#x27;</span>, loadUser);</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;END_USER_LOADING&#x27;</span>, loadFollowers);</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;END_USER_LOADING&#x27;</span>, loadPoint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">saga.runSaga(watcher)</span><br></pre></td></tr></table></figure><blockquote><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*">Generator</a>를 모르는 사람은 문법에 어지러울지 모르겠다. <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*">Generator</a>가 중요한 부분이 아니니 실행 흐름에 거쳐가는 키워드로 보자.</p></blockquote><p>Saga 는 액션을 구독하는 Watcher 와 실제 작업을 수행하는 Worker 의 구성을 따른다</p><ul><li>Watcher<ul><li>watcher 함수</li></ul></li><li>Worker<ul><li>loadUser</li><li>loadFollowers</li><li>loadPoint</li></ul></li></ul><p>먼저 액션을 처리할 워커 함수를 전부 정의한다. loadUser, loadFollowers, loadPoint 셋이 있다. 그리고 매니저가 될 와쳐 함수를 정의하고 그 함수에서 실행을 정의하면 끝이다.</p><p>이후에 좀 더 설명하겠지만 takeXXX 류의 함수는 특정 액션(들) 을 감시하는 함수이고, put 은 실제 액션을 dispatch 하는 함수이다. Redux 의 Dispatch 함수와 동일하다. (이것들을 Saga 에서는 Saga-Effect 라고 부른다. 이후에 설명한다.)</p><p>위 예제에서는 <code>loadUser</code> 는 <code>START_USER_LOADING</code> 가 디스패치될 경우 매번 loadUser 를 실행하게 되어 있다. 그 아래 두개의 함수도 마찬가지로 <code>END_USER_LOADING</code> 가 디스패치 될 경우 각각의 두번째 인자의 함수를 실행한다.</p><p>코드량이 약간 줄은 것 외에는 더 복잡해졌다고 생각할 수 있다.</p><p>하지만 <strong>각 함수들이 자신만의 일에 집중하는 구조로 바뀌었으며 실행 시점을 알기 편해졌다.</strong> 자신 외에 별도 부수효과에 신경쓸 필요가 없다.</p><p>만일 여기서 팔로워나 포인트를 유저 정보 로딩 후가 아닌 다른 타이밍에 호출하려는걸 추가한다면 다음과 같이 하면 된다. 실제 loadXXX 류의 작업 함수는 건드릴 필요가 없다.</p><p>다음과 같이 watcher 함수에 watching 할 액션만 추가로 넣어주면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;START_USER_LOADING&#x27;</span>, loadUser);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery([</span><br><span class="line">        <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;START_FOLLOWER_LOADING&#x27;</span>, <span class="comment">// 추가 </span></span><br><span class="line">    ], loadFollowersFrom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery([</span><br><span class="line">        <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;START_POINT_LOADING&#x27;</span>, <span class="comment">// 추가</span></span><br><span class="line">    ], loadPointFrom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 액션에 대해 로깅을 추가한다고 하면 다음 구문만 추가하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> takeEvery([</span><br><span class="line">    <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;END_USER_POINT_LOADING&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;END_FOLLOWER_LOADING&#x27;</span>, </span><br><span class="line">], writeUserActionLogging);</span><br></pre></td></tr></table></figure><p>이렇게 액션의 감시와 해당 부수효과들을 아예 분리해서 각자의 일만 하게 두었다. 이런 방식으로는 각 액션별로 서로 영향을 주는 표현을 액션만으로 쉽게 나타낼 수 있게 된다. 실제 디스패치 하는 측에서도 비동기의 성공 여부를 고민할 것 없이 동기적 디스패치를 쓰는 것만으로 충분하다.</p><p>실제 작업은 Saga 내부적으로 처리되며 디스패치 된다.</p><h2 id="Saga-Effect"><a href="#Saga-Effect" class="headerlink" title="Saga-Effect"></a>Saga-Effect</h2><p>Saga 는 이러한 부수효과를 처리하는 이펙트들을 지원한다. 앞의 코드에서는 put 과 takeEvery 가 나왔었다.</p><blockquote><p>공식 문서의 Effect 들 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://redux-saga.js.org/docs/api/#effect-creators">https://redux-saga.js.org/docs/api/#effect-creators</a></p></blockquote><p>모든 effect 들은 반드시 yield keyword 와 함께 사용해야 한다</p><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p><code>take</code> 는 특정 액션을 감시하는 용도로 쓰인다.</p><p>다음 코드는 REQUEST_ORDER 액션이 디스패치될 때까지 기다린 후 Api.requestOrder 를 호출하는 예제이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">&#x27;REQUEST_ORDER&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line">    <span class="comment">// ... process ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>블럭된다는 성질을 이용해서 다음과 같이 매번 액션에 대해 반응하는 saga 를 만들 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 무한 루프</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">&#x27;REQUEST_ORDER&#x27;</span>); <span class="comment">// 하지만 이 라인에서 블럭된다.</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line">        <span class="comment">// ... process ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 saga 를 만들일이 많으므로 공식적으로 이런 동작의 헬퍼인 takeEvery, takeLatest, takeLeading 등을 제공하고 있다</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put effect 는 단순하다.</p><p>redux의 dispatch 함수와 완전히 동일하다. 이 effect 는 블럭되지 않기에 조심해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 무한 루프</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">&#x27;REQUEST_ORDER&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 결과를 스토어에 디스패치(put) 한다.</span></span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;RESPONSE_ORDER&#x27;</span>, result &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>새로운 하위 saga 태스크를 생성하는 effect 이다.</p><p>fork 는 블럭되지 않으며 호출 시점에 호출자는 부모 task 가 되고 fork 된 saga 는 자식 task 가 된다. 부모 task 가 취소되면 자식 task 도 취소된다.</p><p>명시적으로 특정 자식 태스크만 취소시킬수도 있다.</p><p>아래에 예제가 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parentTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> task1 = <span class="keyword">yield</span> fork(childTask1);</span><br><span class="line">    <span class="keyword">const</span> task2 = <span class="keyword">yield</span> fork(childTask2);  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... do something ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 아직 동작중이면 취소시킨다.</span></span><br><span class="line">    <span class="keyword">if</span>(task2 &amp;&amp; task2.isRunning()) &#123;</span><br><span class="line">        task2.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>call 은 블럭되는 fork 라고 보면 된다. 인자로 함수나 saga task 를 받을 수 있다.</p><p>두번째부터는 실행될 함수나 사가의 인자로 들어간다.</p><p>보통 Promise 등의 실행 (보통은 Ajax Call) 에 쓰이며 Promise 가 resolve 될 때까지 블럭된다.</p><p>예제는 위에 이미 있으므로 생략한다.</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>redux 의 state 에서 특정 상태를 가져올때 사용하는 effect 이다.</p><p>redux-thunk 의 getState 와 비슷하지만, 인자로 셀렉터를 줄 수 있다.</p><p>블럭 effect 이다.</p><p>아래 예제는 활성 유저를 redux state 에서 찾은 뒤 그 아이디로 유저 정보를 Ajax call 하는 예제이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeUserSelector = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.user.activeUser;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> getUserData = <span class="function"><span class="params">userId</span> =&gt;</span> ajax(<span class="string">`/user/data/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parentTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> activeUser = <span class="keyword">yield</span> select(activeUserSelector);</span><br><span class="line">    <span class="keyword">const</span> activeUserData = <span class="keyword">yield</span> call(getUserData, activeUser.userId); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="article-tags"><a class="tag-none-link" href="/tags/javascript/" rel="tag">javascript</a></div><section id="comments" class="white-box"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></article><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5bf3f68d0a53e4d6"></script><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; <a href="https://blog.javarouka.me">NonBlock</a> Theme by <a href="http://artifact.me/" target="_blank" rel="external nofollow noopener noreferrer">Art Chen</a>.</div><div>Powered by <a target="_blank" href="https://hexo.io/" rel="external nofollow noopener noreferrer">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></aside></div><div class="site-sidebar"><div class="sidebar-switch clearfix show" style="display:block"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-bio" style="display:none"><div class="about-me clearfix"><div class="avatar"><img src="https://avatars2.githubusercontent.com/u/1438503?v=4&s=250"></div><div class="info"><a class="name dark-btn" href="/about">JavaRouka</a></div><div class="info"><span class="item desc">javarouka 의 기술블로그</span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="mailto:javarouka@gmail.com" class="mail" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-mail"></span> </a><a href="https://github.com/javarouka" class="github" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-github"></span> </a><a href="https://www.facebook.com/hanghui.i" class="facebook" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-facebook"></span></a></div><div class="shortcuts clearfix"><div class="bk"><a href="#header" class="dark-btn window-nav"><span class="icon icon-chevron-thin-up"></span> <span class="text">Back to Top</span></a></div><div class="bk"><a href="#footer" class="dark-btn window-nav"><span class="icon icon-chevron-thin-down"></span> <span class="text">Go to Bottom</span></a></div></div></div><div class="site-post-nav show" style="display:block"><div class="site-post-nav-box"><a href="/2019/04/07/book-elasticsearch-in-action/" class="icon icon-chevron-thin-left"><a href="/2019/04/07/book-elasticsearch-in-action/" class="site-post-nav-text">[책] Elasticsearch In Action</a></a></div><div class="site-post-nav-box"><a href="/2018/11/28/java%EC%9D%98-HashMap-%EA%B5%AC%ED%98%84%EC%97%90-%EB%8C%80%ED%95%B4/" class="site-post-nav-text">Java HashMap 구현에 대해 (Effective java 3th - Item11)</a> <a href="/2018/11/28/java%EC%9D%98-HashMap-%EA%B5%AC%ED%98%84%EC%97%90-%EB%8C%80%ED%95%B4/" class="icon icon-chevron-thin-right"></a></div></div><div class="site-toc show" style="display:block"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redux-%EC%99%80-%EB%B6%80%EC%88%98%ED%9A%A8%EA%B3%BC"><span class="toc-number">1.</span> <span class="toc-text">Redux 와 부수효과</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux-%EB%B3%B5%EC%8A%B5"><span class="toc-number">1.1.</span> <span class="toc-text">Redux 복습</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Side-Effect"><span class="toc-number">1.2.</span> <span class="toc-text">Side Effect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux-Saga-%EC%A0%81%EC%9A%A9"><span class="toc-number">1.3.</span> <span class="toc-text">Redux Saga 적용</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Saga-Effect"><span class="toc-number">2.</span> <span class="toc-text">Saga-Effect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#take"><span class="toc-number">2.1.</span> <span class="toc-text">take</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put"><span class="toc-number">2.2.</span> <span class="toc-text">put</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">2.3.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call"><span class="toc-number">2.4.</span> <span class="toc-text">call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">2.5.</span> <span class="toc-text">select</span></a></li></ol></li></ol></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo"</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script type="text/javascript">var disqus_shortname="https-javarouka-github-io",disqus_url="https://blog.javarouka.me/2019/04/02/redux-saga-1/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>