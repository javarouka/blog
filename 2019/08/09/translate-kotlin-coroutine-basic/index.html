<!DOCTYPE html><html><head><meta charset="utf-8"><title>[번역] Kotline Coroutine Basic | NonBlock</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="코틀린 기본 공식 문서 번역"><meta property="og:type" content="article"><meta property="og:title" content="[번역] Kotline Coroutine Basic"><meta property="og:url" content="https://blog.javarouka.me/2019/08/09/translate-kotlin-coroutine-basic/index.html"><meta property="og:site_name" content="NonBlock"><meta property="og:description" content="코틀린 기본 공식 문서 번역"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://blog.javarouka.me/asset/images/rrr.jpg"><meta property="article:published_time" content="2019-08-08T15:00:00.000Z"><meta property="article:modified_time" content="2020-09-22T04:18:02.877Z"><meta property="article:author" content="JavaRouka"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="coroutine"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.javarouka.me/asset/images/rrr.jpg"><link rel="apple-touch-icon" sizes="57x57" href="/fav/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/fav/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/fav/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/fav/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/fav/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/fav/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/fav/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/fav/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/fav/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/fav/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/fav/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/fav/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/fav/favicon-16x16.png"><link rel="manifest" href="/fav/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/fav/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><meta name="keywords" content="kotlin,coroutine"><link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700" rel="stylesheet"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-85661914-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-85661914-1")</script><link rel="stylesheet" href="/icomoon/style.css"><link rel="stylesheet" href="/style.css"><script type="text/javascript">var __sauron=__sauron||[];__sauron.push(["pageview"]),function(){var e="https://analy1.sauroneyes.com/";__sauron.push(["setTrackerUrl",e+"analytics/"]);var a=document,r=a.createElement("script"),s=a.getElementsByTagName("script")[0];r.type="text/javascript",r.async=!0,r.defer=!0,r.src=e+"js/sauron.js",s.parentNode.insertBefore(r,s)}()</script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="alternate" href="/atom.xml" title="NonBlock" type="application/atom+xml">
</head><body><div class="site-wrapper"><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><script>document.getElementById("loading-bar").style.width="20%"</script><header id="header" class="site-header clearfix"><a class="logo square clearfix" href="/"><span class="b">N </span><span class="b">o </span><span class="b">n </span><span class="w">B </span><span class="b">l </span><span class="w">o </span><span class="b">c </span><span class="b">k </span></a><a class="me square site-nav-switch clearfix"><span class="b"><span class="icon icon-menu"></span></span></a></header><aside class="category-wrapper"><div class="site-category"><a class="nav flex-column-link" href="/categories/effective-java/">Effective Java</a><a class="nav flex-column-link" href="/categories/review/">Review</a><a class="nav flex-column-link" href="/categories/tech/">Tech</a><a class="nav flex-column-link" href="/categories/tech/translate/">Translate</a><a class="nav flex-column-link" href="/categories/book/">book</a><a class="nav flex-column-link" href="/categories/java/">java</a><a class="nav flex-column-link" href="/categories/java/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/javascript/">javascript</a><a class="nav flex-column-link" href="/categories/javascript/react/">react</a><a class="nav flex-column-link" href="/categories/javascript/react/redux-saga/">redux-saga</a><a class="nav flex-column-link" href="/categories/kotlin/">kotlin</a><a class="nav flex-column-link" href="/categories/kotlin/tech/">tech</a><a class="nav flex-column-link" href="/categories/kotlin/tech/translate/">translate</a></div><div class="search"><form name="searchform" id="searchform" class="u-search-form"><input type="text" id="searchinput" class="u-search-input st-default-search-input" data-list-highlight="true" data-list-value-completion="true" placeholder="Looking for something in this blog?"> <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit"><span class="icon icon-search"></span></button></form></div><script>document.getElementById("loading-bar").style.width="40%"</script><main id="main" class="clearfix"><article id="post-translate-kotlin-coroutine-basic" class="article white-box article-type-post" itemscope itemprop="blogPost"><header class="article-header"><h1 class="article-title" itemprop="name">[번역] Kotline Coroutine Basic</h1><h2 class="article-sub-title">코틀린 기본 공식 문서 번역</h2><div class="article-meta">Posted on <time class="article-time" datetime="2019-08-08T15:00:00.000Z" itemprop="datePublished">2019-08-09</time></div></header><div class="article-entry" itemprop="articleBody"><h1 id="원문"><a href="#원문" class="headerlink" title="원문"></a>원문</h1><p>이 글은 번역글입니다. 오역에 주의하세요.</p><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://kotlinlang.org/docs/reference/coroutines/basics.html">https://kotlinlang.org/docs/reference/coroutines/basics.html</a></p><p>이 섹션에서는 기본적인 코틀린의 컨셉을 설명한다.</p><h1 id="My-First-Coroutine"><a href="#My-First-Coroutine" class="headerlink" title="My First Coroutine"></a>My First Coroutine</h1><p>다음 코드를 실행해보라</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// non-blocking delay for 1 second (default time unit is ms)</span></span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>) <span class="comment">// print after delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main thread continues while coroutine is delayed</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// block main thread for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>모든 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-01.kt">여기</a>에 있다.</p></blockquote><p>코드 실행으로 다음과 같은 결과를 볼 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line">World!</span><br></pre></td></tr></table></figure><p>기본적으로 코루틴은 경량 스레드(light-weight thread)이다. 코루틴은 코루틴 스코프의 컨텍스트안의 빌더와 함께 시작된다.</p><p>여기서는 <code>GlobalScope</code> 에서 새 코루틴을 시작하고 있다. 이는 새 코루틴의 생명주기가 전체 어플리케이션의 생명주기에 제한된다는 것을 의미한다.</p><p><code>GlobalScope.launch &#123; ... &#125;</code> 를 <code>thread &#123; ... &#125;</code> 로 <code>delay &#123; ... &#125;</code> 을 <code>Thread.sleep &#123; ... &#125;</code> 로 바꿔도 같은 결과를 얻을 수 있다. 한번 해보자.</p><p>만일 <code>GlobalScope.launch</code> 를 <code>thread</code> 로 바꾸려고 하기 시작하면 컴파일러는 다음과 같은 에러를 낸다:</p><blockquote><p>Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function<br>(에러: 코틀린: Suspend 함수들은 코루틴이나 다른 Suspend 함수에서의 호출만을 허용한다.)</p></blockquote><p><code>delay</code> 는 코루틴 안에서만 사용되는, 코루틴을 중단 (suspend) 하고 스레드를 블럭하지 않는 특별한 <code>sespending function</code> 이기 때문이다.</p><h1 id="Bridging-blocking-and-non-blocking-worlds"><a href="#Bridging-blocking-and-non-blocking-worlds" class="headerlink" title="Bridging blocking and non-blocking worlds"></a>Bridging blocking and non-blocking worlds</h1><p>첫 예제는 같은 코드 안에 넌블럭킹(non-blocking) <code>delay(...)</code> 와 블럭킹(blocking) <code>Thread.sleep</code> 코드가 혼재되어 있다. 무엇이 블럭킹이고 무엇이 아닌지 따라가기 어려울 것이다. <code>runBlocking</code> 코루틴 빌더를 사용해서 블럭킹에 대해 명확히 밝혀보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main thread continues here immediately</span></span><br><span class="line">    runBlocking &#123;     <span class="comment">// but this expression blocks the main thread</span></span><br><span class="line">        delay(<span class="number">2000L</span>)  <span class="comment">// ... while we delay for 2 seconds to keep JVM alive</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-02.kt">여기</a>에 있다</p></blockquote><p>결과는 같지만, 이 코드는 단지 넌블럭킹 <code>delay</code> 를 사용한다. 메인 스레드를 실행하는 <code>runBlocking</code> 은 <code>runBlocking</code> 내부의 코루틴이 완료될 때까지 블럭된다.</p><p>이 예제는 더 관용적 방법으로 재작성할 수 있는데, main 함수 실행을 <code>runBlocking</code> 을 사용해 감싸는 것이다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; <span class="comment">// start main coroutine</span></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main coroutine continues here immediately</span></span><br><span class="line">    delay(<span class="number">2000L</span>)      <span class="comment">// delaying for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-02b.kt">여기</a>에 있다</p></blockquote><p>여기의 <code>runBlocking&lt;Unit&gt; &#123; ... &#125;</code> 은 최상위 메인 코루틴 시작에 사용되는 어댑터로서 작동한다. Unit 반환 형식을 명시적으로 지정하는데, 코루틴의 정상적인 메인 함수는 <code>Unit</code> 을 반환해야 하기 때문이다.</p><p>다음은 suspending 함수의 유닛 테스트를 작성하는 방법이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testMySuspendingFunction</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// here we can use suspending functions using any assertion style that we like</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Waiting-for-a-job"><a href="#Waiting-for-a-job" class="headerlink" title="Waiting for a job"></a>Waiting for a job</h1><p>다른 코루틴이 동작할 동안 스레드의 시간을 지연키시는 것은 좋은 접근법이 아니다. 실행된 백그라운드 Job 이 완료될 때까지 명확하게 기다리자:<br>(역자: 지금까지의 예제 코드가 코루틴이 종료될 때까지 <code>Thread.sleep</code> 으로 기다리는 부분을 말하고 있다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">// launch a new coroutine and keep a reference to its Job</span></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">job.join() <span class="comment">// wait until child coroutine completes</span></span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-03.kt">여기</a>에 있다</p></blockquote><p>여전히 결과는 같지만, 메인 코루틴의 코드는 어떤 방식으로든 백드라운드 job 과 엮이지 않았다. 훨씬 낫다.</p><h1 id="Structured-concurrency"><a href="#Structured-concurrency" class="headerlink" title="Structured concurrency"></a>Structured concurrency</h1><p>코루틴의 일반적이고 바람직한 사용법을 소개한다. <code>GlobalScope.launch</code> 을 사용하면 최상위 코루틴을 만든다. 실제 가벼운 동작일지라도, 여전히 동작하는 동안 조금의 메모리를 사용한다. 만일 새로 실행된 코루틴의 참조를 잊어도 코루틴은 여전히 실행된다.</p><p>만일 코루틴의 코드에 행이 걸리는 경우(예를 들면 과도하게 장시간 지연이 발생하는 경우) 나 너무 많은 코루틴이 실행되어 메모리 부족이 오는 경우엔 어떻게 될까?<br>실행된 코루틴의 참조를 수동으로 유지하고 그것들을 <code>join</code> 하는 것은 오류가 나기 쉽다.</p><p>좋은 솔루션이 있다. 코드안에서 구조적 동시성을 사용할 수 있다. <code>GlobalScope</code> 에서 코루틴을 수행하는 대신, 일반적인 스레드와 함께 실행하는 것 처럼 수행중인 오퍼레이션 안의 특정 스코프에서 코루틴을 실행할 수 있다.</p><p>예제에서는 <code>runBlocking</code> 코루틴 빌더를 사용하여 코루틴으로 변환되는 메인 함수가 있다. <code>runBlocking</code> 을 포함한 코루틴 빌더로 생성되는 모든 코드 블럭 스코프에 <code>CoroutineScope</code> 인스턴스를 추가한다. 이 스코프 안에서는 코루틴을 명시적으로 <code>join</code> 하지 않고도 실행할 수 있는데, 바깥의 코루틴 (예제의 <code>runBlocking</code>) 이 그 스코프 안에서 실행된 모든 코루틴이 완료될 때까지 완료되지 않기 때문이다.</p><p>따라서 예제를 더욱 단순하게 만들 수 있다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; <span class="comment">// launch a new coroutine in the scope of runBlocking</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-03s.kt">여기</a>에 있다</p></blockquote><h1 id="Scope-builder"><a href="#Scope-builder" class="headerlink" title="Scope builder"></a>Scope builder</h1><p>다른 빌더가 제공하는 코루틴 스코프 외에, <code>coroutineScope Builder</code> 를 사용해서 자신만의 스코프를 가지는 코루틴을 선언할 수 있다.</p><p><code>coroutineScope Builder</code> 는 코루틴 스코프를 생성하고 모든 자식들이 완료될 때까지 완료되지 않는다.<br><code>runBlocking</code> 과 <code>coroutineScope</code> 의 주된 차이점은 <code>coroutineScope</code> 이 모든 자식이 완료될 때까지 현재 스레드를 차단하지 않는다는 것이다.</p><p>(역자: 관련해서 StackOverflow 의 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://stackoverflow.com/questions/53535977/coroutines-runblocking-vs-coroutinescope">이 질문</a> 도 한번 보자)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; </span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task from runBlocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123; <span class="comment">// Creates a coroutine scope</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>) </span><br><span class="line">            println(<span class="string">&quot;Task from nested launch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task from coroutine scope&quot;</span>) <span class="comment">// This line will be printed before the nested launch</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Coroutine scope is over&quot;</span>) <span class="comment">// This line is not printed until the nested launch completes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-04.kt">여기</a>에 있다</p></blockquote><h1 id="Extract-function-refactoring"><a href="#Extract-function-refactoring" class="headerlink" title="Extract function refactoring"></a>Extract function refactoring</h1><p><code>launch &#123; ... &#125;</code> 안의 코드를 별도 함수로 추출해 보자. 이 코드에 <code>함수 추출</code> 리팩토링(역자: Intellij의 기능을 사용한다) 을 하면 <code>suspend</code> 수정자와 함께 새로운 함수가 추출된다. 이게 여기서 다루는 첫번째 <code>suspending function</code> 이다.</p><p><code>suspending function</code> 은 코루틴 안에서 일반 함수처럼 사용될 수 있으며, 추가적인 기능으로 예제의 <code>delay</code> 처럼 코루틴 실행을 일시적으로 suspend 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is your first suspending function</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-05.kt">여기</a>에 있다</p></blockquote><p>그러나 추출된 함수에 현재 스코프에서 호출되는 코루틴 빌더가 포함되어 있으면 어떨까? 이 경우에 추출된 함수의 <code>suspend</code> 수정자는 충분하지 않다.</p><p><code>CoroutineScope</code> 에서 <code>doWorld</code> 를 확장 메소드(extension method) 로 만드는 것은 솔루션 중 하나이지만 API가 더 명확하지는 않으므로 항상 적용 가능한 것은 아니다.</p><p>관용적 솔루션은 대상 함수를 포함하는 클래스의 필드로 명시적 <code>CoroutineScope</code> 를 갖거나 외부 클래스가 <code>CoroutineScope</code> 를 구현할 때 암시적으로 그것을 필드로 가지는 것이다.</p><p>최후의 수단으로 <code>CoroutineScope (coroutineContext)</code> 를 사용할 수 있지만 이 방법으로는 실행 스코프를 더 이상 제어할 수 없기 때문에 이런 접근 방식은 구조적으로 안전하지 않다.</p><p>개인 API 만이 빌더를 사용할 수 있다.</p><p>(뭔소리여… 아래 원문 붙임)</p><blockquote><p>But what if the extracted function contains a coroutine builder which is invoked on the current scope? In this case suspend modifier on the extracted function is not enough. Making doWorld an extension method on CoroutineScope is one of the solutions, but it may not always be applicable as it does not make API clearer. The idiomatic solution is to have either an explicit CoroutineScope as a field in a class containing the target function or an implicit one when the outer class implements CoroutineScope. As a last resort, CoroutineScope(coroutineContext) can be used, but such approach is structurally unsafe because you no longer have control on the scope of execution of this method. Only private APIs can use this builder.</p></blockquote><h1 id="Coroutines-ARE-light-weight"><a href="#Coroutines-ARE-light-weight" class="headerlink" title="Coroutines ARE light-weight"></a>Coroutines ARE light-weight</h1><p>다음 코드를 보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">100_000</span>) &#123; <span class="comment">// launch a lot of coroutines</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-06.kt">여기</a>에 있다</p></blockquote><p>100K개의 코루틴을 시작하고 1초마다 후에 각 코루틴이 점을 찍는다. 이제 이 로직을 스레드로 시도해보라. 무슨 일이 일어날까?</p><p>(아마도 Thread 를 사용한 코드에서 메모리 부족 오류가 발생할 것이다)</p><h1 id="Global-coroutines-are-like-daemon-threads"><a href="#Global-coroutines-are-like-daemon-threads" class="headerlink" title="Global coroutines are like daemon threads"></a>Global coroutines are like daemon threads</h1><p>다음 코드는 <code>GlobalScope</code> 에서 “I’m sleeping” 을 1초에 두번 인쇄하고 그후 메인 함수에 약간의 <code>delay</code> 후 복귀하는 긴 시간의 코루틴을 실행한다:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&#39;m sleeping $i ...&quot;)</span><br><span class="line">        delay(500L)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delay(1300L) &#x2F;&#x2F; just quit after delay</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-07.kt">여기</a>에 있다</p></blockquote><p>실행하고 세줄이 찍히고 중단되는 걸 볼 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m sleeping 0 ...</span><br><span class="line">I&#39;m sleeping 1 ...</span><br><span class="line">I&#39;m sleeping 2 ...</span><br></pre></td></tr></table></figure><p>GlobalScope에서 시작된 액티브 코루틴은 프로세스를 <code>실행중인</code> 상태로 유지하지 않는다. 그것들은 데몬 스레드와 비슷하다.</p></div><div class="article-tags"><a class="tag-none-link" href="/tags/coroutine/" rel="tag">coroutine</a><a class="tag-none-link" href="/tags/kotlin/" rel="tag">kotlin</a></div><section id="comments" class="white-box"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></article><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5bf3f68d0a53e4d6"></script><script>document.getElementById("loading-bar").style.width="60%"</script></main><footer id="footer" class="clearfix"><div>&copy; <a href="https://blog.javarouka.me">NonBlock</a> Theme by <a href="http://artifact.me/" target="_blank" rel="external nofollow noopener noreferrer">Art Chen</a>.</div><div>Powered by <a target="_blank" href="https://hexo.io/" rel="external nofollow noopener noreferrer">Hexo</a>.</div></footer><script>document.getElementById("loading-bar").style.width="80%"</script><div class="overlay"></div></aside></div><div class="site-sidebar"><div class="sidebar-switch clearfix show" style="display:block"><a class="dark-btn active" data-toggle="toc"><span class="icon icon-list"></span> <span class="text">Index</span> </a><a class="dark-btn" data-toggle="bio"><span class="icon icon-person"></span> <span class="text">Bio</span></a></div><div class="site-bio" style="display:none"><div class="about-me clearfix"><div class="avatar"><img src="https://avatars2.githubusercontent.com/u/1438503?v=4&s=250"></div><div class="info"><a class="name dark-btn" href="/about">JavaRouka</a></div><div class="info"><span class="item desc">javarouka 의 기술블로그</span></div></div><div class="social clearfix"><a href="/atom.xml" class="feed" target="_blank" rel="external"><span class="icon icon-feed"></span> </a><a href="mailto:javarouka@gmail.com" class="mail" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-mail"></span> </a><a href="https://github.com/javarouka" class="github" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-github"></span> </a><a href="https://www.facebook.com/hanghui.i" class="facebook" target="_blank" rel="external nofollow noopener noreferrer"><span class="icon icon-facebook"></span></a></div><div class="shortcuts clearfix"><div class="bk"><a href="#header" class="dark-btn window-nav"><span class="icon icon-chevron-thin-up"></span> <span class="text">Back to Top</span></a></div><div class="bk"><a href="#footer" class="dark-btn window-nav"><span class="icon icon-chevron-thin-down"></span> <span class="text">Go to Bottom</span></a></div></div></div><div class="site-post-nav show" style="display:block"><div class="site-post-nav-box"><a href="/2019/08/10/translate-kotlin-Cancellation%20and%20timeouts/" class="icon icon-chevron-thin-left"><a href="/2019/08/10/translate-kotlin-Cancellation%20and%20timeouts/" class="site-post-nav-text"></a></a></div><div class="site-post-nav-box"><a href="/2019/04/07/interits-conposition/" class="site-post-nav-text">Java / Kotlin 의 상속과 구성 (Inheritance &amp; Composition) #1</a> <a href="/2019/04/07/interits-conposition/" class="icon icon-chevron-thin-right"></a></div></div><div class="site-toc show" style="display:block"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%EC%9B%90%EB%AC%B8"><span class="toc-number">1.</span> <span class="toc-text">원문</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#My-First-Coroutine"><span class="toc-number">2.</span> <span class="toc-text">My First Coroutine</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bridging-blocking-and-non-blocking-worlds"><span class="toc-number">3.</span> <span class="toc-text">Bridging blocking and non-blocking worlds</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Waiting-for-a-job"><span class="toc-number">4.</span> <span class="toc-text">Waiting for a job</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Structured-concurrency"><span class="toc-number">5.</span> <span class="toc-text">Structured concurrency</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scope-builder"><span class="toc-number">6.</span> <span class="toc-text">Scope builder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Extract-function-refactoring"><span class="toc-number">7.</span> <span class="toc-text">Extract function refactoring</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Coroutines-ARE-light-weight"><span class="toc-number">8.</span> <span class="toc-text">Coroutines ARE light-weight</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Global-coroutines-are-like-daemon-threads"><span class="toc-number">9.</span> <span class="toc-text">Global coroutines are like daemon threads</span></a></li></ol></div></div><script type="text/javascript">var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo"</script><script src="https://code.jquery.com/jquery-2.1.4.min.js"></script><script>window.jQuery||document.write('<script src="/js/jquery.js"><\/script>')</script><script src="/js/search.js"></script><script src="/js/app.js"></script><script type="text/javascript">var disqus_shortname="https-javarouka-github-io",disqus_url="https://blog.javarouka.me/2019/08/09/translate-kotlin-coroutine-basic/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script>document.getElementById("loading-bar").style.width="100%"</script></body></html>