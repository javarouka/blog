<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NonBlock</title>
  
  
  <link href="https://blog.javarouka.me/atom.xml" rel="self"/>
  
  <link href="https://blog.javarouka.me/"/>
  <updated>2020-09-22T04:18:02.877Z</updated>
  <id>https://blog.javarouka.me/</id>
  
  <author>
    <name>JavaRouka</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[번역] Kotline Coroutine Basic</title>
    <link href="https://blog.javarouka.me/2019/08/09/translate-kotlin-coroutine-basic/"/>
    <id>https://blog.javarouka.me/2019/08/09/translate-kotlin-coroutine-basic/</id>
    <published>2019-08-08T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="원문"><a href="#원문" class="headerlink" title="원문"></a>원문</h1><p>이 글은 번역글입니다. 오역에 주의하세요.</p><p><a href="https://kotlinlang.org/docs/reference/coroutines/basics.html">https://kotlinlang.org/docs/reference/coroutines/basics.html</a></p><p>이 섹션에서는 기본적인 코틀린의 컨셉을 설명한다.</p><h1 id="My-First-Coroutine"><a href="#My-First-Coroutine" class="headerlink" title="My First Coroutine"></a>My First Coroutine</h1><p>다음 코드를 실행해보라</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>) <span class="comment">// non-blocking delay for 1 second (default time unit is ms)</span></span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>) <span class="comment">// print after delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main thread continues while coroutine is delayed</span></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>) <span class="comment">// block main thread for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>모든 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-01.kt">여기</a>에 있다.</p></blockquote><p>코드 실행으로 다음과 같은 결과를 볼 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello,</span><br><span class="line">World!</span><br></pre></td></tr></table></figure><p>기본적으로 코루틴은 경량 스레드(light-weight thread)이다. 코루틴은 코루틴 스코프의 컨텍스트안의 빌더와 함께 시작된다. </p><p>여기서는 <code>GlobalScope</code> 에서 새 코루틴을 시작하고 있다. 이는 새 코루틴의 생명주기가 전체 어플리케이션의 생명주기에 제한된다는 것을 의미한다. </p><p><code>GlobalScope.launch &#123; ... &#125;</code> 를 <code>thread &#123; ... &#125;</code> 로 <code>delay &#123; ... &#125;</code> 을 <code>Thread.sleep &#123; ... &#125;</code> 로 바꿔도 같은 결과를 얻을 수 있다. 한번 해보자.</p><p>만일 <code>GlobalScope.launch</code> 를 <code>thread</code> 로 바꾸려고 하기 시작하면 컴파일러는 다음과 같은 에러를 낸다:</p><blockquote><p>Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function<br/>(에러: 코틀린: Suspend 함수들은 코루틴이나 다른 Suspend 함수에서의 호출만을 허용한다.)</p></blockquote><p><code>delay</code> 는 코루틴 안에서만 사용되는, 코루틴을 중단 (suspend) 하고 스레드를 블럭하지 않는 특별한 <code>sespending function</code> 이기 때문이다.</p><h1 id="Bridging-blocking-and-non-blocking-worlds"><a href="#Bridging-blocking-and-non-blocking-worlds" class="headerlink" title="Bridging blocking and non-blocking worlds"></a>Bridging blocking and non-blocking worlds</h1><p>첫 예제는 같은 코드 안에 넌블럭킹(non-blocking) <code>delay(...)</code> 와 블럭킹(blocking) <code>Thread.sleep</code> 코드가 혼재되어 있다. 무엇이 블럭킹이고 무엇이 아닌지 따라가기 어려울 것이다. <code>runBlocking</code> 코루틴 빌더를 사용해서 블럭킹에 대해 명확히 밝혀보자.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main thread continues here immediately</span></span><br><span class="line">    runBlocking &#123;     <span class="comment">// but this expression blocks the main thread</span></span><br><span class="line">        delay(<span class="number">2000L</span>)  <span class="comment">// ... while we delay for 2 seconds to keep JVM alive</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-02.kt">여기</a>에 있다</p></blockquote><p>결과는 같지만, 이 코드는 단지 넌블럭킹 <code>delay</code> 를 사용한다. 메인 스레드를 실행하는 <code>runBlocking</code> 은 <code>runBlocking</code> 내부의 코루틴이 완료될 때까지 블럭된다. </p><p>이 예제는 더 관용적 방법으로 재작성할 수 있는데, main 함수 실행을 <code>runBlocking</code> 을 사용해 감싸는 것이다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; <span class="comment">// start main coroutine</span></span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main coroutine continues here immediately</span></span><br><span class="line">    delay(<span class="number">2000L</span>)      <span class="comment">// delaying for 2 seconds to keep JVM alive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-02b.kt">여기</a>에 있다</p></blockquote><p>여기의 <code>runBlocking&lt;Unit&gt; &#123; ... &#125;</code> 은 최상위 메인 코루틴 시작에 사용되는 어댑터로서 작동한다. Unit 반환 형식을 명시적으로 지정하는데, 코루틴의 정상적인 메인 함수는 <code>Unit</code> 을 반환해야 하기 때문이다. </p><p>다음은 suspending 함수의 유닛 테스트를 작성하는 방법이다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">testMySuspendingFunction</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// here we can use suspending functions using any assertion style that we like</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Waiting-for-a-job"><a href="#Waiting-for-a-job" class="headerlink" title="Waiting for a job"></a>Waiting for a job</h1><p>다른 코루틴이 동작할 동안 스레드의 시간을 지연키시는 것은 좋은 접근법이 아니다. 실행된 백그라운드 Job 이 완료될 때까지 명확하게 기다리자:<br>(역자: 지금까지의 예제 코드가 코루틴이 종료될 때까지 <code>Thread.sleep</code> 으로 기다리는 부분을 말하고 있다.)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">// launch a new coroutine and keep a reference to its Job</span></span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">job.join() <span class="comment">// wait until child coroutine completes</span></span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-03.kt">여기</a>에 있다</p></blockquote><p>여전히 결과는 같지만, 메인 코루틴의 코드는 어떤 방식으로든 백드라운드 job 과 엮이지 않았다. 훨씬 낫다.</p><h1 id="Structured-concurrency"><a href="#Structured-concurrency" class="headerlink" title="Structured concurrency"></a>Structured concurrency</h1><p>코루틴의 일반적이고 바람직한 사용법을 소개한다. <code>GlobalScope.launch</code> 을 사용하면 최상위 코루틴을 만든다. 실제 가벼운 동작일지라도, 여전히 동작하는 동안 조금의 메모리를 사용한다. 만일 새로 실행된 코루틴의 참조를 잊어도 코루틴은 여전히 실행된다. </p><p>만일 코루틴의 코드에 행이 걸리는 경우(예를 들면 과도하게 장시간 지연이 발생하는 경우) 나 너무 많은 코루틴이 실행되어 메모리 부족이 오는 경우엔 어떻게 될까?<br>실행된 코루틴의 참조를 수동으로 유지하고 그것들을 <code>join</code> 하는 것은 오류가 나기 쉽다.</p><p>좋은 솔루션이 있다. 코드안에서 구조적 동시성을 사용할 수 있다. <code>GlobalScope</code> 에서 코루틴을 수행하는 대신, 일반적인 스레드와 함께 실행하는 것 처럼 수행중인 오퍼레이션 안의 특정 스코프에서 코루틴을 실행할 수 있다.</p><p>예제에서는 <code>runBlocking</code> 코루틴 빌더를 사용하여 코루틴으로 변환되는 메인 함수가 있다. <code>runBlocking</code> 을 포함한 코루틴 빌더로 생성되는 모든 코드 블럭 스코프에 <code>CoroutineScope</code> 인스턴스를 추가한다. 이 스코프 안에서는 코루틴을 명시적으로 <code>join</code> 하지 않고도 실행할 수 있는데, 바깥의 코루틴 (예제의 <code>runBlocking</code>) 이 그 스코프 안에서 실행된 모든 코루틴이 완료될 때까지 완료되지 않기 때문이다. </p><p>따라서 예제를 더욱 단순하게 만들 수 있다:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; <span class="comment">// launch a new coroutine in the scope of runBlocking</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-03s.kt">여기</a>에 있다</p></blockquote><h1 id="Scope-builder"><a href="#Scope-builder" class="headerlink" title="Scope builder"></a>Scope builder</h1><p>다른 빌더가 제공하는 코루틴 스코프 외에, <code>coroutineScope Builder</code> 를 사용해서 자신만의 스코프를 가지는 코루틴을 선언할 수 있다.</p><p><code>coroutineScope Builder</code> 는 코루틴 스코프를 생성하고 모든 자식들이 완료될 때까지 완료되지 않는다.<br><code>runBlocking</code> 과 <code>coroutineScope</code> 의 주된 차이점은 <code>coroutineScope</code> 이 모든 자식이 완료될 때까지 현재 스레드를 차단하지 않는다는 것이다.</p><p>(역자: 관련해서 StackOverflow 의 <a href="https://stackoverflow.com/questions/53535977/coroutines-runblocking-vs-coroutinescope">이 질문</a> 도 한번 보자)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123; <span class="comment">// this: CoroutineScope</span></span><br><span class="line">    launch &#123; </span><br><span class="line">        delay(<span class="number">200L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task from runBlocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coroutineScope &#123; <span class="comment">// Creates a coroutine scope</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">500L</span>) </span><br><span class="line">            println(<span class="string">&quot;Task from nested launch&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        delay(<span class="number">100L</span>)</span><br><span class="line">        println(<span class="string">&quot;Task from coroutine scope&quot;</span>) <span class="comment">// This line will be printed before the nested launch</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Coroutine scope is over&quot;</span>) <span class="comment">// This line is not printed until the nested launch completes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-04.kt">여기</a>에 있다</p></blockquote><h1 id="Extract-function-refactoring"><a href="#Extract-function-refactoring" class="headerlink" title="Extract function refactoring"></a>Extract function refactoring</h1><p><code>launch &#123; ... &#125;</code> 안의 코드를 별도 함수로 추출해 보자. 이 코드에 <code>함수 추출</code> 리팩토링(역자: Intellij의 기능을 사용한다) 을 하면 <code>suspend</code> 수정자와 함께 새로운 함수가 추출된다. 이게 여기서 다루는 첫번째 <code>suspending function</code> 이다.</p><p><code>suspending function</code> 은 코루틴 안에서 일반 함수처럼 사용될 수 있으며, 추가적인 기능으로 예제의 <code>delay</code> 처럼 코루틴 실행을 일시적으로 suspend 할 수 있다.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is your first suspending function</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-05.kt">여기</a>에 있다</p></blockquote><p>그러나 추출된 함수에 현재 스코프에서 호출되는 코루틴 빌더가 포함되어 있으면 어떨까? 이 경우에 추출된 함수의 <code>suspend</code> 수정자는 충분하지 않다.</p><p><code>CoroutineScope</code> 에서 <code>doWorld</code> 를 확장 메소드(extension method) 로 만드는 것은 솔루션 중 하나이지만 API가 더 명확하지는 않으므로 항상 적용 가능한 것은 아니다. </p><p>관용적 솔루션은 대상 함수를 포함하는 클래스의 필드로 명시적 <code>CoroutineScope</code> 를 갖거나 외부 클래스가 <code>CoroutineScope</code> 를 구현할 때 암시적으로 그것을 필드로 가지는 것이다. </p><p>최후의 수단으로 <code>CoroutineScope (coroutineContext)</code> 를 사용할 수 있지만 이 방법으로는 실행 스코프를 더 이상 제어할 수 없기 때문에 이런 접근 방식은 구조적으로 안전하지 않다. </p><p>개인 API 만이 빌더를 사용할 수 있다.</p><p>(뭔소리여… 아래 원문 붙임)</p><blockquote><p>But what if the extracted function contains a coroutine builder which is invoked on the current scope? In this case suspend modifier on the extracted function is not enough. Making doWorld an extension method on CoroutineScope is one of the solutions, but it may not always be applicable as it does not make API clearer. The idiomatic solution is to have either an explicit CoroutineScope as a field in a class containing the target function or an implicit one when the outer class implements CoroutineScope. As a last resort, CoroutineScope(coroutineContext) can be used, but such approach is structurally unsafe because you no longer have control on the scope of execution of this method. Only private APIs can use this builder.</p></blockquote><h1 id="Coroutines-ARE-light-weight"><a href="#Coroutines-ARE-light-weight" class="headerlink" title="Coroutines ARE light-weight"></a>Coroutines ARE light-weight</h1><p>다음 코드를 보자</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    repeat(<span class="number">100_000</span>) &#123; <span class="comment">// launch a lot of coroutines</span></span><br><span class="line">        launch &#123;</span><br><span class="line">            delay(<span class="number">1000L</span>)</span><br><span class="line">            print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-06.kt">여기</a>에 있다</p></blockquote><p>100K개의 코루틴을 시작하고 1초마다 후에 각 코루틴이 점을 찍는다. 이제 이 로직을 스레드로 시도해보라. 무슨 일이 일어날까? </p><p>(아마도 Thread 를 사용한 코드에서 메모리 부족 오류가 발생할 것이다)</p><h1 id="Global-coroutines-are-like-daemon-threads"><a href="#Global-coroutines-are-like-daemon-threads" class="headerlink" title="Global coroutines are like daemon threads"></a>Global coroutines are like daemon threads</h1><p>다음 코드는 <code>GlobalScope</code> 에서 “I’m sleeping” 을 1초에 두번 인쇄하고 그후 메인 함수에 약간의 <code>delay</code> 후 복귀하는 긴 시간의 코루틴을 실행한다:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    repeat(1000) &#123; i -&gt;</span><br><span class="line">            println(&quot;I&#39;m sleeping $i ...&quot;)</span><br><span class="line">        delay(500L)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">delay(1300L) &#x2F;&#x2F; just quit after delay</span><br></pre></td></tr></table></figure><blockquote><p>전체 코드는 <a href="https://github.com/kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/test/guide/example-basic-07.kt">여기</a>에 있다</p></blockquote><p>실행하고 세줄이 찍히고 중단되는 걸 볼 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I&#39;m sleeping 0 ...</span><br><span class="line">I&#39;m sleeping 1 ...</span><br><span class="line">I&#39;m sleeping 2 ...</span><br></pre></td></tr></table></figure><p>GlobalScope에서 시작된 액티브 코루틴은 프로세스를 <code>실행중인</code> 상태로 유지하지 않는다. 그것들은 데몬 스레드와 비슷하다.</p>]]></content>
    
    
    <summary type="html">코틀린 기본 공식 문서 번역</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/rrr.jpg" type="image"/>
    
    
    <category term="kotlin" scheme="https://blog.javarouka.me/categories/kotlin/"/>
    
    <category term="tech" scheme="https://blog.javarouka.me/categories/kotlin/tech/"/>
    
    <category term="translate" scheme="https://blog.javarouka.me/categories/kotlin/tech/translate/"/>
    
    
    <category term="kotlin" scheme="https://blog.javarouka.me/tags/kotlin/"/>
    
    <category term="coroutine" scheme="https://blog.javarouka.me/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Java / Kotlin 의 상속과 구성 (Inheritance &amp; Composition) #1</title>
    <link href="https://blog.javarouka.me/2019/04/07/interits-conposition/"/>
    <id>https://blog.javarouka.me/2019/04/07/interits-conposition/</id>
    <published>2019-04-06T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="자바의-상속"><a href="#자바의-상속" class="headerlink" title="자바의 상속"></a>자바의 상속</h1><p>객체지향언어에서의 상속은 객체간의 관계를 언어레벨에서 정의하는 방법이다.</p><p>상속은 <a href="https://ko.wikipedia.org/wiki/%EC%8B%9C%EB%AE%AC%EB%9D%BC">Simula</a> 라는 언어의 객체지향적 부분에서 발전했다고 알려져 있다. C++ 개발자인 <a href="https://ko.wikipedia.org/wiki/%EB%B9%84%EC%95%BC%EB%84%A4_%EC%8A%A4%ED%8A%B8%EB%A1%AD%EC%8A%A4%ED%8A%B8%EB%A3%B9">비야네 스트로스트롭</a>이나 Java 개발자인 <a href="https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%9E%84%EC%8A%A4_%EA%B3%A0%EC%8A%AC%EB%A7%81">제임스 고슬링</a>도 Simula 에서 언어 개발에 상당한 아이디어를 얻었다고.</p><p>Java 의 상속은 다음과 같은 성격을 지닌다</p><h2 id="수퍼-서브클래스"><a href="#수퍼-서브클래스" class="headerlink" title="수퍼/서브클래스"></a>수퍼/서브클래스</h2><p>어떤 클래스 B 가 다른 클래스 A 를 상속할 때 A를 수퍼클래스, B 를 서브클래스라고 한다. 간혹 수퍼타입/서브타입으로도 부르기도 하는데 다소 다른 의미다.</p><p>아래 코드에서 <code>Truck</code> 은 <code>Car</code> 의 서브클래스이기 때문에 자동차가게(CarStore) 에 <code>Truck</code> 을 둘 수 있다. 하지만 <code>Ship</code> 은 둘 수 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ship</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarStore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Car&gt; carList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        carList.add(car);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        CarStore shop = <span class="keyword">new</span> CarStore();</span><br><span class="line">        shop.put(<span class="keyword">new</span> Car());</span><br><span class="line">        shop.put(<span class="keyword">new</span> Truck());</span><br><span class="line">        shop.put(<span class="keyword">new</span> Ship()); <span class="comment">// 컴파일 에러. 배는 차가 아니다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상속관계인 클래스 <code>Car</code> 와 <code>Truck</code> 은 서로 각자의 타입이면서 클래스이다.</p><p>타입과 클래스는 다르다. <em>하나의 클래스는 대부분 두가지 이상의 타입으로 표현</em> 될 수 있기 때문이다.</p><h2 id="타입과-클래스"><a href="#타입과-클래스" class="headerlink" title="타입과 클래스"></a>타입과 클래스</h2><p><code>Truck</code>의 인스턴스는 <code>Truck</code> 와 <code>Car</code> 타입이 될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">Truck truck = <span class="keyword">new</span> Truck();</span><br><span class="line">Car truckCar = truck; <span class="comment">// 가능하다.</span></span><br><span class="line">Object obj = truck; <span class="comment">// 가능하다.</span></span><br></pre></td></tr></table></figure><p>Java 의 모든 클래스는 Object 를 상속하므로, Object 타입으로도 표현할 수 있다.</p><p>게다가 제네릭 클래스는 타입 인자에 따라 수많은 타입을 만들어낼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; objs = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">ArrayList&lt;Car&gt; cars = <span class="keyword">new</span> ArrayList&lt;Car&gt;();</span><br><span class="line">ArrayList&lt;Truck&gt; trucks = <span class="keyword">new</span> ArrayList&lt;Truck&gt;();</span><br></pre></td></tr></table></figure><p>다음과 같이 정리할 수 있겠다.</p><ul><li>클래스는 구현 지향적이다. 내부 상태와 할 수 있는 연산이 구현되어 수행하는 자료구조에 가깝다.</li><li>타입은 선언 지향적이다. 특정 객체가 수행할 수 있는 일의 제한을 지정한다.</li></ul><p align="center">    <img src="/asset/images/truck.jpg" alt="트럭"><em>아마존 트럭. 트럭이고 차이고 기계이다.</em></p><h2 id="타입-관계"><a href="#타입-관계" class="headerlink" title="타입 관계"></a>타입 관계</h2><p>서브타입은 수퍼타입의 변수에 할당할 수 있다. 서브타입은 수퍼타입의 모든 기능을 상속받았고 수퍼타입이 할 수 있는 모든 일을 할 수 있으므로, 수퍼 타입이 할 수 있는 모든 기능이 문제없이 동작가능하게 구현되어야 한다. <a href="https://blog.javarouka.me/2018/11/27/object-equals-liskov/#%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EB%B2%95%EC%B9%99">리스코프 치환 원칙</a> 으로도 부른다.</p><p>이러한 타입 관계에서는 <code>변성(variance)</code> 이라는 성질이 존재한다.</p><p>메서드의 인자로 전달된 객체의 상태가 변할땐 자신의 타입을 포함한 수퍼타입으로 제한되고, 특정 객체를 반환할 경우 반환형은 자신의 서브타입으로 제한된다.</p><ol><li>특정 메서드에게 걸그룹을 인자로 전달하려면 특정 메서드의 선언은 걸그룹이거나 걸그룹의 수퍼타입(가수, 사람, 동물 …)이어야 한다.</li><li>특정 메서드에서 걸그룹을 반환할 경우 그 반환값은 걸그룹이거나 걸그룹의 서브타입(트와이스, 소녀시대 …)이어야 한다.</li></ol><p>좀더 유식하게 표현하면 1번의 경우를 <a href="https://medium.com/@lazysoul/%EA%B3%B5%EB%B3%80%EA%B3%BC-%EB%B6%88%EB%B3%80-297cadba191">반공변적</a>이라고 하고 2번의 경우를 <a href="https://edykim.com/ko/post/what-is-coercion-and-anticommunism/">공변적</a>이라고 한다.</p><p align="center">    <img src="/asset/peoples/twice.jpg" alt="트와이스"><em>트와이스는 걸그룹이지만 소녀시대는 아니다.</em></p><p>가요무대 클래스의 멤버 메서드가 노래를 부를 가수 타입이 필요하다면 걸그룹 인자에 대해 반공변적이라고 할 수 있다. </p><p>보이그룹이나 솔로가수도 갈 수 있다.</p><p>하지만 걸그룹 어워드 클래스 메서드에서 특정 걸그룹중 1위를 반환한다고 하면 반환시에는 트와이스나 시스타, 소녀시대만으로 제한된다. </p><p>이때는 인자에 대해 공변적이다.</p><h3 id="제네릭은-항상-서로-다르다"><a href="#제네릭은-항상-서로-다르다" class="headerlink" title="제네릭은 항상 서로 다르다"></a>제네릭은 항상 서로 다르다</h3><p>제네릭을 처음 공부할때 다소 혼란스러운 부분이 제네릭 파라미터가 수퍼/서브타입의 관계일 경우 제네릭 클래스도 수퍼/서브타입이 성립할거라는 착각이다.</p><p>다음 코드는 컴파일 오류이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 호환되지 않는 타입. 컴파일 오류가 발생한다.</span></span><br><span class="line">ArrayList&lt;Car&gt; cars = <span class="keyword">new</span> ArrayList&lt;Truck&gt;();</span><br></pre></td></tr></table></figure><p>제네릭 타입은 다른 모든 제네릭 타입과 수퍼/서브타입이 성립하지 않는다. 제네릭 파라미터화 타입이 서로 어떤 관계이든 항상 다른 타입이다.</p><p>이것을 유식한 단어로 <code>불공변(invariant)</code> 이리고 한다.</p><h3 id="하지만-배열은-이상하다"><a href="#하지만-배열은-이상하다" class="headerlink" title="하지만 배열은 이상하다."></a>하지만 배열은 이상하다.</h3><p>배열은 위의 성질과 다르게 공변관계를 허용한다. 그래서 다음 코드는 문제가 없다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car[] cars = <span class="keyword">new</span> Truck[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>문제는 위의 배열에 다음과 같은 코드를 실행할 때다. <code>ArrayStoreException</code> 이 발생하는데, 컴파일 타임이 아닌 런타임에 발생한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayStoreException</span></span><br><span class="line">cars[<span class="number">0</span>] = <span class="keyword">new</span> Taxi();</span><br></pre></td></tr></table></figure><p>배열은 제네릭과 다르게 런타임 시에도 타입이 소거되지 않고 유지하기 때문이다. 런타임 시 이 소거되지 않은 타입을 검사하며 오류를 출력한다.</p><p>배열의 이러한 공변성으로 인해 타입관련 잠재적인 런타임 오류가 발생할 수 있다. 이런 오류에 대해서는 컴파일러가 대부분은 경고를 해 주므로, 컴파일 시의 워닝 메시지를 무시하지 말자.</p><h3 id="와일드카드-변성"><a href="#와일드카드-변성" class="headerlink" title="와일드카드 변성"></a>와일드카드 변성</h3><p>Java 에서는 배열의 제네릭 파라미터일 경우 이 관계를 와일드카드와 함께 써서 <code>PECS (Producer-extends, Consumer-super)</code> 로 정의한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 공변 제네릭 리스트</span></span><br><span class="line">List&lt;? extends GirlGroupSinger&gt; girlGroups1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 문은 컴파일 오류이다. 이 값이 어떤 값인지 특정지을 수 없다.</span></span><br><span class="line">girlGroups1.add(<span class="keyword">new</span> Twice());</span><br><span class="line">girlGroups1.add(<span class="keyword">new</span> Sistar());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 걸그룹임이 보장된다.</span></span><br><span class="line">GirlGroupSinger some = girlGroups.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 반공변 제네릭 리스트</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> GirlGroupSinger&gt; girlGroups2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 걸그룹의 수퍼타입이면 뭐든 입력할 수 있다</span></span><br><span class="line">girlGroups1.add(<span class="keyword">new</span> People());</span><br><span class="line">girlGroups1.add(<span class="keyword">new</span> Animal());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 문은 컴파일 오류이다. 이 타입이 무엇인지 특정지을 수 없다.</span></span><br><span class="line">GirlGroupSinger some = girlGroups.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>여기서 Producer 와 Consumer 의 주체는 제네릭 타입의 인자이다.</p><p>extends 일 경우 인자가 값을 생산 (get) 한다는 의미이며 super 일 경우 인자가 값을 소비(set) 한다는 의미이다.</p><blockquote><p>이 주제와 관련해서 좋은 StackOverflow 링크가 있다. <a href="https://bit.ly/2GdGEUh">https://bit.ly/2GdGEUh</a></p></blockquote><h2 id="자동-선언"><a href="#자동-선언" class="headerlink" title="자동 선언"></a>자동 선언</h2><p>서브클래스는 수퍼클래스의 인스턴스 변수와 멤버 메서드들을 자동으로 상속한다. </p><p>상속한다는 뜻은 서브클래스에서 별도로 정의하지 않아도 정의된 것처럼 별도 선언 없이 사용할 수 있다.</p><p><em>인스턴스 변수</em>, <em>멤버 메서드</em> 라고 명시적으로 말한 건 static 으로 정의된 변수와 메서드는 제외되기 때문이다.</p><p>수퍼클래스에 대한 접근은 <code>super</code> 키워드를 사용한다. </p><p>super 키워드는 사용처에 따라 다른 대상을 가르킨다.</p><ul><li>생성자에서 사용되는 <code>super</code> 는 <em>생성자 함수</em> 를 가르킨다. 호출하는 함수 형태이다.</li><li>멤버 함수에서의 <code>super</code> 는 <em>인스턴스</em> 를 가르킨다. 부모 인스턴스를 레퍼런스하는 변수처럼 동작한다. </li></ul><h2 id="접근제어"><a href="#접근제어" class="headerlink" title="접근제어"></a>접근제어</h2><p>상속에 몇가지 제약을 걸 수 있는 접근제어자가 있다.</p><p>Java 를 처음 학습할때 접하는 <code>private</code>, <code>protected</code>, <code>public</code> 이고 별도로 정의하지 않으면 <code>default</code> 접근제어가 적용된다.</p><p>보통 좋은 프로그램 코딩 가이드에서는 제한적인 접근을 먼저 적용하고 필요에 따라 넓혀가라고 조언된다. <code>private</code> 으로 전부 선언한 뒤, 필요에 따라 <code>protected</code> 혹은 <code>public</code> 으로 넓혀가는게 좋다. </p><p>애매한 건 <code>default</code> 접근 제어인데 이 케이스는 일반적인 케이스의 경우 잘 사용되지 않지만, 구현체를 직접적으로 사용하지 못하게 할때 유용하게 쓸 수 있다.</p><p>만일 같은 패키지에 <code>UserInputController</code> 클래스와 <code>UserInputController</code> 을 상속한 <code>Mouse</code> 클래스, <code>Keyboard</code> 클래스가 있다고 할 때 타 패키지에서는 <code>UserInputController</code> 으로만 추상적으로 접근하게 하고 싶다면 다음과 같이 구현하면 된다.</p><p>구현 클래스에는 public 접근제어 없이 default 로 선언했다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file UserInputController.java</span></span><br><span class="line"><span class="keyword">package</span> me.javarouka.input;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInputController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file Mouse.java</span></span><br><span class="line"><span class="keyword">package</span> me.javarouka.input;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">UserInputController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file Keyboard.java</span></span><br><span class="line"><span class="keyword">package</span> me.javarouka.input;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> <span class="keyword">implements</span> <span class="title">UserInputController</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>외부에서는 클래스를 생성하지 못한다. </p><p><em>private 생성자</em> 로도 이런 방법을 쓸 수 있지만, DI 프레임워크(Spring Framework 가 대중적이다.) 등을 쓰고 있다면 이 방법이 유용할 것이다.</p><p>DI 프레임워크 등이 없다면 팩토리 클래스 같은 생성 헬퍼를 만들어줘야 할 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.javarouka.input;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInputControllers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInputController <span class="title">createMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInputController <span class="title">createKeyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Keyboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제 구현 클래스의 노출 없이 구현 클래스 타입을 제공하여 불필요한 정보 공개를 하지 않고 안전성을 높일 수 있다.</p><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>다음 포스트에서는 상속의 단점과 구성에 대해 알아보겠다. 그리고 코틀린에서 이런 상속 관계들을 어떻게 처리하는지 알아본다 </p>]]></content>
    
    
    <summary type="html">자바의 상속과 클래스, 타입</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/rrr.jpg" type="image"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/categories/java/"/>
    
    <category term="kotlin" scheme="https://blog.javarouka.me/categories/java/kotlin/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="kotlin" scheme="https://blog.javarouka.me/tags/kotlin/"/>
    
    <category term="composition" scheme="https://blog.javarouka.me/tags/composition/"/>
    
    <category term="type" scheme="https://blog.javarouka.me/tags/type/"/>
    
    <category term="class" scheme="https://blog.javarouka.me/tags/class/"/>
    
    <category term="delegate" scheme="https://blog.javarouka.me/tags/delegate/"/>
    
  </entry>
  
  <entry>
    <title>[책] Elasticsearch In Action</title>
    <link href="https://blog.javarouka.me/2019/04/07/book-elasticsearch-in-action/"/>
    <id>https://blog.javarouka.me/2019/04/07/book-elasticsearch-in-action/</id>
    <published>2019-04-06T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.876Z</updated>
    
    <content type="html"><![CDATA[<p align="center">    <img src="http://acornpub.co.kr/tb/detail/book/ej/lq/1477017264mU57qQOe.jpg" alt="엘라스틱 인 "></p><p>최근 엘라스틱서치를 좀 써보고 깊이 공부해야 할 필요성이 있어 인액션 시리즈를 구매해서 부록을 제외한 파트를 다 읽었다. 이런 두꺼운 책은 오랜만인것 같다.</p><p>읽으면서 많이 아쉬웠던건 예제나 설명이 구 버전에 맞춰져 있었고, 샘플 색인 데이터 스크립트는 Mac 에서 오동작했다 (스크립트 안의 curl 명령어를 조금 수정해줘야 색인할 수 있다)</p><p>번역의 품질은 번역서에서는 매우 중요한데 이 책은 번역 품질은 아쉽게도 그리 훌륭하지 않다.</p><p>용어 번역 그런 문제가 아니다.<br>그냥 번역문이 매끄럽지가 못해서 같은 부분을 반복해서 읽어야 이해가 된다 (머리속에 더 잘남으려나;) 오탈자도 많다;</p><p>하지만 이런 단점에도 내용 자체가 깊이있고 훌륭하다. </p><p>상당히 괜찮은 책.</p>]]></content>
    
    
    <summary type="html">책 리뷰.</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/rrr.jpg" type="image"/>
    
    
    <category term="book" scheme="https://blog.javarouka.me/categories/book/"/>
    
    
    <category term="db" scheme="https://blog.javarouka.me/tags/db/"/>
    
    <category term="book" scheme="https://blog.javarouka.me/tags/book/"/>
    
    <category term="elasticsearch" scheme="https://blog.javarouka.me/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Redux-Saga 소개</title>
    <link href="https://blog.javarouka.me/2019/04/02/redux-saga-1/"/>
    <id>https://blog.javarouka.me/2019/04/02/redux-saga-1/</id>
    <published>2019-04-01T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redux-와-부수효과"><a href="#Redux-와-부수효과" class="headerlink" title="Redux 와 부수효과"></a>Redux 와 부수효과</h2><p>Redux 는 상태 관리를 도와주는 간단한 라이브러리이다. 실제로도 소스코드 용량은 매우 작고, 해주는 일도 매우 단순하다.</p><!-- 보통 Redux 를 공부할때 어렵게 느껴지는 이유가 먼저 같이 많이 쓰이는 React UI 와 같이 붙여서 코드부터 쳐보다가, 액션...리듀서...디스패처...등의 개념에 혼란함을 느껴 질리는 경우가 많다. 하지만 React 를 배제하고 Redux 의 순수한 기능부터 공부하면 훨씬 쉽게 공부할 수 있다. --><h3 id="Redux-복습"><a href="#Redux-복습" class="headerlink" title="Redux 복습"></a>Redux 복습</h3><p>Redux 를 다들 잘 알겠지만 복습해보자.</p><ul><li>스토어</li><li>액션</li><li>리듀서</li></ul><p>Redux 는 자신이 관리하는 데이터 모음인 <code>상태(state)</code> 를 <code>스토어(Store)</code> 라는 저장소에 두고 이 상태를 변경할 수 있는 것은 <code>액션(action)</code> 으로 제한한다.</p><p>액션은 단순한 문자열이며 이 액션으로 상태를 변경하기 위해서는 <code>스토어(Store)</code> 에 <code>디스패치(dispatch)</code> 하는 행위가 필요하다.</p><p><code>디스패치(dispatch)</code> 할 때 전달할 정보는 다음과 같은 인터페이스를 가지는 일반 자바스크립트 객체이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReduxDispatchAction &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>, <span class="comment">// required 액션은 반드시 문자열이어야 한다.</span></span><br><span class="line">    [prop:<span class="built_in">any</span>]?: <span class="built_in">any</span> <span class="comment">// optional N. 나머지는 옵셔널이며 객체에 할당할 수 있는 모든 키/값이 올 수 있다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>디스패치 함수는 스토어가 가지고 있고, 시그니쳐는 다음과 같다</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReduxStore &#123;</span><br><span class="line"></span><br><span class="line">    dispatch(action: ReduxDispatchAction) =&gt; <span class="built_in">void</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 스토어 기타 함수, subscribe 등</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제 사용 코드는 다음과 같다. </p><p><code>doAmazingShow</code> 라는 액션을 payload 속성과 같이 디스패치하는 코드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 액션</span></span><br><span class="line"><span class="keyword">const</span> doAmazingShow = <span class="string">&#x27;doAmazingShow&#x27;</span></span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    action: doAmazingShow,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        invited: [ <span class="string">&#x27;Cool&#x27;</span>, <span class="string">&#x27;Hot&#x27;</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>디스패치의 결과로 <code>reducer</code>가 실행된다. <code>reducer</code> 는 모든 액션이 디스패치 될 때마다 액션과 현재 상태를 받는 단순한 함수다.</p><p>reducer 의 시그니처는 다음과 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Reducer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param currentState 현재 상태</span></span><br><span class="line"><span class="comment">     * @param action 디스패치를 통해 전달된 액션</span></span><br><span class="line"><span class="comment">     * @return 새로운 상태 객체</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    (currentState): <span class="built_in">object</span>, action: ReduxDispatchAction) =&gt; <span class="built_in">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 흐름은 한번의 실행 스택으로 수행되는데, 이 뜻은 다수의 액션 수행을 해도 그 순서를 보장한다는 뜻이다. 스크립트의 동작이 원래 그렇듯이 말이다.</p><p>여기까지가 Redux 의 간단한 흐름이다. 더 자세한 설명을 원하면 <a href="https://lunit.gitbook.io/redux-in-korean/">공식 사이트</a>를 보자.</p><blockquote><p>Reducer 라는 네이밍은 Redux 제작자의 네이밍인데, 개인적으로는 액션처리기 같은 직관적 네이밍이 어땠을까 한다. 그럼 Redux 가 아니라 Execer 가 되었을지도 모르겠다. 그렇지만 액션을 누적해 하나의 상태로 처리하는 <code>reduce</code> 측면에서는 원래 이름인 Redux 가 더 어울린다.</p></blockquote><h3 id="Side-Effect"><a href="#Side-Effect" class="headerlink" title="Side Effect"></a>Side Effect</h3><p>실무에서 Redux 를 쓰다보면 액션이 동시다발적으로 발생되며, 액션 중간에 실제 Redux 액션이 아닌 일반 로직이 수행되거나 Ajax Call 등의 서버 리퀘스트도 발생한다. 그 와중에 여러 액션의 실행 보장도 해줘야 하는데, 자칫 코드가 상당히 난해해질 수 있다.</p><p>이럴때 사용을 고려해볼만한 라이브러리들이 몇개 있는대 대표적으로 Redux-Saga, Rx-Observable, MobX 등이다.</p><p>Redux-Saga 나 Rx-Observable 등을 Redux 와 같이 사용할때 이점으로 보통 비동기 처리가 손쉽다…라는 문구로 광고가 보통 되지만, 구조화된 Redux 설계를 했다면 비동기 처리도 그렇게 더러워지진 않는다. (다시 말하면 설계가 좋지 않다면 유지보수가 힘든 스파게티가 나온다는 뜻이다)</p><p>사실 단순 비동기 처리보다 더 큰 어려움은 액션이 여러 의미를 가지게 되고 그에 맞춰 기능이 확장되면서 액션이 다른 액션과 체이닝되기 시작할 때이다.</p><p>이런 기능들을 기존의 Redux 로 일일해 대응하다보면 코드가 순식간에 누더기가 된다. 순진하게 액션 처리 후 다른액션, 그리고 그 액션 성공 후 다른 액션… 으로 이어지는 코드는 대부분 스파게티맛을 맛본다.</p><p>예를 들어 회원 정보 페이지가 있다고 해보자. 다음은 액션을 디스패치하는 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;START_USER_LOADING&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;FAIL_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 앱에 새로운 기능이 추가되어 유저 로딩 후 사용자의 팔로워를 같이 로딩해야 한다고 해보자.</p><p>코드는 다음과 같이 변경할 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadFollowersFrom = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;START_FOLLOWER_LOADING&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">await</span> Users.loadFollowersFrom(userId);</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;END_FOLLOWER_LOADING&#x27;</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;FAIL_FOLLOWER_LOADING&#x27;</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;START_USER_LOADING&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 이 부분이 추가되었다. 유저 정보 로딩 후 실행한다.</span></span><br><span class="line">        loadFollowersFrom()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;FAIL_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>별로 나빠보이지 않는다. 그러나 이 코드는 앞으로의 코드 변경에 꽤나 힘들어질 수 있는 스타트를 끊은 코드다. </p><p>지금은 유저 정보 로딩 후 팔로워 로딩만 추가했지만 앞으로 이후 수많은 유저 관련 정보가 로딩될 수 있다. </p><p>예를 들면 추가적으로 유저 정보 로딩 후, 그 정보의 유무에 따라 현금성 결제 포인트와 이 유저를 방문한 유저를 로딩해야 할 수 있다. 그리고 사용성 트래킹을 위해 로그를 서버에 전송할 수도 있다.</p><p>그 호출 책임은 전부 <code>loadUser</code> 라는 함수가 담당하고 있다. </p><p>원래의 목적은 유저를 로딩한다는 목적으로 만들었지만, 이제는 유저도 로딩하고, 포인트도 로딩하고, 팔로워도 로딩하고 … 하는 함수가 되었다. 이쯤되면 이름을 <code>loadUserThenFollowers</code> 같은 이름으로 바꿔야 할지도 모르겠다.</p><p>더욱 힘들게 하는 건 만일 유저 정보 로딩 후 실행되는 부수 액션들(팔로워, 포인트…) 중 하나가 오류가 났을 때 각 부수 액션들끼리도 서로 영향을 줄 수 있다. 만일 비즈니스적으로 어떤 액션은 주변의 오류와 상관없이 진행해야 할 수도 있고 중단해야 할 수도 있다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;START_USER_LOADING&#x27;</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FIXME 거슬리는 부분 1</span></span><br><span class="line">        <span class="comment">// 비즈니스에 따라 처리해야 할 로직이 직접적으로 박힌다.</span></span><br><span class="line">        <span class="comment">// 이쯤 되면 함수 이름을 loadUser 가 아닌 다른걸로 바꾸는 걸 정말로 고려하는게 좋겠다.</span></span><br><span class="line">        <span class="keyword">await</span> loadFollowersFrom(userId)</span><br><span class="line">        <span class="keyword">await</span> loadPoint(userId)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">&#x27;FAIL_USER_LOADING&#x27;</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// FIXME 거슬리는 부분 2</span></span><br><span class="line">        <span class="comment">// 오류 여부에 관계없이 실행해야 한다.</span></span><br><span class="line">        <span class="keyword">await</span> writeUserActionLogging(userId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 본래 액션 말고도 그 액션에 따라 다른 액션이나 이벤트가 파생되는건 꽤나 흔한 일이다.</p><p>이런 일을 <code>부수효과 (Side-Effect)</code> 라고 한다.</p><ul><li>Ajax 콜</li><li>비동기 타이머</li><li>애니메이션 후 콜백</li><li>요청 중 취소</li><li>스로틀링</li><li>디바운싱</li><li>페이지 이동</li></ul><p>이러한 것은 일반적인 Redux의 액션 흐름으로는 나타내기가 조금 어렵고, 비동기 수행시에는 어디엔가 dispatch 함수의 레퍼런스를 가지고 있다가 필요할때에 호출하면서 수행해야 한다.</p><p>이러한 부수 효과들은 Redux-Saga 를 쓴다면 꽤 단순하고 직관적으로 풀어낼 수 있다.</p><h3 id="Redux-Saga-적용"><a href="#Redux-Saga-적용" class="headerlink" title="Redux Saga 적용"></a>Redux Saga 적용</h3><p>다음은 Redux-Saga 로 위의 문제를 다시 작성해본 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 유저 현금성 포인트를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadPoint = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">yield</span> call(Point.load, userId);</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;END_USER_POINT_LOADING&#x27;</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;FAIL_USER_POINT_LOADING&#x27;</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 특정 유저의 팔로워를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadFollowers = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">yield</span> call(Users.loadFollowersFrom, userId);</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;END_FOLLOWER_LOADING&#x27;</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;FAIL_FOLLOWER_LOADING&#x27;</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 유저 정보를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadUser = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">yield</span> call(Users.loadUser, userId)</span><br><span class="line">        <span class="keyword">yield</span> put((&#123; <span class="attr">type</span>: <span class="string">&#x27;END_USER_LOADING&#x27;</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put((&#123; <span class="attr">type</span>: <span class="string">&#x27;FAIL_USER_LOADING&#x27;</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 각 워커의 시작점을 관리</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> watcher = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;START_USER_LOADING&#x27;</span>, loadUser);</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;END_USER_LOADING&#x27;</span>, loadFollowers);</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;END_USER_LOADING&#x27;</span>, loadPoint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">saga.runSaga(watcher)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*">Generator</a>를 모르는 사람은 문법에 어지러울지 모르겠다. <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*">Generator</a>가 중요한 부분이 아니니 실행 흐름에 거쳐가는 키워드로 보자.</p></blockquote><p>Saga 는 액션을 구독하는 Watcher 와 실제 작업을 수행하는 Worker 의 구성을 따른다</p><ul><li>Watcher<ul><li>watcher 함수</li></ul></li><li>Worker<ul><li>loadUser</li><li>loadFollowers</li><li>loadPoint</li></ul></li></ul><p>먼저 액션을 처리할 워커 함수를 전부 정의한다. loadUser, loadFollowers, loadPoint 셋이 있다. 그리고 매니저가 될 와쳐 함수를 정의하고 그 함수에서 실행을 정의하면 끝이다.</p><p>이후에 좀 더 설명하겠지만 takeXXX 류의 함수는 특정 액션(들) 을 감시하는 함수이고, put 은 실제 액션을 dispatch 하는 함수이다. Redux 의 Dispatch 함수와 동일하다. (이것들을 Saga 에서는 Saga-Effect 라고 부른다. 이후에 설명한다.)</p><p>위 예제에서는 <code>loadUser</code> 는 <code>START_USER_LOADING</code> 가 디스패치될 경우 매번 loadUser 를 실행하게 되어 있다. 그 아래 두개의 함수도 마찬가지로 <code>END_USER_LOADING</code> 가 디스패치 될 경우 각각의 두번째 인자의 함수를 실행한다.</p><p>코드량이 약간 줄은 것 외에는 더 복잡해졌다고 생각할 수 있다.</p><p>하지만 <strong>각 함수들이 자신만의 일에 집중하는 구조로 바뀌었으며 실행 시점을 알기 편해졌다.</strong> 자신 외에 별도 부수효과에 신경쓸 필요가 없다.</p><p>만일 여기서 팔로워나 포인트를 유저 정보 로딩 후가 아닌 다른 타이밍에 호출하려는걸 추가한다면 다음과 같이 하면 된다. 실제 loadXXX 류의 작업 함수는 건드릴 필요가 없다.</p><p>다음과 같이 watcher 함수에 watching 할 액션만 추가로 넣어주면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;START_USER_LOADING&#x27;</span>, loadUser);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery([</span><br><span class="line">        <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;START_FOLLOWER_LOADING&#x27;</span>, <span class="comment">// 추가 </span></span><br><span class="line">    ], loadFollowersFrom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery([</span><br><span class="line">        <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;START_POINT_LOADING&#x27;</span>, <span class="comment">// 추가</span></span><br><span class="line">    ], loadPointFrom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 액션에 대해 로깅을 추가한다고 하면 다음 구문만 추가하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> takeEvery([</span><br><span class="line">    <span class="string">&#x27;END_USER_LOADING&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;END_USER_POINT_LOADING&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;END_FOLLOWER_LOADING&#x27;</span>, </span><br><span class="line">], writeUserActionLogging);</span><br></pre></td></tr></table></figure><p>이렇게 액션의 감시와 해당 부수효과들을 아예 분리해서 각자의 일만 하게 두었다. 이런 방식으로는 각 액션별로 서로 영향을 주는 표현을 액션만으로 쉽게 나타낼 수 있게 된다. 실제 디스패치 하는 측에서도 비동기의 성공 여부를 고민할 것 없이 동기적 디스패치를 쓰는 것만으로 충분하다.</p><p>실제 작업은 Saga 내부적으로 처리되며 디스패치 된다.</p><h2 id="Saga-Effect"><a href="#Saga-Effect" class="headerlink" title="Saga-Effect"></a>Saga-Effect</h2><p>Saga 는 이러한 부수효과를 처리하는 이펙트들을 지원한다. 앞의 코드에서는 put 과 takeEvery 가 나왔었다.</p><blockquote><p>공식 문서의 Effect 들 <a href="https://redux-saga.js.org/docs/api/#effect-creators">https://redux-saga.js.org/docs/api/#effect-creators</a></p></blockquote><p>모든 effect 들은 반드시 yield keyword 와 함께 사용해야 한다</p><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p><code>take</code> 는 특정 액션을 감시하는 용도로 쓰인다.</p><p>다음 코드는 REQUEST_ORDER 액션이 디스패치될 때까지 기다린 후 Api.requestOrder 를 호출하는 예제이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">&#x27;REQUEST_ORDER&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line">    <span class="comment">// ... process ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>블럭된다는 성질을 이용해서 다음과 같이 매번 액션에 대해 반응하는 saga 를 만들 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 무한 루프</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">&#x27;REQUEST_ORDER&#x27;</span>); <span class="comment">// 하지만 이 라인에서 블럭된다.</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line">        <span class="comment">// ... process ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 saga 를 만들일이 많으므로 공식적으로 이런 동작의 헬퍼인 takeEvery, takeLatest, takeLeading 등을 제공하고 있다</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put effect 는 단순하다.</p><p>redux의 dispatch 함수와 완전히 동일하다. 이 effect 는 블럭되지 않기에 조심해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 무한 루프</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">&#x27;REQUEST_ORDER&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 결과를 스토어에 디스패치(put) 한다.</span></span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;RESPONSE_ORDER&#x27;</span>, result &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>새로운 하위 saga 태스크를 생성하는 effect 이다.</p><p>fork 는 블럭되지 않으며 호출 시점에 호출자는 부모 task 가 되고 fork 된 saga 는 자식 task 가 된다. 부모 task 가 취소되면 자식 task 도 취소된다.</p><p>명시적으로 특정 자식 태스크만 취소시킬수도 있다.</p><p>아래에 예제가 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parentTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> task1 = <span class="keyword">yield</span> fork(childTask1);</span><br><span class="line">    <span class="keyword">const</span> task2 = <span class="keyword">yield</span> fork(childTask2);  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... do something ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 아직 동작중이면 취소시킨다.</span></span><br><span class="line">    <span class="keyword">if</span>(task2 &amp;&amp; task2.isRunning()) &#123;</span><br><span class="line">        task2.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>call 은 블럭되는 fork 라고 보면 된다. 인자로 함수나 saga task 를 받을 수 있다.</p><p>두번째부터는 실행될 함수나 사가의 인자로 들어간다.</p><p>보통 Promise 등의 실행 (보통은 Ajax Call) 에 쓰이며 Promise 가 resolve 될 때까지 블럭된다.</p><p>예제는 위에 이미 있으므로 생략한다.</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>redux 의 state 에서 특정 상태를 가져올때 사용하는 effect 이다.</p><p>redux-thunk 의 getState 와 비슷하지만, 인자로 셀렉터를 줄 수 있다.</p><p>블럭 effect 이다.</p><p>아래 예제는 활성 유저를 redux state 에서 찾은 뒤 그 아이디로 유저 정보를 Ajax call 하는 예제이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeUserSelector = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.user.activeUser;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> getUserData = <span class="function"><span class="params">userId</span> =&gt;</span> ajax(<span class="string">`/user/data/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parentTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> activeUser = <span class="keyword">yield</span> select(activeUserSelector);</span><br><span class="line">    <span class="keyword">const</span> activeUserData = <span class="keyword">yield</span> call(getUserData, activeUser.userId); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Redux-Saga 소개</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/js.jpg" type="image"/>
    
    
    <category term="javascript" scheme="https://blog.javarouka.me/categories/javascript/"/>
    
    <category term="react" scheme="https://blog.javarouka.me/categories/javascript/react/"/>
    
    <category term="redux-saga" scheme="https://blog.javarouka.me/categories/javascript/react/redux-saga/"/>
    
    
    <category term="javascript" scheme="https://blog.javarouka.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Java HashMap 구현에 대해 (Effective java 3th - Item11)</title>
    <link href="https://blog.javarouka.me/2018/11/28/java%EC%9D%98-HashMap-%EA%B5%AC%ED%98%84%EC%97%90-%EB%8C%80%ED%95%B4/"/>
    <id>https://blog.javarouka.me/2018/11/28/java%EC%9D%98-HashMap-%EA%B5%AC%ED%98%84%EC%97%90-%EB%8C%80%ED%95%B4/</id>
    <published>2018-11-27T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map-인터페이스"><a href="#Map-인터페이스" class="headerlink" title="Map 인터페이스"></a>Map 인터페이스</h2><p>Map 같은 동작을 하는 키-값의 자료구조는 <a href="https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B4%80_%EB%B0%B0%EC%97%B4">연관 배열</a>이라고 부르는 자료구조이다. 언어에 따라 Dictionary, Map, Symbol Table 등등으로 바꿔 부르기도 한다.</p><h3 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h3><p><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Map.html">Map Interface(JDK9 기준)</a> 는 단순하던 JDK 7 구현에서(기본적인 CRUD 성의 메서드 지원만 했다.) <code>default method</code> 가 추가된 JDK 8에서는 편의성 메서드들이 대거 추가되었다.</p><ul><li>편의성을 위해 지정된 값에 대해 일정 연산을 수행하고 그 결과를 갱신하는 compute, computeIfAbsent, computeIfPresent, merge</li><li>요소를 엔트리로 순회가능한 forEach</li><li>값을 보고 없으면 두번째 인자를 반환하는 getOrDefault</li><li>첫번째 인자로 준 키가 없을때만 넣는 putIfAbsent</li><li>값과 키 둘이 일치해야 삭제하는 remove(key, value)</li><li>값을 교체하는 replace, replaceAll</li></ul><p>이 중 getOrDefault 는 특정 경우에 따라 computeIfAbsent 와 대체해서 코드 량을 더욱 줄일 수 있다.</p><p>다음과 같은 코드를 보자. </p><p>키가 문자열이고 리스트가 값인 맵에서 특정 문자열 키의 값이 없다면 해당 값을 기본값을 리스트에 넣고 리스트를 값으로 put 하는 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; strListMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본값 넣기</span></span><br><span class="line">List&lt;String&gt; list = strListMap.getOrDefault(<span class="string">&quot;locale&quot;</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">list.add(<span class="string">&quot;ko_KR&quot;</span>);</span><br><span class="line">strListMap.put(<span class="string">&quot;locale&quot;</span>, list);</span><br></pre></td></tr></table></figure><p>이 코드를 computeIfAbsent 와 람다로 한줄로 줄일 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; strListMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본값 넣기</span></span><br><span class="line">strListMap.computeIfAbsent(<span class="string">&quot;locale&quot;</span>, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;()).add(<span class="string">&quot;ko_KR&quot;</span>);</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/@hun/java-8%EC%9D%98-%EB%9E%8C%EB%8B%A4-%ED%95%A8%EC%88%98-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-1767d034f962#e8d1">Java 8의 람다 함수 살펴보기:성능 비교</a> 를 참고해보자.</p><h3 id="JDK-9"><a href="#JDK-9" class="headerlink" title="JDK 9"></a>JDK 9</h3><p>JDK 9 에서는 좀더 기능이 확장되어 불변 맵을 생성하는 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/Map.html#immutable">of default</a> 메서드가 추가되었다.</p><p>오버로딩이 꽤 많이 되어 최대 인자 20개로 10개까지의 원소를 가지는 맵을 생성할 수 있다. 구현이 너무 정직해서 놀랐다.</p><p><a href="https://github.com/google/guava">Google Guava</a> 에는 이미 구현되어 있던 기능이다. 그냥 Guava를 정식 라이브러리로 하면 어떨까 싶다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; immutableMap = Map.of(<span class="string">&quot;키1&quot;</span>, <span class="string">&quot;값1&quot;</span>, <span class="string">&quot;키2&quot;</span>, <span class="string">&quot;값2&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Map-의-hash-함수"><a href="#Map-의-hash-함수" class="headerlink" title="Map 의 hash 함수"></a>Map 의 hash 함수</h2><p>Java 에서는 hashCode 라는 메서드가 기본적으로 최상위 클래스인 Object 에 존재한다.</p><p>이 코드로 Map 에 사용되는 key 를 대체하면 좋겠지만, hashCode 는 int 형이기에 Map 에 저장할 수 있는 객체의 숫자는 2의 32제곱의 사이즈만으로 제한될 것이다. 그렇다고 hashCode 를 long 으로 키워도 문제고, 다른 타입으로 교체할 경우 계산에 따른 성능 문제가 발생할 수 있다. </p><p>이런걸 다 무시하고 억지로 적용한다 쳐도, Map 이 생성될때마다 2의 32제곱의 사이즈만큼의 저장소(버킷이라고 한다)를 초기화해둬야 한다.</p><p>그래서 Map 의 버킷은 타협을 일정량의 버킷만 생성하고 몇가지 전략으로 버킷 충돌을 관리한다 (Open Addressing, Separate Chaining). Java 에서 사용하는 버킷 충돌 회피는 Separate Chaining 이며, 버킷을 일종의 LinkedList 로 관리한다.</p><p>버킷내의 충돌이 발생하면 기존 key와 신규 key의 equals 호출로 다시한번 중복여부를 검사하여 값을 교체하기에 키가 될 객체 Class 의 equals 구현은 상당히 중요하다.</p><p>hashCode 의 구현 규칙에서 <code>두 객체가 다르더라도 두 객체가 서로 다른 hashCode 를 반환하지 않아도 된다</code> 라는 건 이 때문이다.</p><p>하지만 둘다 다르게 구현하는게 Map의 성능 향상에 크게 도움이 된다. (특정 버킷에 편중되어 저장되는 현상을 회피할 수 있고, 충돌 버킷의 순회 비용이 줄어든다)</p><p>위 조건을 만족하는 hashCode 구현을 <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">완전 해시 함수</a> 라고도 부른다</p>]]></content>
    
    
    <summary type="html">equals를 재정의하려거든 hashCode도 재정의하라</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>Equals 구현과 리스코프 치환 법칙 (Effective java 3th - Item10)</title>
    <link href="https://blog.javarouka.me/2018/11/27/object-equals-liskov/"/>
    <id>https://blog.javarouka.me/2018/11/27/object-equals-liskov/</id>
    <published>2018-11-26T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="equals-구현-규칙"><a href="#equals-구현-규칙" class="headerlink" title="equals 구현 규칙"></a>equals 구현 규칙</h2><p>equals 는 정해진 법칙에 따라 다양한 객체에서 호출되고 있다.</p><p>규칙을 지키지 않은 구현으로 의존성 객체에 처리를 맡긴다면, 의도하지 않은 동작이 발생하고 디버깅을 어렵게 만든다.</p><p>규칙들은 다음과 같다.</p><ul><li>반사성</li><li>null은 항상 false</li><li>대칭성</li><li>추이성</li><li>일관성</li></ul><h3 id="반사성"><a href="#반사성" class="headerlink" title="반사성"></a>반사성</h3><p>context 와 null이 아닌 인자가 같을 경우 항상 true 가 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.equals(context); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="대칭성"><a href="#대칭성" class="headerlink" title="대칭성"></a>대칭성</h3><p>context 가 어떤 대상 some 과 같다면 그 역방향도 true 가 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.equals(some); <span class="comment">// true</span></span><br><span class="line">some.equals(context); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>상속관계가 아닌 타입이 다른 객체에서 객체의 equals 비교로 true를 반환하는 구현은 거의 99.99% 대칭성 위반에 걸린다.</p><h3 id="추이성"><a href="#추이성" class="headerlink" title="추이성"></a>추이성</h3><p>말이 어려운데, A와 B가 같고 B와 C가 같다면 A와 C는 같아야 한다는 어디선가 본 논리적 법칙이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.equals(some); <span class="comment">// true</span></span><br><span class="line">some.equals(another); <span class="comment">// true</span></span><br><span class="line">context.equals(another); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>이 구현에서 주의할 것은 상속관계가 얽힐 때다.</p><p>특정 클래스를 확장하여 새로운 필드등을 추가한 클래스는 추이성을 만족시킬 수 없다.</p><p>특정 클래스를 특정지어 비교하는 방법으로 구현된 equals 의 경우 언뜻 조건 만족을 하는 것 같지만 리스코프 치환 법칙을 위배하기에 쓸 수가 없다.</p><p>이 경우에는 <a href="https://www.geeksforgeeks.org/association-composition-aggregation-java/">컴포지션</a> 을 통해 문제를 해결할 수 있다.</p><h4 id="리스코프-치환-법칙"><a href="#리스코프-치환-법칙" class="headerlink" title="리스코프 치환 법칙"></a>리스코프 치환 법칙</h4><p>서브타입은 언제나 자신의 상위 타입으로서의 기능을 해야 한다.</p><p>만일 상위 클래스가 직사각형이고, 하위 클래스를 정사각형이라고 해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(height, width);</span><br><span class="line">        <span class="keyword">if</span>(height != width) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionException(<span class="string">&#x27;cannot create!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height != width) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionException(<span class="string">&#x27;cannot create!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">super</span>(height, width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>직사각형(Rectangle) 은 마음대로 크기 조절이 가능하지만 정사각형(Square) 은 크기 조절에 제약이 있다.</p><p>일견 문제가 없어 보이지만 문제는 정사각형이 직사각형의 문맥에서 사용될 때다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 직사각형 문맥 로직 수행</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeWideSize</span><span class="params">(Rectangle rec)</span> </span>&#123;</span><br><span class="line">    dim.setSize(dim.getHeight(), dim.getWidth() * <span class="number">2</span>); <span class="comment">// throw Exception.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자 측에서는 직사각형이라고 생각하고 인자를 처리하고 있다.</p><p>하지만 불행히도 객체지향의 인자는 <a href="https://edykim.com/ko/post/what-is-coercion-and-anticommunism/">반공변적(contravariant)</a>이다. 이 뜻은 인자는 실제 객체의 하위타입이 올 수 있다는 뜻이다.</p><p>예제에서는 <strong>직사각형(Rectangle) 뿐 아니라 정사각형(Square)</strong> 도 올 수 있다는 뜻이다.</p><p>그리고 어떤 객체가 오느냐에 따라 코드의 동작은 변한다. 이럴 경우 리스코프 치환 법칙이 깨졌다고 설명할 수 있다. 정사각형 객체의 가로세로의 크기가 달라져 버렸다.</p><h3 id="일관성"><a href="#일관성" class="headerlink" title="일관성"></a>일관성</h3><p>몇번을 호출해도 어떤 상황에서 호출해도 두 대상 객체의 내용이 같다면 결과는 항상 같아야 한다.</p><p>equals 는 언제나 해당 객체를 대상으로 동치성을 비교해야 하는데, 다른 조건을 참고해가며 비교하게 되면 이 조건이 깨지기 쉽다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">context.equals(some); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ignore) &#123;&#125;</span><br><span class="line">    context.equals(some); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">equals 는 일반 규약을 지켜 재정의하라</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>객체 소멸자의 슬픈 디자인 (Effective java 3th - Item8, 9)</title>
    <link href="https://blog.javarouka.me/2018/11/26/Finalizer%EC%99%80-Cleaner/"/>
    <id>https://blog.javarouka.me/2018/11/26/Finalizer%EC%99%80-Cleaner/</id>
    <published>2018-11-25T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finalize</code> 메서드를 Override 하면 해당 객체가 JVM 에게 Garbage Collection 을 해야 할 대상이 될 때 호출된다. 객체가 없어지기 전 다른 연관 자원을 정리하려는 의도로 작성된다.</p><p>하지만 이 메서드는 사용해서는 안되며 실제로 java9+ 부터 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#finalize--">Deprecated</a> 되어버렸다.</p><p>오류/시점/성능/수행성 뭐 하나 보장하지 못하며 때로는 영원히 수행되지 않거나 불행하게도 Lock 이 걸려 프로그램 전체가 블럭될 수도 있다.</p><p>java9 에서는 대안으로 Cleaner 를 지원하게 되었다</p><h2 id="Cleaner"><a href="#Cleaner" class="headerlink" title="Cleaner"></a>Cleaner</h2><p>Java9 에서 도입된 소멸자로 생성된 Cleaner 가 더 이상 사용되지 않을 때 등록된 스레드에서 정의된 클린 작업을 수행한다.</p><p>혹은 명시적으로 clean 을 수행할수도 있다. 보통 AutoCloseable을 구현해서 <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html">try-with-resource</a> 와 같이 사용한다. (이 편이 추천된다)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleaningRequiredObject</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cleaner cleaner = Cleaner.create​();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanData</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 여기서 클린 작업 수행</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CleanData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CleaningRequiredObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cleanData = <span class="keyword">new</span> CleanData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 등록</span></span><br><span class="line">        <span class="keyword">this</span>.cleanable = cleaner.register(<span class="keyword">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자칫 Clean 작업을 실제로 수행할 클래스의 디자인에 실패해서 다른 외부 참조나 의존성이 걸릴 경우, 최악의 경우 순환의존성 덕분에 GC의 기회가 없어질 수도 있다.</p><p>이를 피하기 위해 보통은 AutoCloseable - try-with-resource 로 안전장치를 거는 편이 좋다.</p><h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><p>I/O 등의 작업에서는 어떤 모듈이 사용이 종료될 경우 해당 자원을 해지하고 없애야 할때가 많다.</p><p>보통 그럴 경우 try-finally 구문으로 처리하는데 이 경우 코드가 상당히 지저분하다.</p><p>또한 작업 메서드가 오류가 나더라도 close 를 해야 할 경우와 close 자체에서도 오류를 던지는 경우가 있어 그 두 부분을 전부 try-catch 하다보면 코드 가독성은 현저하게 저하된다.</p><p>try-with-resource 로 이런 고충을 한방에 날려버릴 수 있다.</p><p>다음 Worker 클래스는 테스트를 위해 명시적으로 오류를 내고 있다. 이 경우에 try-with-resource 를 사용하면 아주 깔끔한 코드가 나오며, 오류또한 잘 캡처된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;work Exception!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;close Exception!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 짧다!</span></span><br><span class="line">        <span class="keyword">try</span>(Worker worker = <span class="keyword">new</span> Worker()) &#123;</span><br><span class="line">            worker.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출력 오류는 다음과 같다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: work Exception!</span><br><span class="line">at Boss$Worker.work(Boss.java:6)</span><br><span class="line">at Boss.main(Boss.java:16)</span><br><span class="line">Suppressed: java.lang.RuntimeException: close Exception!</span><br><span class="line">at Boss$Worker.close(Boss.java:10)</span><br><span class="line">at Boss.main(Boss.java:18)</span><br></pre></td></tr></table></figure><h2 id="Cleaner-Finalizer-둘다-애매하다"><a href="#Cleaner-Finalizer-둘다-애매하다" class="headerlink" title="Cleaner / Finalizer 둘다 애매하다."></a>Cleaner / Finalizer 둘다 애매하다.</h2><p>하지만 둘다 일반적으로는 사용이 불필요하다.</p><p>둘다 성능에 문제가 많고, Serialize 를 통한 보안 이슈가 존재하며, 수행 시점이 보장되지 않는다.</p><p>JVM 구현에 따라 동작도 매우 달라질 여지가 많다.</p><p>사용할수밖에 없을때는 다음과 같은 케이스가 있다</p><ul><li>JNI</li><li>Off-Heap 메모리 사용시 (DirectBuffer 류 사용시)</li></ul><h2 id="읽을만한-글"><a href="#읽을만한-글" class="headerlink" title="읽을만한 글"></a>읽을만한 글</h2><ul><li><a href="https://dzone.com/articles/javas-finalizer-is-still-there">Java’s Finalizer Is Still There</a></li><li><a href="https://d2.naver.com/helloworld/329631">Java Reference와 GC</a></li><li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/gc/phantom-reference.html">Java Garbage Collection - Understanding Phantom Reference with examples</a></li></ul>]]></content>
    
    
    <summary type="html">finalizer 와 cleaner 사용을 피하라</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
    <category term="try-with-resource" scheme="https://blog.javarouka.me/tags/try-with-resource/"/>
    
  </entry>
  
  <entry>
    <title>String과 Boxing, 그리고 객체생성 (Effective java 3th - Item6)</title>
    <link href="https://blog.javarouka.me/2018/11/25/%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EC%83%9D%EC%84%B1-%ED%9A%8C%ED%94%BC/"/>
    <id>https://blog.javarouka.me/2018/11/25/%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EC%83%9D%EC%84%B1-%ED%9A%8C%ED%94%BC/</id>
    <published>2018-11-24T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-재활용"><a href="#객체-재활용" class="headerlink" title="객체 재활용"></a>객체 재활용</h2><p>불변 객체이고, 재활용이 자주 되는 객체는 매번 생성해서 좋을게 없다. 미리 만들어두고 참조만 지정하면서 재사용하는게 유리하다.</p><p>Java 내부 구현에서도 String 이 이런 패턴을 따른다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure><p>나중에 다시 “world” 문자열이 필요해서 다음과 같이 선언해도 같은 객체를 사용함이 보장된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isEnd()) &#123;</span><br><span class="line">    String world = <span class="string">&quot;world&quot;</span>; <span class="comment">// 계속 같은 인스턴스 참조</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 동작하는 이유는 Java에서 쓰이는 모든 String 객체는 상수풀에서 관리되며 프로그램 종료때까지 유지되기 때문이다.</p><p>강제로 상수풀의 문자열을 사용하게 하는 메서드로 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#intern--">intern</a> 이 있다.</p><p><em>intern</em> 된 문자열은 상수 풀에서 사용되기에 true 를 반환한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">hello == <span class="keyword">new</span> String(<span class="string">&quot;world&quot;</span>); <span class="comment">// false</span></span><br><span class="line">hello == <span class="keyword">new</span> String(<span class="string">&quot;world&quot;</span>).intern(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Auto-Boxing-Auto-UnBoxing"><a href="#Auto-Boxing-Auto-UnBoxing" class="headerlink" title="Auto-Boxing / Auto-UnBoxing"></a>Auto-Boxing / Auto-UnBoxing</h2><p>Primitive 타입의 박싱에서 주의해야 할게 잘못 코딩할 경우 원치않는 객체 생성이 일어난다. 비슷하게 쓸 수 있다고 해서 루프문이나 과도한 계산에 박싱타입과 Primitive 타입을 섞어 쓸 경우에는 끔찍한 성능 이슈를 겪을수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> first = <span class="number">3L</span>;</span><br><span class="line"><span class="keyword">long</span> second = <span class="number">2L</span>;</span><br><span class="line">Long value = first + second; <span class="comment">// 객체 생성.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">불필요한 객체 생성을 피하라</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>신규 통합 CS 시스템 관리 개발기 # 혼란편</title>
    <link href="https://blog.javarouka.me/2018/11/23/new_project_2/"/>
    <id>https://blog.javarouka.me/2018/11/23/new_project_2/</id>
    <published>2018-11-22T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.872Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><a href="/2018/10/28/new_project_1/">신규 통합 CS 시스템 관리 개발기 # 설계편 #</a></li><li>신규 통합 CS 시스템 관리 개발기 # 혼란편 #</li></ul><hr><h2 id="생각-이상으로-많이-생기는-Behavior-DTO-문제"><a href="#생각-이상으로-많이-생기는-Behavior-DTO-문제" class="headerlink" title="생각 이상으로 많이 생기는 Behavior, DTO 문제"></a>생각 이상으로 많이 생기는 Behavior, DTO 문제</h2><p>단순 조회라도 Controller -&gt; Service -&gt; Behavior -&gt; Repository 로 이어진다.</p><p>그리고 그 레이어간의 통신시마다 각자의 레이어들이 요구하는 DTO 를 만들다보면, 필드 값들이 매우 유사한 많은 Class 가 정의된다.</p><p>특히 단순 아이디 조회건의 경우에는 형식적인 각 레이어 관련 class 들이 생성되고 그에 대응하는 동일 필드의 DTO 들이 정의되며, 그를 위한 변환 로직이 들어간다.</p><p align="center">    <img src="/asset/new_project/boxes.jpeg" alt="수많은..."><em>많다...</em></p><p>각 도메인의 지식이 명확하고 이해도가 깊다면, 모든 Layer 에서 참고할 수 있는 Top-Level 레이어 수준으로 Entity (JPA Entity 말고) 를 만들어볼 수 있겠지만, 현실은 쉽지 않았다. 전사 도메인이 그렇게 일관된 통일성이 있는게 아니라 A 비즈니스 팀 에서 해야할 일을 B 비즈니스 팀에서 하는 일도 있고 자주 바뀌기에 이것에 대응하려는 설계는 참으로 어려웠다.</p><p>하지만 정석은 언제나 통한다고 생각한다. 많은 시간을 들여 분석해가며 설계하면 이런 점까지 커버할 수 있는 시스템을 만들 수 있다. </p><p>하지만 이번에는 일단 초기에 만든 규칙대로 다수의 파일 생성도 감안하며 가는 방식을 선택했다. 후에 리팩토링을 통해서라도 개선하고 싶다.</p><h2 id="API-분할과-정의-문제"><a href="#API-분할과-정의-문제" class="headerlink" title="API 분할과 정의 문제"></a>API 분할과 정의 문제</h2><p><a href="https://blog.javarouka.me/2018/10/28/new_project_1/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%86%A0%EB%A7%89%EC%B9%98%EA%B8%B0">전 글</a> 에서 언급한 <code>데이터 토막치기</code> 로 간단히 데이터를 합쳐서 한방에 내려주는 방식이 아닌 각각의 논리적 단위로 데이터를 가져오는 방식으로 변하면서, 서버 API 설계가 상당히 중요해졌다.</p><p>API 를 전체적으로 알지 못하면 같은 데이터가 필요할 때 비슷한 기능의 API 가 생성될 수도 있고, 적절한 관리가 안될 경우 나중엔 비슷비슷한 응답의 endpoint 만 조금씩 다른 API가 많아질 수 있다.</p><p>이번에 작업한 내용은 <code>주문정보</code> 라는 컨텐츠 하나였지만 그 안에서도 서로 비슷한 필드 몇개만이 다른 endpoint API 가 몇개 정도 존재하게 되었고 그대로 product 배포 상태이다.</p><p>이 점은 문서화와 관련이 깊다고 생각한다.</p><p>나중에 문서화를 위해 다급히 <a href="https://swagger.io/">swagger</a> 를 붙이고 주석 <code>annotation</code> 을 코딩했지만 만족스럽진 않다.</p><p align="center">    <img src="/asset/new_project/use-swagger.png" alt="문서"><em>문서 정리는 언제나 귀찮다</em></p><p>개발단계에서 보다 쉽게 API 를 파악할 방법이 있다면 좋겠는데.</p><h2 id="Client-에서의-요청-증가-문제"><a href="#Client-에서의-요청-증가-문제" class="headerlink" title="Client 에서의 요청 증가 문제"></a>Client 에서의 요청 증가 문제</h2><p>역시 <code>데이터 토막치기</code> 로 인해 기존에 한방에서 여러 요청으로 나뉘면서 Http Request 의 숫자가 늘어났다.</p><p>데이터 각자가 자신이 필요한 데이터만 응답하기에 경량화된건 사실이다. 하지만 화면에서는 여전히 여러 데이터가 필요하고 그 데이터를 구하려면 필요한 수 만큼의 API 요청을 해야 한다. </p><p>복잡한 도메인이 포함된 비즈니스로 구성되는 컨테이너의 경우 많은 요청으로 인해 느릴 수밖에 없고 네트워크의 Latency 가 나쁜 상황에서는 몇배로 느려진다.</p><p align="center">    <img src="/asset/new_project/receipts.jpeg" alt="많은 영수증"></p><p>이 때문에 논리적인 데이터 토막을 잘 정의하는게 매우 중요하다. </p><p>데이터를 과하게 합쳐 응답할 경우 특정 UI 나 비즈니스만을 위한 API 가 되고, 과도하게 나눠 응답할 경우 Client 로직이 복잡해지고 Http request 가 증가한다.</p><p>이에 대해서는 확실한 기준을 세우지 못했다. 대략적으로 만든 아래와 같은 기준이 있을 뿐이다.</p><ul><li>반복적으로 조회되며 변경율이 낮은 상수 데이터는 앱 초기에 로딩하여 store 에 저장한다</li><li>키 조회 API 는 분리한다 (상품, 주문, 취소, 반품 …)</li><li>정책 API 는 분리한다 (취소가능, 배송지 변경가능, 접수 수정가능 …)</li><li>복수의 데이터의 조합으로 결정되는 데이터는 합친다 (회원 특별등급, 3P,Retail 배송상태 …)</li><li>데이터의 변경/생성/삭제 에 대해서는 최소한의 파라미터로 한번의 트랜잭션으로 처리한다</li></ul><h2 id="Client-로직에서의-Container-단위-정의-문제"><a href="#Client-로직에서의-Container-단위-정의-문제" class="headerlink" title="Client 로직에서의 Container 단위 정의 문제"></a>Client 로직에서의 Container 단위 정의 문제</h2><p>데이터를 분할해서 받았으니 역시 분할된 데이터를 조립해야 한다.</p><p>그 영역은 Container 라 부르는 Redux Store 에 <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connect">connect</a> 되는 영역에서 처리하기로 했다.</p><p>각 <a href="https://github.com/erikras/ducks-modular-redux">Ducks</a> 를 확장한 <a href="https://github.com/alexnm/re-ducks">ReDucks</a> 에서 <a href="https://github.com/alexnm/re-ducks#selectors">selector</a> entity 들의 데이터를 잘 조합하는 Container 용 selector 를 만든다. (selector 는 메모이징을 지원하도록 <a href="https://github.com/reduxjs/reselect">reselect</a> 를 사용했다)</p><p>Container 는 특정 목적의 비즈니스의 집합이라 UI 와 강하게 결합되기에 그냥 한파일에 selector 를 넣었다.</p><p>이렇다보니 Container 를 잘못 정의할 경우 엄청난 크기의 selector 가 만들어진다. 그렇다고 모든 UI Component 들을 Container 화 할 경우 모든 UI 에 entitiy selector 가 달리게 되고, 데이터 구조 변경에 강한 영향을 받게 된다.</p><p>현재는 데이터의 응집력(나름대로의…) 단위로 나눠두긴 했는데, 이것도 불명확하긴 매한가지. </p><p>참고할 만한 기준따위 있을리도 없고, 결국에는 실전 운영으로 타협점을 찾아가는게 좋을 듯 하다.</p><h2 id="Webpack-Code-Splitting-문제"><a href="#Webpack-Code-Splitting-문제" class="headerlink" title="Webpack Code Splitting 문제"></a>Webpack Code Splitting 문제</h2><p>asset(js, css, images…)들의 로딩은 단일 서버 운영에서는 문제가 일어나지 않는다.</p><p>하지만 복수의 서버로 운영되는 환경에서 운영되는 배포 프로세스중에는 <a href="https://martinfowler.com/bliki/CanaryRelease.html">Canary Release</a> 라는 방식이 있다.</p><blockquote><p>Canary Release 는 새로운 버전의 소프트웨어를 운영 환경에 배포할 때, 전체 사용자들이 사용하도록 모든 인프라에 배포하기 전에 소규모의 사용자들에게만 먼저 배포함으로써 리스크를 줄이는 기법이다. <br/>- <a href="https://m.blog.naver.com/PostView.nhn?blogId=muchine98&logNo=220262491992&proxyReferer=https://www.google.co.kr/">너굴너굴 블로그</a></p></blockquote><p>이 환경에서는 일정 기간동안은 asset 의 버전이 다른 미배포 서버와 canary 서버가 다를 수 있는데 canary 서버의 변경이 있는 상태에서 변경되지 않은 미배포 서버의 asset 을 로딩할 경우 asset 버전 불일치로 인한 장애가 발생할 수 있다.</p><p>꼭 canary 방식이 아니더라도 순차적으로 N대씩 배포되는 환경에서는 문제가 발생한다.</p><p>Webpack 에서는 기본 전략으로 asset 파일들을 hash 문자열로 변환하여 배포시마다 파일이름이 <code>[hash].[ext]</code> 형식으로 번들되어 배포되는데, 문제는 canary 서버가 배포된 뒤 이 서버에서 asset 을 미배포 서버에 요청하게 되는 일이다. 당연히 해당 asset 은 없어서 404 error 가 발생한다.</p><p>파일 이름을 강제로 고정 이름 (예를 들면 534fsdnfg23543gf.js 가 아닌 main.js) 으로 정해도 되지만, 이 경우 client cache 를 피하기 어렵다.</p><p align="center">    <img src="/asset/new_project/code-split.png" alt="코드 분할"></p><p>운 좋게 canary 서버가 요청한 asset 을 canary 가 받았다 하더라도, Chunck 등의 <a href="https://webpack.js.org/guides/code-splitting/">Code Splitting</a> 이나 <a href="https://webpack.js.org/guides/lazy-loading/">Lazy Loading</a> 등을 적용해뒀다면 Chunk Loading Error 도 보게 된다.</p><p>처음에는 장애 포인트를 알 수 없어서 Canary Release 를 건너뛰고 항상 Deploy All 을 했었다.</p><p>해결책은 S3빌드번호를 webpack 번들링 타이밍에 인자로 넘겨 output 설정에 <a href="https://webpack.js.org/guides/public-path/">Public Path</a>를 만드는 방법이었다.</p><p>Public Path 가 고정되니 배포 Scope 으로 asset 을 요청하게 되고 자신의 배포버전에 맞는 asset 을 서버에서 로딩하도록 유도할 수 있었다.</p><p>이부분에서 꽤나 많은 시행착오가 있었던걸로 기억한다.</p><h2 id="익숙하지-않은-도구들-문제"><a href="#익숙하지-않은-도구들-문제" class="headerlink" title="익숙하지 않은 도구들 문제"></a>익숙하지 않은 도구들 문제</h2><h3 id="styled-component"><a href="#styled-component" class="headerlink" title="styled-component"></a>styled-component</h3><p align="center">    <img src="/asset/new_project/styled-component.png" alt="Styled Component"></p><p>스타일 도구로 <a href="https://www.styled-components.com/">styled-component</a> 를 사용했는데, 기존의 css 와 className 개념과는 아주 달랐다. Component 에서 Style 의 요소를 Component 로 분리하는 생각이 생각대로 잘 되지 않았다.</p><p>별도 파일로 분리해야 하는 것인가, 기존 css 처럼 하나의 파일에 전부 모아두고 selection import 하는 방식인 것인가부터, 어느 레벨로 그룹해야 하는지도 혼란스러웠다.</p><p>문법적으로도 3.x 버전과 4.x 버전의 과도기에 사용해서 라이브러리의 구조가 변했고, 대응하느라 리소스의 낭비도 있었다.</p><p>사용하면서 내린 나름의 결론은 이렇다.</p><ul><li>각 컴포넌트는 가급적 <a href="https://reactjs.org/docs/fragments.html">React.Fragment</a> 로 래핑한다</li><li>부모 레벨이 자식 컴포넌트의 스타일을 지정할 수 있게 한다. StyleComponent 로 자식을 감싸서 사용한다는 뜻이다</li><li>StyleComponent 든 DataComponent 든 네이밍과 파일 단위는 동일하게 한다. 사용 측에서는 이 컴포넌트가 Style 인지 Data 인지 알 필요가 없다.</li></ul><p>현재 (2018.11.23) 운영 배포된 소스는 위의 룰을 지키지 못했다. 천천히 수정해야 할 일이다.</p><h3 id="Redux-Saga"><a href="#Redux-Saga" class="headerlink" title="Redux-Saga"></a>Redux-Saga</h3><p align="center">    <img src="/asset/new_project/redux-saga.png" alt="Redux Saga"></p><p><a href="https://github.com/redux-saga/redux-saga">Redux-Saga</a> 의 사용에 미숙하여 여러 착오를 겪었다.</p><p>제일 심하게 겪은 문제는 <a href="https://redux-saga.js.org/docs/api/#takepattern">take</a> 관련인데 <code>Ajax 등의 비동기 Side-Effect 를 동반하는 Task</code> 일 경우 같은 요청이 다수가 중복된다면 첫번째만 처리하는 것이 보통 효율이 좋다. 이런 경우는 대부분 사용자의 반복된 클릭등으로 요청되는게 대부분이기 때문이다.</p><p>Saga 에서는 <a href="https://redux-saga.js.org/docs/api/">Helper 함수</a>로 <code>takeLatest</code>, <code>takeEvery</code>, <code>takeLeading</code> 등을 지원한다</p><ul><li>takeEvery<ul><li>매번 요청건 처리</li></ul></li><li>takeLatest<ul><li>제일 마지막 건만 처리</li></ul></li><li>takeLeading<ul><li>제일 첫번째 건만 처리</li></ul></li></ul><p>개발 초기에는 대부분의 Saga Watcher 에 takeLeading (1.x) 을 걸어두었다. 중복 요청일 경우 두번째는 무시하기 위해서이다. </p><p>하지만 나중에 테스트와 액션 리포트를 보면 사용자의 반복 요청에 막히는 것은 거의 없고 오히려 특정 사이드이펙트 action watcher (트리거 action이 여러개 존재하는 watcher) 가 서로 다른 action dispatch 에 영향받게 되면서 나중 요청을 전부 씹는 상황이 발생했다</p><p>예를 들면 주문 상세를 트리거하는 ORDER_DETAIL 액션으로 주문 A 를 trigger 했다가 바로 B 를 trigger 하면 주문 A 의 정보를 로딩하는 watcher 들이 takeLeading 방식이라 나중에 들어온 B 정보 action 을 dispatch 하지 않고 주문 A 관련만을 처리하게 되는 것이다.</p><p><code>take</code> 디자인에도 생각없이 하면 안된다는 걸 깨닫고 액션과 UI 의 관계에 따라 다른 <code>take</code> 전략을 사용해야 한다는 걸 깨달았다. 잘 모르겠으면 <a href="https://redux-saga.js.org/docs/api/#saga-helpers">take helper</a> 들을 안쓰는 것도 좋은 방법인것 같다.</p><p><code>fork</code> 된 액션은 부모의 try-catch 에 영향이 없다라든지 <code>call</code> 과 <code>fork</code> Blocking 차이라든지 하는 Redux-Saga 이해도가 부족한 것에서 오는 어려움도 있었지만 이런건 <a href="https://mskims.github.io/redux-saga-in-korean/">Document</a> 를 잘 봤으면 해결될 문제라…</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>CS 상담 시스템 개편이 현재 시간 기준 한창 테스트중이다.</p><p>여러모로 아쉬운 점이 많은 프로젝트였다. 여기엔 적지 않았지만 잘못된 시간분배나 플래닝, 계획들도 큰 장애거리였다.</p><p>테스트 결과와는 관계없이 기록을 남겨 나중에 기술 선택에 좀더 도움이 되길 바랄 뿐이다.</p>]]></content>
    
    
    <summary type="html">혼란하다</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/java-logo.png" type="image"/>
    
    
    <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="javascript" scheme="https://blog.javarouka.me/tags/javascript/"/>
    
    <category term="scaffolding" scheme="https://blog.javarouka.me/tags/scaffolding/"/>
    
    <category term="legacy" scheme="https://blog.javarouka.me/tags/legacy/"/>
    
    <category term="new-cs-system" scheme="https://blog.javarouka.me/tags/new-cs-system/"/>
    
  </entry>
  
  <entry>
    <title>Dependency Inject &amp; Dispatch (Effective java 3th - Item5)</title>
    <link href="https://blog.javarouka.me/2018/11/21/dependency-inject/"/>
    <id>https://blog.javarouka.me/2018/11/21/dependency-inject/</id>
    <published>2018-11-20T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>java 객체지향은 많은 모듈들의 의존성으로 이뤄진다. 다만 의존성을 코드상에 명시할 경우 그 의존성이 클라이언트 코드에 강하게 결합되게 된다.</p><p>다음과 같은 싱글턴 클래스가 있다. 만화 드래곤 볼에 나오는 드래곤 레이더이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DragonBallRadar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HeightMap heightMap = <span class="keyword">new</span> EarthMap();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DragonBallRadar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">detect</span><span class="params">()</span> </span>&#123; <span class="comment">/* 구현 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 드래곤 레이더는 지구에서는 아주 잘 동작할 것이다. 지구에 대한 데이터가 미리 주어지기 때문에 지구에 대해 드래곤 볼의 위치를 잘 표시할 수 있다.</p><p>하지만 작중에서 피콜로가 죽고 나메크별로 무대가 옮겨지는 때가 있다. 안타깝지만 부르마와 Z 전사들은 이 드래곤 레이더로 나메크성의 드래곤볼을 찾을 수 없게 될것이다.</p><p>이 레이더는 지구맵만 지원하고 있기 때문이다.</p><p><code>높이맵 (HeightMap)</code> 을 바꾸기 위해 <code>setHeightMap</code> 를 추가할수도 있지만, 싱글톤 객체에 setter 를 추가하는건 멀티환경에서는 오류를 내기 쉽다.<br>다수의 스레드의 접근 상태에서 setter 를 호출할 경우 의도하지 않은 오류가 발생할 수 있고 문법적으로 매우 어색하다.</p><p>정적 클래스의 메서드는 같은 상태일 때 A 를 호출하면 B 를 받는 순수 함수의 형태가 되어야 옳다. 상태를 가지는 것도 물론 어색하다.</p><blockquote><p>사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다<br/>-Effective Java 3th 29 page</p></blockquote><p>이 경우에는 정적 메소드는 지양해야 하며, 사용자 측에서 높이맵을 바꿔줄 수 있어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DragonBallRadar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HeightMap heightMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DragonBallRadar</span><span class="params">(Supplier&lt;HeightMap&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.heightMap = supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">detect</span><span class="params">()</span> </span>&#123; <span class="comment">/* 구현 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Framework 를 사용하면서 자연스럽게 쓰고 있을 규칙이지만, 간혹 static 과 의존성을 섞어 쓰는 사례가 있는데 조심해야 한다. 의존성이 추가되기 전에도 정적 메서드는 호출할 수 있으며, Spring Application Context 가 완전히 초기화되기 전에 정적 메서드가 호출된다면 문제가 생길 것이다.</p><p>간단한 변경으로 나메크별의 높이맵 생성 팩토리를 만들어 주입한 결과 이제 프리저보다 먼저 드래곤볼을 찾을 수 있게 됨은 물론, 나중에 지구에서도 사용할 수 있는 만능 레이더가 되었다.</p>]]></content>
    
    
    <summary type="html">자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
    <category term="di" scheme="https://blog.javarouka.me/tags/di/"/>
    
    <category term="double dispatch" scheme="https://blog.javarouka.me/tags/double-dispatch/"/>
    
  </entry>
  
  <entry>
    <title>LazyHolder 기법 (Effective java 3th - Item4)</title>
    <link href="https://blog.javarouka.me/2018/11/20/no-instance/"/>
    <id>https://blog.javarouka.me/2018/11/20/no-instance/</id>
    <published>2018-11-19T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>Java 에서의 생성자는 접근제어로 통제할 수 있기에 객체 생성에 생성자를 쓰고 싶지 않다면, private 접근제어를 줘서 막자.</p><p align="center">    <img src="/asset/images/effective/item4-cannot-extends-because-private.png"></p><p>위 그림의 예제처럼, 상속을 방어하는 효과도 있다.</p><p>클래스 A 는 B의 생성자를 체이닝하려 하지만 접근이 막혀 컴파일 오류를 발생시킨다.</p><h2 id="LazyHolder-기법"><a href="#LazyHolder-기법" class="headerlink" title="LazyHolder 기법"></a>LazyHolder 기법</h2><p>책에는 소개되지 않지만 싱글턴 기법으로 <code>LazyHolder</code> 라는 방법이 있다.</p><p>책에서는 Enum 방식을 안전하다고 제안하고 있지만 Android 같이 <a href="https://www.google.co.kr/search?q=androlid+Context">Context</a> 의존성이 있는 환경일 경우, Singleton의 초기화 과정에 Context라는 의존성이 끼어들 가능성이 있다.</p><p><code>LazyHolder</code> 는 그에 대한 대안으로 나온 방법이다. JVM에게 객체의 초기화를 떠님기는 방식으로, 멀티스레드 환경에서도 객체의 단일성을 보장할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OnlyOne</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OnlyOne <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.IT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> OnlyOne IT = <span class="keyword">new</span> OnlyOne();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체 생성을 담당할 내부클래스를 하나 정의하는데, 이것이 <code>LazyHolder</code> 다.<br>OnlyOne 클래스는 초기에는 아무런 상태가 없기에 LazyHolder 클래스를 초기화하지 않지만, <code>getInstance</code> 메서드가 호출될 때 LazyHolder 가 로딩되며 초기화가 진행된다.</p><p>클래스의 내부의 클래스는 외부의 클래스가 초기화될때 초기화되지 않고, 클래스의 static 변수는 클래스를 로딩할 때 초기화되는 것을 이용한 기법이다.</p><p>Class 를 로딩하고 초기화하는건 JVM 의 영역이고 <code>Thread Safe</code> 를 보장한다.</p>]]></content>
    
    
    <summary type="html">인스턴스화를 막으려거든 private 생성자를 사용하라</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
    <category term="singleton" scheme="https://blog.javarouka.me/tags/singleton/"/>
    
    <category term="lazyholder" scheme="https://blog.javarouka.me/tags/lazyholder/"/>
    
  </entry>
  
  <entry>
    <title>Java 의 Serialize (Effective java 3th - Item3)</title>
    <link href="https://blog.javarouka.me/2018/11/19/serialize-java/"/>
    <id>https://blog.javarouka.me/2018/11/19/serialize-java/</id>
    <published>2018-11-18T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Serialize"><a href="#Serialize" class="headerlink" title="Serialize?"></a>Serialize?</h2><p>JVM 메모리 - Heap or Stack - 에 있는 객체 데이터를 바이트 형태로 변환하는 기술. 이 역방향 변환을 Deserialize 라고 한다.</p><p>Java 에서의 <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a>은 별도의 처리 없이도 Serialize 가 가능하다. 다만 Object 형식의 객체는 <a href="https://docs.oracle.com/javase/9/docs/api/java/io/Serializable.html">java.io.Serializable</a> 을 구현해야 Serialize 대상이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Serializable 를 구현해서 Serialize 가능하게 한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sleep</span><span class="params">(<span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Serialize 에는 <a href="https://docs.oracle.com/javase/9/docs/api/java/io/ObjectOutputStream.html">java.io.ObjectOutputStream</a> 을 사용한다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sleep sleep = <span class="keyword">new</span> Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    ByteArrayOutputStream arraySerializer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream objectSerializer = <span class="keyword">new</span> ObjectOutputStream(arraySerializer);</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 실제 Serialize 수행</span></span><br><span class="line">    objectSerializer.writeObject(sleep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 배열로 저장</span></span><br><span class="line">    persistSerialized(arraySerializer.toByteArray());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>(IOException serializeFailed) &#123;</span><br><span class="line">    handleSerializeFail(serializeFailed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>Serialize/Deserialize 간에 Serialize 대상의 고유 번호 표시이다.</p><p>Serialize 인터페이스를 상속한 클래스는 가급적 이 번호도 추가하는게 좋다.</p><p><code>serialVersionUID</code>는 명시적인 선언 없이도 자동으로 생성되나 없을 경우 <a href="https://docs.oracle.com/javase/10/docs/specs/serialization/class.html#inspecting-serializable-classes">특정 알고리즘을 사용</a> 하여 클래스의 해시값으로 지정된다.</p><p>Serialize 는 상당히 까다롭게 동작한다.</p><p>클래스가 같더라도 Serialize/Deserialize 시에 serialVersionUID 값이 다르다면 InvalidClassException 이 던져진다</p><p>자동 생성된 serialVersionUID 는 클래스의 해시값이기에 클래스 구조에 변화가 생기면 다를 수밖에 없다. 또한, 명시적인 선언이 있어도 데이터 타입이 변경될 경우 오류가 발생한다. 이 경우에는 InvalidClassException 이 던져진다.</p><h2 id="Pre-Process-Methods"><a href="#Pre-Process-Methods" class="headerlink" title="Pre-Process Methods"></a>Pre-Process Methods</h2><p>Serialize/Deserialize 중 Singleton 등의 인스턴스 제한, 알수없는 데이터에 대한 Deserialize 검증 등의 특수한 처리가 필요할 경우가 종종 있다.</p><p>이럴 경우에 대해 Serialize 전처리 메서드들이 준비되어 있다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br><span class="line"><span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br><span class="line"><span class="function">Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></table></figure><h3 id="writeObject-readObject"><a href="#writeObject-readObject" class="headerlink" title="writeObject/readObject"></a>writeObject/readObject</h3><p>해당 class 에 위의 전처리 메서드를 구현할 경우 Serialize/Deserialize 시에 호출된다. 보통은 해당 클래스의 상태에 전처리를 할때 사용한다. </p><p>특정 데이터를 writeObject 시에 추가한뒤 readObject 시에 다시 읽거나, 외부 시스템으로부터 받은 수상한 데이터에 대한 방어 목적으로도 사용할 수 있다. 객체에 특정 서명을 추가하거나 해서 어느정도의 보안도 적용 가능해진다.</p><p>만일 이 메서드에서 NotSerializableException 을 던지게 되면 Serialize 가 불가능하게 된다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * place 필드는 transient 로 실제 직렬화 대상이 아니지만</span></span><br><span class="line"><span class="comment"> * writeObject/readObject 구현으로 추가로 직렬화에 포함시켰다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String place;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sleep</span><span class="params">(<span class="keyword">int</span> duration, String place)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">        <span class="keyword">this</span>.place = place;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.defaultWriteObject(); <span class="comment">// static, transient 필드를 제외하고 현재 객체에서 데이터를 읽는다.</span></span><br><span class="line">        out.writeObject(<span class="keyword">this</span>.place);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        in.defaultReadObject(); <span class="comment">// static, transient 필드를 제외하고 현재 객체로 데이터를 읽는다. </span></span><br><span class="line">        <span class="keyword">this</span>.place = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readObjectNoData"><a href="#readObjectNoData" class="headerlink" title="readObjectNoData"></a>readObjectNoData</h3><p><a href="https://stackoverflow.com/questions/7445217/java-when-to-add-readobjectnodata-during-serialization/7445415">https://stackoverflow.com/questions/7445217/java-when-to-add-readobjectnodata-during-serialization/7445415</a></p><h3 id="writeReplace-readResolve"><a href="#writeReplace-readResolve" class="headerlink" title="writeReplace/readResolve"></a>writeReplace/readResolve</h3><p>이 메서드를 구현해서 원래 Serialize/Deserialize 대상 객체를 변경할 수 있다.<br>직렬화에 대한 프록시 기능이나 인스턴스 수 제한에 유용하다.</p><p>링크 하나 공유한다.</p><p><a href="http://thecodersbreakfast.net/index.php?post/2011/05/12/Serialization-and-magic-methods">Serialization and magic methods</a></p>]]></content>
    
    
    <summary type="html">private 생성자나 열거 타입으로 싱글턴임을 보장하라</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
    <category term="serialize" scheme="https://blog.javarouka.me/tags/serialize/"/>
    
  </entry>
  
  <entry>
    <title>빌더 패턴 (Effective java 3th - Item2)</title>
    <link href="https://blog.javarouka.me/2018/11/14/builder/"/>
    <id>https://blog.javarouka.me/2018/11/14/builder/</id>
    <published>2018-11-13T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-생성시에-거슬리는-요인"><a href="#객체-생성시에-거슬리는-요인" class="headerlink" title="객체 생성시에 거슬리는 요인"></a>객체 생성시에 거슬리는 요인</h2><ul><li>많은 인자<ul><li>인자의 순서를 실수할 경우가 잦아진다</li></ul></li><li>기본값<ul><li>옵셔널 기본값을 주고 싶지만 주기 어렵다</li></ul></li><li>많은 멤버<ul><li>수많은 멤버를 가진 객체의 경우 생성자가 비대해진다</li></ul></li></ul><p>기본 생성자 호출 뒤 Setter로 하나하나 세팅하는 방법도 있지만 시간의 흐름에 따라 멤버가 초기화되기에 일관성이 해쳐진다. </p><p>그리고 불변객체를 만들 수 없어 스레드, 코딩 안정성이 저하된다.</p><h2 id="그래서-준비했습니다"><a href="#그래서-준비했습니다" class="headerlink" title="그래서 준비했습니다"></a>그래서 준비했습니다</h2><h3 id="일반적인-빈즈의-빌더-패턴"><a href="#일반적인-빈즈의-빌더-패턴" class="headerlink" title="일반적인 빈즈의 빌더 패턴"></a>일반적인 빈즈의 빌더 패턴</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Car &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Car</span><span class="params">(String name, <span class="keyword">int</span> price, Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">// 필수값</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> price = <span class="number">0</span>; <span class="comment">// 기본값</span></span><br><span class="line">        <span class="keyword">private</span> Color color = Color.RED; <span class="comment">// 기본값</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">price</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.price = price;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">color</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Car(</span><br><span class="line">                <span class="keyword">this</span>.name, </span><br><span class="line">                <span class="keyword">this</span>.price, </span><br><span class="line">                <span class="keyword">this</span>.color</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car superMyCar = <span class="keyword">new</span> Car.Builder(<span class="string">&#x27;내 애마&#x27;</span>)</span><br><span class="line">    .price(<span class="number">9999999999</span>)</span><br><span class="line">    .color(Color.INDIGO)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok!"></a>Lombok!</h2><p><a href="https://projectlombok.org/features/Builder">@Builder</a></p>]]></content>
    
    
    <summary type="html">생성자에 매개변수가 많다면 빌더 패턴을 고려하라</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
    <category term="serialize" scheme="https://blog.javarouka.me/tags/serialize/"/>
    
  </entry>
  
  <entry>
    <title>객체 생성 정적 팩토리 메서드를 쓰는게 왜 유리한가 (Effective java 3th - Item1)</title>
    <link href="https://blog.javarouka.me/2018/11/12/static-creator/"/>
    <id>https://blog.javarouka.me/2018/11/12/static-creator/</id>
    <published>2018-11-11T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="생성자-기본지식"><a href="#생성자-기본지식" class="headerlink" title="생성자 기본지식"></a>생성자 기본지식</h2><p>java 에서의 보통의 객체 생성은 new 를 사용한다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>공개된(public) 생성자를 new 연산자와 함께 호출해서 객체를 생성한다.</p><p>이 과정에서 알아둘 생성자에 대한 몇가지 기본적인 지식이 있다</p><ul><li>class 정의 시 생성자를 정의하지 않았다면 기본적으로 인자가 없는 생성자가 언어레벨에서 지원된다.</li><li>Subclassing 된 class 라면 자식 생성자 호출 시 부모의 생성자도 연쇄적으로 호출한다. 생성자 체이닝이라고도 부른다.</li><li>어떤 클래스가 기본 생성자가 아닌 생성자가 정의되었다면 Subclass 도 반드시 생성자를 정의해야 한다. 그리고 그 생성자에는 super로 명시적 체이닝을 해줘야 한다</li></ul><p>생성자 호출은 모듈에는 Spring 등의 <a href="https://en.wikipedia.org/wiki/Dependency_injection#Dependency_injection_frameworks">DI Framework</a> 를 쓰고, 일반 객체는 <a href="https://johngrib.github.io/wiki/builder-pattern/">Builder 패턴</a> 을 사용하게 되면 거의 쓸일이 없어진다.</p><p>하지만 독자 레이어링 시에는 간간히 호출하는 경우가 있기에 알아두면 좋을 것 같다.</p><h2 id="정적-팩토리-메서드"><a href="#정적-팩토리-메서드" class="headerlink" title="정적 팩토리 메서드"></a>정적 팩토리 메서드</h2><p>이 책에서 생성자 대신 정적 팩토리 메서드 생성을 추천하는 이유로 5가지를 들고 있다.</p><h3 id="이름을-가질-수-있다"><a href="#이름을-가질-수-있다" class="headerlink" title="이름을 가질 수 있다"></a>이름을 가질 수 있다</h3><p>객체 생성의 목적은 상황에 따라 다르다. 그리고 그 결과가 어떤 값이 될련지는 생성자 정의에 따라 달라지지만 <code>new XXX</code> 로 호출하는 표현에는 명시적으로 나와있지 않다.</p><p>이름을 가지게 되면 해당 생성의 목적을 이름에 표현할 수 있어 가독성이 증가한다.</p><h3 id="객체-생성-제한이-가능하다"><a href="#객체-생성-제한이-가능하다" class="headerlink" title="객체 생성 제한이 가능하다"></a>객체 생성 제한이 가능하다</h3><p>객체 생성에 제한을 걸거나, 불변 객체를 매번 반환하는 등의 요령을 쓸 수 있다.<br>상황에 따라 신규 생성인지 기존 객체 반환인지도 정할 수 있다.</p><h3 id="SubClass-를-반환할-수-있다"><a href="#SubClass-를-반환할-수-있다" class="headerlink" title="SubClass 를 반환할 수 있다"></a>SubClass 를 반환할 수 있다</h3><p>상속 계층과 타입 상 하위 객체를 반환할 수 있고, 사용자는 그걸 모른채로 사용할 수 있다.</p><p>특정 버전의 class 정적 팩토리 메서드가 하위클래스 A를 반환하다가, 역시 Sub-Classing 된 B 를 반환하더라도 Client 코드에서는 그걸 신경쓰지 않고 작업이 가능하다.</p><p>기본적인 생성자를 사용한다면 구현체 자체가 바뀌었기에 Client 코드의 변경이 불가피해진다.</p><h3 id="입력-매개변수에-따라-다른-타입으로-반환-가능하다"><a href="#입력-매개변수에-따라-다른-타입으로-반환-가능하다" class="headerlink" title="입력 매개변수에 따라 다른 타입으로 반환 가능하다"></a>입력 매개변수에 따라 다른 타입으로 반환 가능하다</h3><p>위 <code>SubClass 를 반환할 수 있다</code> 랑 비슷한 이점이다. 매개변수에 따라 선택적인 Sub-Classing 된 객체를 반환할 수 있다.</p><h3 id="실제-구현체-클래스가-없어도-된다"><a href="#실제-구현체-클래스가-없어도-된다" class="headerlink" title="실제 구현체 클래스가 없어도 된다"></a>실제 구현체 클래스가 없어도 된다</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">newTruck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; truckClz = Class.forName(<span class="string">&quot;me.javarouka.vehicle.Truck&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> truckClz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">newBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; busClz = Class.forName(<span class="string">&quot;me.javarouka.vehicle.Bus&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> busClz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>위 코드처럼 처음 클래스가 로더에 존재하지 않아도 동적으로 현재 코드가 실행되는 클래스 로더에 해당 클래스 (예제에서는 com.vehicle.Truck, com.vehicle.Bus) 들을 로딩한다.</p><p>그리고 그 클래스의 인스턴스를 생성해서 반환할 수 있다.</p><blockquote><p>추가적으로 Class.forName 으로 로딩된 클래스들은 static 구문을 수행한다 . 보통 JDBC 3.x 이하를 써본 사람은 많이 본 코드일 것이다</p></blockquote><h2 id="정적-팩토리-메서드의-단점"><a href="#정적-팩토리-메서드의-단점" class="headerlink" title="정적 팩토리 메서드의 단점"></a>정적 팩토리 메서드의 단점</h2><p>책에서는 2가지를 소개하고 있지만 큰 단점으로 보이지 않는다.</p><ul><li>Sub-Classing 어려움</li><li>문서화</li></ul><p>하지만 둘다 큰 단점으로 보이진 않는다.<br>오히려 이시대의 사회악처럼 되어버린 상속을 방지하는 부가효과(?) 가 있고, 문서화는 코드 표현과 네이밍으로 대체할 수 있기 때문이다.</p><p>주로 쓰는 네이밍들은 다음과 같다.</p><ul><li>from<ul><li>매개변수 하나인 메서드</li></ul></li><li>of<ul><li>매개변수가 N개인 메서드</li></ul></li><li>getInstance<ul><li>인스턴스를 생성한다. 앞서 반환한 객체와 같을 수도 있다.</li></ul></li><li>newInstance<ul><li>인스턴스를 생성한다. 앞서 반환한 객체와는 항상 다르다.</li></ul></li><li>getSomeType<ul><li>인스턴스를 생성하지만 자신의 타입이 아닌 다른 타입 (SomeType) 으로 반환한다. 다른 내용은 <code>getInstance</code> 와 같다</li></ul></li><li>newSomeType<ul><li>인스턴스를 생성하지만 자신의 타입이 아닌 다른 타입 (SomeType) 으로 반환한다. 다른 내용은 <code>newInstance</code> 와 같다</li></ul></li></ul>]]></content>
    
    
    <summary type="html">객체 생성 정적 팩토리 메서드를 쓰는게 왜 유리한가 (Effective java 3th - Item1)</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
    <category term="serialize" scheme="https://blog.javarouka.me/tags/serialize/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3th 정리노트</title>
    <link href="https://blog.javarouka.me/2018/11/10/effective-java/"/>
    <id>https://blog.javarouka.me/2018/11/10/effective-java/</id>
    <published>2018-11-09T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-3th-정리노트"><a href="#Effective-Java-3th-정리노트" class="headerlink" title="Effective Java 3th 정리노트"></a>Effective Java 3th 정리노트</h2><ul><li><a href="/2018/11/12/static-creator">Item 1 객체 생성 정적 팩토리 메서드를 쓰는게 왜 유리한가</a></li><li><a href="/2018/11/14/builder">Item 2 생성자에 매개변수가 많다면 빌더 패턴을 고려하라</a></li><li><a href="/2018/11/19/serialize-java">Item 3 private 생성자나 열거 타입으로 싱글턴임을 보장하라</a></li><li><a href="/2018/11/20/no-instance">Item 4 인스턴스화를 막으려거든 private 생성자를 사용하라</a></li><li><a href="/2018/11/20/dependency-inject">Item 5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</a></li><li><a href="/2018/11/25/%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EC%83%9D%EC%84%B1-%ED%9A%8C%ED%94%BC">Item 6 불필요한 객체 생성을 피하라</a></li><li><a href="/2018/11/26/Finalizer%EC%99%80-Cleaner">Item 8,9 finalizer 와 cleaner 사용을 피하라 &amp; Try-With-Resource</a></li><li><a href="/2018/11/27/object-equals-liskov">Item 10 equals 는 일반 규약을 지켜 재정의하라</a></li><li><a href="/2018/11/28/java%EC%9D%98-HashMap-%EA%B5%AC%ED%98%84%EC%97%90-%EB%8C%80%ED%95%B4">Item 11 equals를 재정의하려거든 hashCode도 재정의하라</a></li><li>…</li></ul>]]></content>
    
    
    <summary type="html">책 읽고 간단히 정리한 흔적들</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/effective/effective.webp" type="image"/>
    
    
    <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>신규 통합 CS 시스템 관리 개발기 # 설계편</title>
    <link href="https://blog.javarouka.me/2018/10/28/new_project_1/"/>
    <id>https://blog.javarouka.me/2018/10/28/new_project_1/</id>
    <published>2018-10-27T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.870Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>신규 통합 CS 시스템 관리 개발기 # 설계편 #</li><li><a href="/2018/11/23/new_project_2/">신규 통합 CS 시스템 관리 개발기 # 혼란편 #</a></li></ul><hr><h2 id="Customer-Service-관리-시스템-개발"><a href="#Customer-Service-관리-시스템-개발" class="headerlink" title="Customer Service 관리 시스템 개발"></a>Customer Service 관리 시스템 개발</h2><p>전자상거래의 CS 관리 시스템이라는 건 생각보다 복잡하다.</p><ul><li>회원정보 조회</li><li>회원 정보 (아이디, 계좌, 주소지 …때로는 탈퇴처리) 변경</li><li>이 회원이 주문한 내역</li><li>이 회원이 최근 주문한 상품</li><li>이 회원의 상담 이력</li><li>상품 판매 업체와 연동</li><li>택배 연동</li><li>메시지, 전화 등의 Channel 연동</li><li>etc …</li></ul><p>사실상 전자상거래의 모든 도메인이 다뤄진다고 볼 수 있다. </p><p>그만큼 의존성이 문어발 식으로 연결되어있고, 그 만큼 타 도메인의 변화에 영향을 많이 받는다.</p><p align="center">    <img src="/asset/new_project/octocat.png" alt="나...?"><em>나 말하나...?</em></p><p>과장하면 타 도메인에서 재채기를 하면 감기에 걸릴수도 있는게 CS 관리 프로그램이다.</p><h2 id="버틸수가-없다"><a href="#버틸수가-없다" class="headerlink" title="버틸수가 없다"></a>버틸수가 없다</h2><p>MSA(<code>M</code>icro <code>S</code>ervice <code>A</code>rchitecture) 환경에서 동시다발적으로 벌어지는 각 도메인들의 변화를 추적하고 반영하다보면, 쉴새없는 오류와, 호환성 문제를 겪게 된다.</p><p>이런 상황을 잘 관리하지 못하면 결과는 끔찍하다.</p><p>쓰레기를 가득 실은 트럭이 도로 제한속도를 넘어 과속하는 것만으로 위험한데, 이 트럭이 사고가 나 전복된다면 쓰레기들이 도로를 가득 메우는 상황이 펼쳐질 것이다.</p><p>아마 CS 개발자 대부분이 어떤 로직에 추가사항을 넣으려고 할때 </p><blockquote><p>이 코드는 누가 만들었지?!</p></blockquote><p>하며 <code>git blame</code> 을 (혹은 annotation) 을 안해본 사람이 없을 것이다.</p><p>(때로는 만든 사람이 자신인 웃기는 경우도 있다…)</p><p>테스트 코드 부재는 예사이고, 팀원들끼리 충분한 커뮤니케이션이 없으면 중복된 코드가 각자의 개성으로 암세포처럼 자라난다.</p><p>그 코드가 관련된 도메인이 변할 경우 이곳저곳에서 자란 해당 코드 모두가 수정되어야 한다.<br>새 기능이 추가될 때 하나라도 이 부분을 누락하면 바로 장애로 이어지거나 유지보수 이슈가 등록된다.</p><p>리팩토링에도 한계가 있다.</p><p>리팩토링 범위를 아무리 최소로 해도 하다보면 너무나 광범위한 영역을 다루게 되며 결국 포기하는 일이 많다. 리팩토링이 때로는 새로운 버그를 만들기도 한다. 이건 이 경우와는 별개로 애초에 잘못된 습관 탓도 있고, 다른 상황에서도 마찬가지인 경우가 많긴 하다.</p><p align="center">    <img src="/asset/new_project/zealot.jpeg" alt="버틸..."><em>버틸수가 없다!</em></p><p>이런 환경속에서 부족한 리소스로 일을 진행하면서 몇차례의 개편을 하다보니 코드의 유지보수성에 많은 생각을 하게 되었다.</p><ul><li>외부 변화에 큰 타격이 없을 것</li><li>도메인 대응이 늦어도 해당 도메인의 기능을 제외하고는 정상 동작해야 할것</li><li>서버와 클라이언트의 분리가 될 것</li><li>새 기능의 추가가 쉬울 것</li><li>프로그램 속도에 문제가 없을 것</li><li>코드가 Readable 할 것</li><li>재미있을 것(?)</li></ul><p>이런 생각이 정리되어 가던 때에 드디어 다시한번 개편을 시도할 기회가 생기게 되었다. 신규 주문정보의 개편이 시작된 것이다. 이번이 나에겐 4번째이다. </p><p>그동안 고민했던 문제들을 쭉 펼쳐보고 기존에서 바꾼 방법을 하나하나 적어보겠다.</p><p>모든 것은 <code>팀원들과의 회의를 통해 결정</code> 했다. 이 과정은 상당히 길고 잦었지만 그 시간은 상당히 유익했던 시간이었다</p><h2 id="새로운-방법"><a href="#새로운-방법" class="headerlink" title="새로운 방법"></a>새로운 방법</h2><h3 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h3><p>기존의 구조는 Spring 의 Controller - Service - Repository or Domain API 의 정석적인(?) 구조였다.</p><p><a href="https://zetawiki.com/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EC%A3%BC%EB%8F%84_%EC%84%A4%EA%B3%84_DDD">DDD</a> 방식으로의 전환도 고려해보았지만, 5년을 넘게 일해도 이해할 수 없는 여러 비즈니스들과 도메인 개념들, 그리고 팀 전체적으로 (나 포함) 낮은 DDD 숙련도 등으로 그냥 전통적인 Controller - Service - Repository or Domain API 로 결정했다.</p><p>약간 아쉽기도 하지만, 시간이라는 제약도 있고 익숙하지 않은 모험을 하기에는 약간 위험했다.</p><p>다만 저 기본적인 흐름에 레이어링을 적용하기로 했다.</p><ul><li><code>Controller</code><ul><li>외부 요청을 처리하는 용도. 일반적인 Controller.</li></ul></li><li><code>Service</code><ul><li>요청에 대한 비즈니스 로직의 묶음. 비즈니스가 변할 경우 서비스만 재작성하면 된다.</li><li>여러 비즈니스 단위 모듈 의존성을 주입받아 처리한다. 하나의 의존성만 있을 수 있고, 여러 비즈니스가 얽힌 의존성이 처리될 수도 있다.</li></ul></li><li><code>Business Logic Behavior</code><ul><li>단일 비즈니스를 처리하기 위한 모듈</li><li>Repository 등에 의존성이 있다.</li></ul></li><li><code>Repository</code><ul><li>팀 오너십 데이터에 대한 CRUD 및 외부 API 에 대한 래퍼.</li><li>Repository 와 Api 를 나누려고 했으나 그냥 하나의 레이어로 래핑하기로 함.</li></ul></li><li><code>Helper</code><ul><li>유틸리티. 무상태이거나 Controller, Service, Behavior, Repository 에는 의존성이 없는 모듈.</li><li>순수 함수들의 집합.</li></ul></li></ul><p>Helper 를 제외한 각 레이어끼리는 의존성을 걸지 않는게 기본이다.</p><p>초창기에는 Collector Layer 도 추가했지만, 나중에 설명할 <code>데이터 토막치기</code> 덕분에 잘 쓰이지 않아 사장되었다. Collector 는 각 데이터를 Aggregation 하는 레이어였다.</p><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>DTO 도 구분했다.</p><p align="center">    <img src="/asset/new_project/dto.jpeg" alt="박스"><em>데이터의 포장에도 각자의 목적이 있다</em></p><p>기본적으로 Request 로 받는 Condition 류를 제외한 모든 DTO 에는 모든 필드가 <code>final</code> 로 불변객체이다.</p><p>불변이 아닐 경우 각 로직이나 레이어를 거치면서 전달되는 객체의 필드가 실제 값이 있는지, 중간에 값이 어떻게 변하는지, 등의 상황에서 한 레이어만 보고서는 추적이 되지 않기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 확장성이 없고 반드시 필요한 순서대로 호출해야만 한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 주문정보를 읽는다</span></span><br><span class="line">DetailOrderDTO order = <span class="keyword">this</span>.readOrderData(orderId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주문에 상품정보를 넣는다</span></span><br><span class="line">order = productModule.appendProductData(order);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주문에 업체정보를 넣는다</span></span><br><span class="line">order = vendorModule.appendVendorData(order);</span><br></pre></td></tr></table></figure><p>이러한 로직이 있을 경우 <code>productModule.appendProductData</code>, <code>vendorModule.appendVendorData</code> 는 주문의 특정 필드의 nullable 여부가 중요해진다. 게다가 상품에 업체정보가 있으므로 앞선 로직에서 상품정보가 정상적이지 않을 경우 다음 업체정보도 얻을 수 없게 된다.</p><p>이 상황에서는 필드의 초기화 여부와 각 모듈의 호출 순서가 매우 중요하다. 이 규칙아래 에서 모듈 의존성 뿐 아니라 로직 의존성까지 발생한다.</p><p>리팩토링을 할 때도 문제가 된다.</p><p>각 모듈 호출 순서를 반드시 지켜야 하며 각 모듈안의 로직을 자세히 살펴보고 완전히 로직을 파악한 뒤에야 리팩토링을 할 수 있다.</p><p>하지만, 모든 필드가 <code>final</code> 일 경우 어떠한 DTO 를 전달받았을 경우 각 필드들이 반드시 초기화가 되었다는 걸 의미하기에 앞선 문제의 대부분이 해소된다. 어디선가 전달받은 객체라도 값의 내용물에 대해 안심하고 쓸 수 있다는 뜻이다. (필드의 Null 여부가 아니라 초기화 여부를 말한다)</p><p>각 레어이간 데이터는 다음과 같은 기준으로 정했다. 네이밍이 약간 이상한것 같지만 그런가보다 하자;</p><ul><li><code>VO</code><ul><li>Repository 등에서 얻는 기본 데이터.</li></ul></li><li><code>Condition</code><ul><li>Client 의 요청 데이터. 불변처리가 힘들기에 일반적인 Setter 가 달려있다.</li></ul></li><li><code>Form</code><ul><li>비즈니스 로직 단위의 요청 폼. 대부분 서비스에서 생성되어 각 비즈니스 처리기에 전달된다.</li></ul></li><li><code>Result</code><ul><li>각 VO 를 수집하여 Client 가 요구하는 데이터로 빌드되는 DTO</li></ul></li></ul><p>예를 들면, MemberFindCondition 으로 요청되면 서비스는 그 요청으로 각 비즈니스에 MemberFindForm, MemberBlockForm, MemberXXXForm 등을 만들어 처리하고 그 결과를 MemberFoundResult 로 응답한다.</p><h3 id="Data-Aggregation"><a href="#Data-Aggregation" class="headerlink" title="Data Aggregation"></a>Data Aggregation</h3><p>다양한 도메인을 한번에 다루는 CS 특성상 여러 도메인의 데이터를 조합하는 경우가 많다.</p><p align="center">    <img src="/asset/new_project/bibim.jpeg" alt="비빔밥" title="비빔밥"><em>재료를 잘 섞어야 맛있다.</em></p><p>어디에도 끼는 회원이나 상품 말고도 CS의 99% 이상의 문의가 주문 관련이니 주문 데이터와 주문에 따라오는 배송 데이터 등은 항상 데이터 조합 대상이다.</p><p>기존 시스템은 클라이언트 요청에 서버는 각 도메인의 데이터를 한번에 합쳐서 보여주는 방식으로 동작했다. 가령 회원이 최근에 주문한 데이터를 봐야 한다면 회원정보, 주문정보, 상품정보, 배송정보, 취소정보를 읽은 뒤 조합했다.</p><p>요청이 하나만 있을 경우에는 이 방법도 나쁘지 않지만, 요청이 다수가 겹칠 경우 문제가 될 수 있다. 요청하는 데이터끼리 중복되는 데이터를 포함할 수 있기 때문이다.</p><p>최근 주문목록을 보여주는 컴포넌트가 있고 주문목록에서 특정 주문을 선택할 경우 다시 해당 주문의 상세를 보여주는 UI가 있다고 가정한다면,<br>매 요청의 응답에는 공통적으로 연관 상품정보, 취소정보, 결제정보, 배송정보가 포함되게 된다.</p><p>불필요한 반복적 요청이 되는 셈이다.</p><p>게다가 비즈니스의 변화로 데이터에 변화가 생길 경우 각 화면별로 더 추가되거나 제거될 수 있어 수정도 동시에 여러 군데에서 일어난다.</p><p>이런 방법보다 데이터의 조합은 연관결합도가 높은 것끼리만 하고, 공통적인 데이터는 분할 요청하는 방식을 선택했다.</p><p>난 이걸 <code>데이터 토막치기</code> 라고 (나 혼자 쓰는 용어이다) 명명했다.</p><h3 id="데이터-토막치기"><a href="#데이터-토막치기" class="headerlink" title="데이터 토막치기"></a>데이터 토막치기</h3><p align="center">    <img width="320" src="/asset/new_project/Dr Salvador.jpg" alt="닥터 살바도르" title="닥터 살바도르"><em>토막쳐보자... 부우우우우웅!!</em></p><p>최근 주문목록에 필요한 데이터를 조합한다고 가정해보자</p><ol><li>회원정보 요청</li><li>회원이 주문한 내역 리스트 데이터를 최근 순으로 요청</li><li>주문내의 정보로 다음 정보 요청<ul><li>주문 내의 상품정보로 상품 정보 요청</li><li>주문 아이디로 결제 정보 요청</li><li>주문 아이디로 취소 정보 요청</li></ul></li><li>상품 정보가 응답되면 그 정보로 다시 업체 정보 요청</li><li>상품 정보로 상품의 각 배송타입, 유형, 카테고리 정보 요청</li></ol><p>각 정보를 조합해서 화면에 표시한다.</p><p>여기서 다시 특정 주문의 상세를 보고 싶다고 한다면 앞서 요청한 상품상세와 각 메타데이터, 업체, 결제, 취소 정보는 요청하지 않아도 된다.<br>필요한 상세 데이터를 추가 요청한뒤 데이터를 조합하면 끝이다.</p><p>그리고 다른 주문번호를 보다가 다시 같은 주문 상세를 조회할 경우, 이미 로딩된 정보를 활용할 수도 있다.<br>어떤 데이터 종류는 갱신이 자주 되는 데이터는 만료 관리가 필요하거나 아예 새로 로딩해야 할 때도 있지만, 대부분의 경우 앞서 설명한 <code>로딩된 데이터끼리의 조합</code> 방식이 훨씬 유리하다.</p><p>이렇게 데이터를 최대한 분할하여 재활용성과 서버 자원 낭비를 줄이고 성능 향상도 고려했다. 모든 데이터를 토막치는게 아닌 비즈니스나 UI 상황, 효율및 결합도에 따라 데이터 구성을 하여 합치는게 유리하다는 것도 잊지 않았다.</p><p>마침 적용하려고 하는 상태관리기 <a href="https://lunit.gitbook.io/redux-in-korean/">Redux</a> 의 selector 개념과 이를 보좌해주는 <a href="https://github.com/reduxjs/reselect">Reselect</a> 는 이런 방식에 찰떡 궁합이었고, 디렉토리 구조도 그에 맞게 가져갔다.</p><h2 id="서버-기반을-수정해보자"><a href="#서버-기반을-수정해보자" class="headerlink" title="서버 기반을 수정해보자"></a>서버 기반을 수정해보자</h2><p>서버 개발에서는 특별한 개선을 하기 어려웠다.</p><p>프로젝트를 온전하게 새로 설정했으면 좋았겠지만, 기존부터 쌓인 코드에 의존성이 상당하고 타 팀의 코드도 섞여 있기에 서버의 완전한 새판 짜기는 불가능했다. 위에 설명했던 레이어링 및 패키지와 설정 파일의 분리 정도가 가능했고, 나머지 모듈 의존성 등은 크게 손댈 수 없었다.</p><p>기회가 된다면 Spring Boot 부터 Mbean 등을 좀 더 잘 써보고 싶은데… 한다면 팀 스탠드얼론이 가능한 프로젝트에나 도입할 수 있을 것 같아 아쉽다.</p><p align="center">    <img width="320" src="/asset/new_project/simu.jpg" alt="ㅠㅠ" title="ㅠㅠ"><em>OTL</em></p><h2 id="클라이언트-기반을-수정해보자"><a href="#클라이언트-기반을-수정해보자" class="headerlink" title="클라이언트 기반을 수정해보자"></a>클라이언트 기반을 수정해보자</h2><p>클라이언트는 이야기가 달라서 완전한 재설정이 가능했다.</p><p>클라이언트쪽은 기존의 나쁜 냄새를 모두 제거하기 위해 바닥부터 새로 시작하기로 했다.</p><ul><li>Global N Sub 방식의 Multi-Store</li><li>클라이언트 사이드 라우팅</li><li>스크립트 용량 축소</li><li>컴포넌트의 재사용성</li><li>사용자 액션 추적</li><li>에러 리포트</li></ul><h3 id="Multi-Store"><a href="#Multi-Store" class="headerlink" title="Multi Store"></a>Multi Store</h3><p>Redux 는 기본적으로 단일 스토어를 추천한다.</p><p>하지만 새로 개편하는 어플리케이션에는 단일 스토어의 이점이 전혀 떠오르지 않았다.</p><p>데이터가 각 회원 혹은 주문 단위로 휘발성이며 상태들의 재사용성이나 히트율이 낮고, 동일한 구조의 회원이나 주문 등의 컨텍스트만 다른 데이터가 대다수이다.</p><p>이 역시 컨텍스트가 바뀌면 버려진다.</p><p>게다가 개편 대상인 어플리케이션은 동적 탭 단위의 구조이다. 같은 탭이 여러개 열릴 수도 있다. 그러면 탭마다 관리되는 상태는 컨텍스트마다 종속 데이터를 관리해야 한다.</p><p>또한 탭이 바뀌거나 하면 화면의 모든 요소를 새 화면의 컨텍스트에 맞게 계산하고, 컴포넌트를 렌더링해야 한다. 탭 하나가 굉장히 많은 데이터를 가질텐데, 단순한 탭의 스위칭만으로 모든 요소가 새로 그려질 것이고 그만큼 화면의 부하는 커진다.</p><p>컨텍스트에 따른 reducer - state 설계도 만만치 않은데다, 성능저하는 단일 스토어에 대해 깊이 생각해보게 되었다.</p><p>결론은 전역 스토어는 하나 두고, 특정 컨텐츠 탭에 대해서는 서브 스토어를 생성하며 스토어를 가진 탭이 닫힐 경우 상태를 정리하는 것보다 그냥 그 스토어를 버리는 구조로 정하게 되었다.</p><p>자식 스토어는 선택적으로 부모 스토어에서 상태를 구독할 수 있고, 액션중 특정 <a href="https://developer.mozilla.org/ko/docs/Glossary/Symbol">Symbol</a> 을 통해 전역 스토어에도 dispatch 를 할 수 있도록 설계했다.</p><h3 id="클라이언트-라우팅"><a href="#클라이언트-라우팅" class="headerlink" title="클라이언트 라우팅"></a>클라이언트 라우팅</h3><p align="center">    <img width="320" src="/asset/new_project/routing.jpeg" alt="표지판" title="표지판"><em>이리저리 가시오</em></p><p>라우팅 기능을 하는 <a href="https://github.com/ReactTraining/react-router">React-Router</a> 라는 훌륭한 라이브러리가 이미 존재하고, 이걸 쓰면 되겠지 라고 생각했다.</p><p>그러나 이리저리 돌려본 결과는 실제 CS 툴에는 그리 어울리지 않다는 결론을 내렸다.</p><p>다음과 같은 이유에서다.</p><ul><li>단일 스토어에 최적화되어 있다.</li><li>라우팅이 바뀔 경우 현재 스토어의 state 에 따라 컴포넌트를 새로 렌더링하는데, 만들려는 어플리케이션은 잦은 라우팅 변경이 있어서 성능 문제가 생긴다</li><li>props 가 아닌 state 의 관리가 어렵다</li></ul><p>결국 React Router 에서 Route 기능만을 빌려와서 직접 라우팅 시스템을 구현할 수밖엔 없었다.</p><p>겸사겸사 React Router 에서 지원하기 좀 애매한 동적 모듈 로딩 라우팅도 적용했다. (개발 당시에는 없었는데 <a href="https://reactjs.org/docs/code-splitting.html##reactlazy">지금 버전에서는 잘 지원</a>하고 있더라…)</p><p>사용한 라이브러리는 <a href="https://github.com/kriasoft/universal-router">Univasal-Router</a> 이다.</p><p>단순하지만 프로젝트에서 필요로 하는 모든 기능이 들어있었다.</p><h3 id="스크립트-용량-축소"><a href="#스크립트-용량-축소" class="headerlink" title="스크립트 용량 축소"></a>스크립트 용량 축소</h3><p>위에 잠깐 언급되었지만 기존 시스템의 스크립트 용량은 무려 5mb 였다.</p><p>어플리케이션에 사용되는 모든 스크립트를 하나의 파일로 만들어서 한번어 로딩하는 방식이었기 떄문이다.</p><p>이 방법으로 인해 성능이 느리거나 네트워크가 불량할 경우 어플리케이션이 상당히 느려졌었고, 브라우저으 javascript 성능이 다소 안좋을 경우 (IE…) 페이지가 한참동안 흰색으로 보이거나 Timeout 에 걸리는 <code>백화 현상</code> 이라는 일이 발생했었다.</p><p>이번에는 필요한 자원이 있을때 로딩하는 동적 로딩을 도입하기로 했다.</p><p>동적 로딩은 간단했다. webpack, babel 조합으로 간단히 import 구문으로 구현할 수 있었고, webpack 의 chunkName 조합으로 디버깅 및 파일 이름 지정도 가능했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 동적 컴포넌트 예시</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadComponent = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;component/DynamicComponent&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">        DynamicComponent: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        loadComponent().then(<span class="function"><span class="params">DynamicComponent</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                DynamicComponent</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; DynamicComponent &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">        <span class="keyword">if</span>(!DynamicComponent) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;DynamicComponent /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>적용 후 첫 로딩 스크립트의 용량이 300kb 도 안될 정도로 좋아진 걸 보고 꽤나 좋았던 기억이 난다.</p><h3 id="컴포넌트-재사용성"><a href="#컴포넌트-재사용성" class="headerlink" title="컴포넌트 재사용성"></a>컴포넌트 재사용성</h3><p>이 문제는 참 어렵다.</p><p>재사용성을 아무리 고려해도 실제 이리저리 재활용을 하려고 하면 각자의 조금씩 다른 요구사항과 스타일 등에 버려지는 케이스가 많기 때문이다. 재활용성이 높은 컴포넌트는 무엇보다 이런 고민이 잘 커버되는 설계가 상당히 중요하다.</p><p>설계 능력이 그리 좋지 못한 덕분에 나는 아직도 재활용성이 높은 컴포넌트가 뭔지 헤메이고 있다.</p><p>그래도 노력이 나를 조금이나마 동정했는지, 몇몇 컴포넌트는 재사용성을 확보할 수 있었다. 디자인 요소를 배제할수록, 도메인 이해도가 높을 수록 재사용성이 높았던 것 같다.</p><ul><li>PureComponent 를 최대한 다수를 생성하려고 했다. 재활용의 시작이 되니까. React 16.6 에서는 <a href="https://reactjs.org/docs/react-api.html#reactmemo">React.memo</a> 라는 것도 지원해서 PureComponent 사용이 더 좋아졌다.</li><li>재활용 요소는 가급적 <a href="https://reactjs.org/docs/fragments.html">React.Fragment</a> 로 래핑한다. 이 요소가 어느 레이아웃으로 재활용될지 모르기 때문이다.</li><li>스타일 요소는 하나하나를 스타일링하지 말고 Styled-Component 로 대체할 수 있게 디자인한다.</li></ul><!-- - 각 팝업 버튼 재사용 (버튼을 컨테이너화해서 property 만으로 액션과 부수효과를 처리했다)- 로직 UI 재사용 (전체취소, 확인요청 등의 비즈니스 덩어리를 정해진 프로퍼티만으로 표현할 수 있었다)--><h3 id="사용자-액션-추적-에러-리포트"><a href="#사용자-액션-추적-에러-리포트" class="headerlink" title="사용자 액션 추적 / 에러 리포트"></a>사용자 액션 추적 / 에러 리포트</h3><p>이 문제는 사실 Redux의 middleware 만 잘 활용하면 달성이 쉽다.</p><p>다만, 액션으로 잡히지 않는 것까지 모두 처리하려면 직접적인 상태 변화가 없는 (다시 말하면 reducer 에서 처리하지 않는) 액션까지 디테일하게 설계해야 한다.</p><p>이런 건 보통 사이드이펙트 뿐인 작업을 수행할 때 발생하는데, 이런 것에 잘 어울리는 방식을 찾다가 Redux-Saga 를 도입하기로 했다.</p><p><a href="https://github.com/redux-saga/redux-saga">Redux-Saga</a> 는 Redux 플로우에서 사이드이펙트를 관리하기 위한 미들웨어이다.</p><p>Redux Saga 로 사용자의 모든 행동은 Saga 를 통해 로깅되며 사이드이펙트로 서버에 리포트되도록 했다.</p><p>이런 액션 로깅은 <a href="https://www.elastic.co/kr/products/elasticsearch">Elastic Search</a> 등으로 쌓아서 통계나 어플리케이션 사용 행태를 분석하는 용도로 쓰려고 준비중이다.</p><p>사용자의 흐름이나 행동 및 발생하는 에러를 분석하면 버그나 기능 개선, 사용율 체크에 큰 도움이 되지 않을까 한다. 에러 시에는 현재 상태의 스냅샷을 전송한다면 재현도 어렵지 않게 할 수 있기에 처리가 좀 더 쉬울것이라 예상한다.</p><p>서비스를 해봐야 알겠지만…</p><h3 id="클라이언트-단독-개발이-가능하도록"><a href="#클라이언트-단독-개발이-가능하도록" class="headerlink" title="클라이언트 단독 개발이 가능하도록"></a>클라이언트 단독 개발이 가능하도록</h3><p align="center">    <img width="320" src="/asset/new_project/front-back.jpg" alt="프론트 엔드 백엔드" title="Front Castle on Back"><em>프론트 엔드 성 아래의 백 엔드 심해</em></p><p>요청사항에 따라 클라이언트 개발만 진행하거나 소소한 수정건이 있을 수 있다. 이런 경우 예전의 구조에서는 클라이언트 수정이라도 로컬 서버를 먼저 실행시키고 로컬 서버를 구동하여 개발을 진행했다.</p><p>이 방법이 나쁜건 아니나 어차피 현재 구조에서는 페이지 라우팅을 클라이언트에서 하는데다가, 인증과 데이터 말고는 서버가 화면에 하는 일이 없기때문에 굳이 클라이언트 수정할때 무거운 local WAS 를 실행시킬 필요가 없다고 생각했다.</p><p>이 구조에서는 데이터만 제공된다면 클라이언트 개발에는 무리가 없다.</p><p>가상 데이터를 제공할 수 있는 mock 서버를 시작하고 가상 데이터를 내려주는 로컬 서버를 시작하고 webpack-dev-server 를 mock 서버에 연결하는 작업으로 로컬서버만으로 개발이 가능하게 되었다.</p><p>mock 서버는 <a href="https://github.com/smollweide/node-mock-server">node-mock-server</a> 을 사용했다.</p><p>문서가 다소 부족해서 사용법 사용에 애를 먹었지만, 파일 기반으로 GET, POST, PUT, DELETE 등 지원에 커스텀 파라미터에 따른 커스텀 데이터 생성기능까지 쓸만한 기능은 다 있어서 단순한 기능 사용에는 문제가 없었다.</p><p>webpack-dev-server 와 mock 연동에는 <a href="https://www.npmjs.com/package/express-http-proxy">express-http-proxy</a> 를 사용했다.</p><p>이 방법으로 mock 연계를 하고나니 좀 더 나아가서 실제 서버로 화면 개발을 진행할 수 있을것 같았다.</p><p>추가 개발은 proxy 에 https 지원을 추가하고 npm 스크립트를 몇개 수정한 것 뿐으로 훌륭한 실서버 &lt;==&gt; webpack-dev-server 의 연계가 만들어졌다.</p><p>이 작업으로 클라이언트 개발 매우 편해져서 작업 효율이 크게 증가했다.</p><h2 id="아직이다"><a href="#아직이다" class="headerlink" title="아직이다"></a>아직이다</h2><p>지금까지 개선과 설계 방향을 쭉 나열한 것 같다.</p><p><a href="/2018/11/23/new_project_2/">다음 글</a> 에는 이러한 개념을 적용하며 겪은 문제점과 아쉬운 부분을 나열해보겠다.</p>]]></content>
    
    
    <summary type="html">일단 지른다</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/java-logo.png" type="image"/>
    
    
    <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
    <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
    <category term="javascript" scheme="https://blog.javarouka.me/tags/javascript/"/>
    
    <category term="scaffolding" scheme="https://blog.javarouka.me/tags/scaffolding/"/>
    
    <category term="legacy" scheme="https://blog.javarouka.me/tags/legacy/"/>
    
    <category term="new-cs-system" scheme="https://blog.javarouka.me/tags/new-cs-system/"/>
    
  </entry>
  
  <entry>
    <title>Inline styles</title>
    <link href="https://blog.javarouka.me/2018/01/01/inline-styles/"/>
    <id>https://blog.javarouka.me/2018/01/01/inline-styles/</id>
    <published>2017-12-31T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="인라인-스타일에-대한-생각"><a href="#인라인-스타일에-대한-생각" class="headerlink" title="인라인 스타일에 대한 생각"></a>인라인 스타일에 대한 생각</h2><ul><li>스타일이 각각의 엘레먼트에 있음으로 인해 HTML 문서의 용량이 증가. 이는 과한 트래픽으로 이어진다. CSS 의 경우엔 첫 로딩 이후에는 일반적으로 캐시되며 트래픽 감소 효과가 있다.</li><li>공통적 스타일을 변경할 경우 해당하는 모든 스타일을 수정해야 한다.</li><li>요소에 붙은 스타일을 보고 어떤 스타일인지 추론하는 것이 불가능하다. 예를 들어 highlight-box 라는 클래스네임이 있다면 강조 성격의 UI 블럭요소라고 추론해볼 수 있지만 인라인일 경우 직접 스타일 코드를 읽어야 한다.</li><li>Left-To-Right, Right-To-Left 등의 언어 방식의 경우 대응이 힘들어진다.</li></ul>]]></content>
    
    
    <summary type="html">Inline styles</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/css.png" type="image"/>
    
    
    <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
    <category term="css" scheme="https://blog.javarouka.me/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Lerna</title>
    <link href="https://blog.javarouka.me/2018/01/01/lerna/"/>
    <id>https://blog.javarouka.me/2018/01/01/lerna/</id>
    <published>2017-12-31T15:00:00.000Z</published>
    <updated>2020-09-22T04:18:02.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><h3 id="Official-Site"><a href="#Official-Site" class="headerlink" title="Official Site"></a>Official Site</h3><p><a href="https://lernajs.io/">https://lernajs.io/</a></p><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><ul><li><a href="https://gist.github.com/nolanlawson/457cdb309c9ec5b39f0d420266a9faa4">Why we dropped Lerna from PouchDB</a></li><li><a href="https://hackernoon.com/the-highs-and-lows-of-using-lerna-to-manage-your-javascript-projects-ff5c5cd82a99">The highs and lows of using Lerna to manage your JavaScript projects </a></li><li><a href="https://medium.com/trabe/monorepo-setup-with-lerna-and-yarn-workspaces-5d747d7c0e91">Monorepo setup with Lerna and Yarn workspaces</a></li><li><a href="https://medium.com/@deptno/monorepo-yarn-workspace-e81e3e078100">Monorepo? Yarn Workspace!</a></li><li><a href="https://medium.com/@patrickleet/mono-repo-or-multi-repo-why-choose-one-when-you-can-have-both-e9c77bd0c668">Mono-repo or multi-repo? Why choose one, when you can have both?</a></li></ul><h3 id="What-Lerna"><a href="#What-Lerna" class="headerlink" title="What Lerna?"></a>What Lerna?</h3><p>Lerna 는 여러 패키지로 구성된 대규모 npm 프로젝트를 관리하기 위한 도구이다.<br>세분화된 구성 요소로 구성된 대구모 프로젝트의 경우 각 서브 프로젝트들의 의존성을 서로 관리하다보면 각 프로젝트별 업데이트 관리가 꽤나 힘들어진다.<br>이럴 경우 lerna 를 사용하여 대규모 프로젝트 관리에 큰 도움을 받을 수 있다.</p>]]></content>
    
    
    <summary type="html">Lerna 는 여러 패키지로 구성된 대규모 npm 프로젝트를 관리하기 위한 도구이다.</summary>
    
    
    <content src="https://blog.javarouka.me/asset/images/js.jpg" type="image"/>
    
    
    <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
    <category term="npm" scheme="https://blog.javarouka.me/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>운영되던 서비스, ES5 에서 ES6 으로 옮긴 이야기 2 (feat Webpack)</title>
    <link href="https://blog.javarouka.me/2017/05/14/convert-legacy-to-webpack-bundle-2/"/>
    <id>https://blog.javarouka.me/2017/05/14/convert-legacy-to-webpack-bundle-2/</id>
    <published>2017-05-14T14:30:17.000Z</published>
    <updated>2020-09-22T04:18:02.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2016년 5월부터 2016년 6월까지 진행된 나의 to ES6 삽질을 기록해본다. 100% Real 은 아니고… 95% 정도?</p></blockquote><p><a href="/2017/05/03/convert-legacy-to-webpack-bundle-1/">전 글</a></p><h2 id="버틸수가-없다"><a href="#버틸수가-없다" class="headerlink" title="버틸수가 없다"></a>버틸수가 없다</h2><p>전 포스트의 막바지에 썼듯이 실무는 실전이었다.</p><p>다음과 같은 문제를 부딪히며 하나하나 해결해 나갈 수 밖에 없었다.</p><h3 id="컨트롤러-매핑-문제"><a href="#컨트롤러-매핑-문제" class="headerlink" title="컨트롤러 매핑 문제"></a>컨트롤러 매핑 문제</h3><p>requirejs 를 쓰면서 AMD 식으로 필요할 때 스크립트를 로딩했는데, 이 부분부터 고쳐야 했다</p><p>Controller 의 이름이 만일 <code>order/MemberController</code> 라면 다음과 같은 방법으로 컨트롤러를 로딩한다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const controllerPath = &#x27;order/MemberController&#x27;;</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">`controller/<span class="subst">$&#123;controllerPath&#125;</span>`</span>], <span class="function"><span class="params">ControllerClass</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> controlelr = <span class="keyword">new</span> ControllerClass(contentElement, controllerPath)</span><br><span class="line">    controlelr.execute();</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 방법은 필요할 때 비동기로 네트워크 상에서 스크립트를 로딩하고, 완료 시 콜백 함수의 인자를 통해 모듈을 사용한다</p><p>일단은 기본적으로 모든 모듈이 바로 접근 가능해야 하는 ES6의 모듈은 이런것을 허용하지 않았다.</p><p>결국 아래와 같은 controllerMap 을 만들었다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file controllerFactory.js</span></span><br><span class="line"><span class="keyword">import</span> EmptyController <span class="keyword">from</span> <span class="string">&#x27;./EmptyController&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MainController <span class="keyword">from</span> <span class="string">&#x27;./OrderController&#x27;</span></span><br><span class="line"><span class="keyword">import</span> OrderController <span class="keyword">from</span> <span class="string">&#x27;./order/OrderController&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MemberController <span class="keyword">from</span> <span class="string">&#x27;./member/MemberController&#x27;</span></span><br><span class="line"><span class="keyword">import</span> MemberBlockController <span class="keyword">from</span> <span class="string">&#x27;./member/MemberBlockController&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... Controller import Statement 다수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controllerMap = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;MainController&#x27;</span>: MainController,</span><br><span class="line">    <span class="string">&#x27;order/OrderController&#x27;</span>: OrderController,</span><br><span class="line">    <span class="string">&#x27;member/MemberController&#x27;</span>: MemberController,</span><br><span class="line">    <span class="string">&#x27;member/MemberBlockController&#x27;</span>: MemberBlockController,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이름으로 매핑해둔 컨트롤러를 반환한다.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">conrollerPath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> controllerMap[conrollerPath] || <span class="keyword">new</span> EmptyController();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식으로 미리 Controller 모듈을 로딩해두고 맵으로 관리되게 한 다음, 반환하는 Factory 모듈을 만들어서 처리했다.</p><p>동적 로딩을 완전히 포기하고 초기에 모든 스크립트를 로딩하게 한 선택이다.</p><p>물론 초기 스크립트 로딩 용량이 굉장히 커지고 컨텐트와 컨트롤러가 추가될수록 증가하지만, 별 방법이 없다고 생각했다.</p><p><a href="https://webpack.github.io/docs/code-splitting.html">require.ensure</a> 를 사용하여 동적 로딩을 선택할 수도 있었지만 동적 로딩도 동적 문자열로 모듈을 로딩하는건 불가능하기에, 각 컨트롤러의 매핑마다 동적 로딩 코드를 적어주어야 했다.</p><p>다음과 같이 말이다. 별로 마음에 들지 않았다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file asyncControllerFactory.js</span></span><br><span class="line"><span class="keyword">import</span> EmptyController <span class="keyword">from</span> <span class="string">&#x27;./EmptyController&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controllerMap = &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="string">&#x27;MainController&#x27;</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> resolve(<span class="built_in">require</span>(<span class="string">&#x27;./MainController&#x27;</span>)))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="string">&#x27;order/OrderController&#x27;</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">require</span>.ensure([], <span class="function">() =&gt;</span> resolve(<span class="built_in">require</span>(<span class="string">&#x27;./order/OrderController&#x27;</span>)))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">conrollerPath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> factory = controllerMap[conrollerPath];</span><br><span class="line">    <span class="keyword">return</span> factory ? </span><br><span class="line">        factory().then(<span class="function"><span class="params">Controller</span> =&gt;</span> <span class="keyword">new</span> Controller().execute())</span><br><span class="line">        :</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> EmptyController().execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>저 <code>ensure</code> 구문은 반드시 저렇게 패스와 같이 적어줘야지 별도로 분리하게 되면 webpack 번들링 후 실제 로딩이 잘 동작하지 않았다.</p><p>컨트롤러 수가 작업 당시에는 그렇게 많지 않았고 동적 로딩 시 종종 Timeout 등의 네트워크 오류도 났기에 그냥 전체를 한번에 번들링해버리는 선택을 했다.<br>(그리고 나중에 엄청 후회했다…)</p><h4 id="Webpack2-에서의-Async-Module-Loading"><a href="#Webpack2-에서의-Async-Module-Loading" class="headerlink" title="Webpack2 에서의 Async Module Loading"></a>Webpack2 에서의 Async Module Loading</h4><p>Webpack 2 에서는 <code>import</code> 와 <code>async/await</code> 를 사용해서 동적 로딩을 할 수 있다.<br>이런식의 코딩이 가능. 표준을 준수한다는 것 외엔 특별한 외형 차이는 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES7 의 async 와 await 를 사용한다</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadOrderCancelController</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Controller = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./OrderCancelController&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> Controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadOrderCancelController()</span><br><span class="line">    .then(<span class="function"><span class="params">Controller</span> =&gt;</span> <span class="keyword">new</span> Controller().execute());</span><br></pre></td></tr></table></figure></div><p>이제 각 컨트롤러를 매핑해주고 컨텐츠 로더가 그것을 잘 사용할 수 있게 수정하는 노가다만 남은듯 했다.</p><p>하지만 현실은 …</p><h3 id="ES6-모듈과-commonjs-amd-모듈은-달랐다"><a href="#ES6-모듈과-commonjs-amd-모듈은-달랐다" class="headerlink" title="ES6 모듈과 commonjs, amd 모듈은 달랐다."></a>ES6 모듈과 commonjs, amd 모듈은 달랐다.</h3><p>Webpack 은 분명 AMD 와 commonjs 모듈도 사용할 수 있다. 실제로도 그렇다.<br>하지만, 이 두 스펙의 모듈 정의를 ES6 모듈과 함께 사용할때는 큰 문제가 발생했다.</p><p>ES6 모듈 정의에는 <code>default export, named export</code> 라는 AMD, commonjs 에 없는 개념이 있었기 때문이다.</p><p><img src="/asset/howthefuck.jpg" alt="뭐냐..."></p><p>다음에 세가지 스타일로 모듈을 정의해보았다.<br>이 모듈의 이름은 <code>rouka/blog/module</code> 이라고 해보자</p><p>먼저, AMD 모듈은 다음과 같은 형식이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">define([ <span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;moment&#x27;</span> ], <span class="function"><span class="keyword">function</span> <span class="title">factory</span>(<span class="params">$, moment</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> YMD_FORMAT_STR = <span class="string">&#x27;YYYYMMDD&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getEl(selector, context) &#123;</span><br><span class="line">            <span class="keyword">return</span> $(selector, context || <span class="built_in">document</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        todayString() &#123;</span><br><span class="line">           <span class="keyword">return</span> moment().format(YMD_FORMAT_STR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>commonjs 의 모듈은 다음과 같은 형식이다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YMD_FORMAT_STR = <span class="string">&#x27;YYYYMMDD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.getEl = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(selector, context || <span class="built_in">document</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.todayString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moment().format(YMD_FORMAT_STR);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 모듈은 다음과 같은 형식이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>; </span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YMD_FORMAT_STR = <span class="string">&#x27;YYYYMMDD&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEl</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(selector, context || <span class="built_in">document</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">todayString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moment().format(YMD_FORMAT_STR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기까지는 세개 다 비슷해 보인다. 모듈을 로딩할때 쓰는 statement 나 문법만 다른 정도.<br>하지만 위의 정의 모듈을 사용할때 달라진다.</p><p>먼저 AMD 와 commonjs 는 기본적으로 형태만 다를 뿐 기본적인 사용은 같다.</p><p>모듈을 로딩하고, 해당 모듈을 객체를 얻으면 그 모듈을 사용할 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;rouka/blog/module&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">blogModule</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(blogModule.todayString()); <span class="comment">// 오늘 날자...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// commonjs</span></span><br><span class="line"><span class="keyword">const</span> blogModule = <span class="built_in">require</span>(<span class="string">&#x27;rouka/blog/module&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(blogModule.todayString()); <span class="comment">// 오늘 날자...</span></span><br></pre></td></tr></table></figure><p>하지만 이 모듈을 ES6 에서 사용하려면 좀 다르다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="comment">// 이 부분이 다르다!</span></span><br><span class="line"><span class="keyword">import</span> &#123; todayString &#125; <span class="keyword">from</span> <span class="string">&#x27;rouka/blog/module&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(todayString()); <span class="comment">// 오늘 날자...</span></span><br></pre></td></tr></table></figure><p>import 시에 실제 사용할 기능 프로퍼티 이름을 적어주고 있다.<br>만일 그냥 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">import</span> blogModule <span class="keyword">from</span> <span class="string">&#x27;rouka/blog/module&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(blogModule.todayString()); <span class="comment">// throw TypeError</span></span><br></pre></td></tr></table></figure><p>이런식으로 사용할 경우 오류를 낸다.</p><p>위의 문법은 <code>rouka/blog/module</code> 에서 default 모듈을 사용하겠다는 뜻이다.<br>ES6 모듈에는 <code>default export</code> 라는게 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>; </span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEl</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(selector, context || <span class="built_in">document</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">todayString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moment().format(YMD_FORMAT_STR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default export</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">setTodayOnEl</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    getEl(selector, context).html(todayString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>default export 로 해당 엘리먼트에 오늘 날자를 HTML 로 넣어주는 함수를 정의했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default 모듈 사용</span></span><br><span class="line"><span class="keyword">import</span> setTodayOnEl <span class="keyword">from</span> <span class="string">&#x27;rouka/blog/module&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(setTodayOnEl(<span class="string">&#x27;body&#x27;</span>)); <span class="comment">// 오늘 날자...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ........................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 명시적으로 사용</span></span><br><span class="line"><span class="keyword">import</span> &#123; setTodayOnEl &#125; <span class="keyword">from</span> <span class="string">&#x27;rouka/blog/module&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(setTodayOnEl(<span class="string">&#x27;body&#x27;</span>)); <span class="comment">// 오늘 날자...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ........................</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 혼용해서 사용. 앞이 default</span></span><br><span class="line"><span class="keyword">import</span> setTodayOnEl, &#123; todayString &#125; <span class="keyword">from</span> <span class="string">&#x27;rouka/blog/module&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(setTodayOnEl(<span class="string">&#x27;body&#x27;</span>)); <span class="comment">// 오늘 날자...</span></span><br></pre></td></tr></table></figure><p>실제 Babel 은 ES6 모듈과 이외 모듈을 다른 방식으로 컴파일하는데, ES6 의 모듈일 경우에는 <code>__esModule</code> 이라는 마크를 해 두고 import 구문을 만날 경우 다른 방식으로 import 를 수행한다.</p><p>Controller 모듈을 기본적으로 ES6 으로 변경하고 있었는데 이 경우 Controller 를 commonjs 나 amd 모듈이 import 할 경우</p><p>추가적으로 default 프로퍼티로 접근해야 했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./es6.style.module&#x27; 모듈은</span></span><br><span class="line"><span class="comment">// named export 와 default export 가 섞여있다.</span></span><br><span class="line"><span class="keyword">var</span> es6Module = <span class="built_in">require</span>(<span class="string">&#x27;./es6.style.module&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 반환된 모듈 안은</span></span><br><span class="line"><span class="comment">// &#123; default: doSome, otherSome &#125; 같은 형식이다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 물론 doSome 사용에는 default 프로퍼티가 필요하다.</span></span><br><span class="line">es6Module.default.doSome();</span><br><span class="line"></span><br><span class="line"><span class="comment">// named export 모듈은 그냥 사용한다</span></span><br><span class="line">es6Module.otherSome();</span><br></pre></td></tr></table></figure><p>실제 프로젝트에 적용 시 세가지 스타일의 모듈 정의가 뒤섞여 작업되고 있었고,</p><p>각 모듈마다 모듈 사용에 있어 각기 다른 방법으로 사용해야 하는 지경에 이르르니, 거의 수라계에 온 듯한 느낌을 받게 했다.</p><p>webpack 에서 뱉어내는 빨간색 천지의 오류 메시지와 함께 내 마음도 붉게 물들기 시작했다</p><p><img src="/asset/doc-heatal.jpg" alt="아...그냥 그만두고 여길 나갈까"></p><div style="padding: 0 5px; background-color: #ECECEC; border-top: solid 1px #333; font-size: 80%;">위의 ES6 및 commonjs 모듈의 다른 점을 알고 싶다면 엑셀박사님의 블로그를 한번 읽어보자.<br/><a href="http://2ality.com/2015/12/babel-commonjs.html" target="_blank">[Babel and CommonJS modules]</a></div><h3 id="결국-개발된-모든-파일을-ES6-으로-변환"><a href="#결국-개발된-모든-파일을-ES6-으로-변환" class="headerlink" title="결국, 개발된 모든 파일을 ES6 으로 변환~!"></a>결국, 개발된 모든 파일을 ES6 으로 변환~!</h3><p>여러 꼼수를 써보다가, 결국 선택한건 모든 파일에 대해 ES6 스타일로 코드를 변환하는 것으로 선택했다.</p><p>프로젝트 내에서 한가지 스타일로 코딩이 되어 있어야 하는건 당연한 것이고, 기왕이면 표준 스펙으로 선택하는 것이 유리했으며,</p><p>ES6 모듈을 적용하면 Dead Code Elimination(Tree Shaking) 이라는 최적화 전략까지 쓸 수 있기 때문이었다.</p><p><a href="https://github.com/rollup/rollup#tree-shaking">Tree Shaking</a></p><p>Tree Shaking 은 요약하면 모듈 import 최적화로 실제 컴파일 시 모듈 import 에서 사용하는 코드만 컴파일 결과에 포함시키는 것이다.</p><p>당연히 용량이 작아지고 연산이 줄어든다.</p><p>암튼 나는 당시 900 개가 넘는(…) js 코드들을 하나하나 열어서 ES6 스타일의 모듈 코드로 변환하기 시작했다.</p><p>정말 즐거운 일이었다.</p><h2 id="개발서버와-번들서버"><a href="#개발서버와-번들서버" class="headerlink" title="개발서버와 번들서버"></a>개발서버와 번들서버</h2><p>스크립트를 동적으로 컴파일한다는건 파일이 작을땐 별 문제가 되지 않는다.</p><p>하지만 프로젝트의 규모가 나름 컸으므로 생성된 파일은 상당히 많았고, 이 파일을 실제 컴파일하여 실제 파일을 만들어내는 데에는 2~3 분의 시간이 걸렸다.</p><p>뭐 배포 전 한번이라면 괜찮다.</p><p>하지만 이 것이 watch 등으로 코드 수정시마다 일어난다고 할 경우에는 문제가 심각해진다.</p><p>webapack 은 <code>webpack dev server</code> 를 제공했고, 이것을 사용할 경우 파일을 실제 Disk 에 생성하는게 아닌 메모리에 생성하고 그것만을 갱신하기에 속도가 상당히 빠르다.</p><p>설정은 예제 사이트들이 아주 잘 되어있어서 그것을 가져다가 쓰면 되었다.</p><p>여기에 express 를 사용해서 Data Server 를 Proxy 로 감싸서 쓰게 되면 로컬에 별도의 java 를 구동하지 않고도 사용할 수 있어서 클라이언트 개발에는 순수하게 webpack-dev-server 만으로도 충분하도록 설정했다.<br>(뭐 결국 서버까지 손대는 일이 부지기수지만…갑작스러운 오류 등으로 클라이언트에 대해 디버깅하기에는 엄청나게 유용했다.)</p><p><a href="https://www.npmjs.com/package/express-http-proxy">express-http-proxy</a> 를 사용해서 정적 리소스 외에는 프록시로 이미 구동중인 서버로 요청을 하게 했다.</p><p>프록시-번들서버 코드는 매우 간단하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> proxy <span class="keyword">from</span> <span class="string">&#x27;express-http-proxy&#x27;</span> <span class="comment">// 이놈이 효자</span></span><br><span class="line"><span class="keyword">import</span> Express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">startProxyServer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> delegateServer = <span class="keyword">new</span> Express();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 프록시 서버 정보</span></span><br><span class="line">    <span class="keyword">const</span> proxyServer = <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> proxyPort = <span class="number">11980</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 번들서버 정보</span></span><br><span class="line">    <span class="keyword">const</span> bundleServerHost = <span class="string">&#x27;localhost:11980&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// API 서버 정보</span></span><br><span class="line">    <span class="keyword">const</span> targetServer = <span class="string">&#x27;myproject.companydev.com&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 번들서버 요청</span></span><br><span class="line">    delegateServer.use(<span class="string">&#x27;/resources/*/bundles/:name&#x27;</span>, proxy(bundleServerHost, &#123;</span><br><span class="line">        forwardPath(req) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;/bundles/&#x27;</span> + req.params.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 이 외의 요청은 Proxy 를 통해 설정된 서버로.</span></span><br><span class="line">    delegateServer.use(<span class="string">&#x27;/&#x27;</span>, proxy(targetServer));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 시작~</span></span><br><span class="line">    delegateServer.listen(proxyPort, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(err);</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.info(<span class="string">&#x27;Webpack development proxy server progress... %s&#x27;</span>, <span class="string">`http://<span class="subst">$&#123;proxyServer&#125;</span>:<span class="subst">$&#123;proxyPort&#125;</span> to <span class="subst">$&#123;targetServer&#125;</span>`</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>webpack-dev-server</code> 를 구동할때 프록시 개발서버까지 같이 돌려주면 완벽.</p><p>이제 남은건 실제 배포 환경이었다.</p><h2 id="실제-배포환경"><a href="#실제-배포환경" class="headerlink" title="실제 배포환경"></a>실제 배포환경</h2><p>실제 운영 환경에서는 번들서버같은걸 띄울수도 없고 띄워서도 안된다.</p><p>운영시에는 메모리에 존재하는 스크립트가 아니라 실제 파일을 만들어야 해서 별도로 webpack 설정을 production 용으로 하나 만들고 이 설정에서는 별다른 번들서버나 프록시, 기타 개발 서포트 플러그인을 제외하고 구성했다.</p><p>개발에는 없던 <a href="https://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin">UglifyPlugin</a> 옵션을 추가해서 소스를 압축했다.</p><p>사내에서는 빌드에 <code>gradle</code> 을 사용하고 있었기에 다음과 같은 구문을 넣어서 <code>gradle</code> 의 <code>war task</code> 수행 전 <code>npm</code> 을 사용해서 소스를 컴파일하고 파일을 지정된 위치에 생성되게 했다.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">&#x27;war&#x27;</span></span><br><span class="line"></span><br><span class="line">task packageClient (<span class="attr">type :</span> Exec) &#123;</span><br><span class="line">executable <span class="string">&quot;$&#123;project.projectDir&#125;/packageClient.sh&quot;</span> <span class="comment">// npm 빌드 스크립트</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 여기~</span></span><br><span class="line">war.dependsOn packageClient</span><br></pre></td></tr></table></figure><h2 id="끝났나"><a href="#끝났나" class="headerlink" title="끝났나"></a>끝났나</h2><p>검색 -  삽질 - 노가다 - 삽질 - 검색의 무한루프를 돌며 변환이 끝났다. </p><p>이 작업은 기존의 잘 돌아가던 시스템을 다시 엎은거라서, 잘 되어야 본전인 일이라 사실 티는 그다지 나지 않았다.<br>중간에 몇가지의 문제로 압박받은것만 많았고…</p><p>게다가 모든 코드를 한번에 로딩하는 방법을 선택해서, 스크립트 용량이 상당히 거대해져버린 문제는 과제로 남았다.</p><p>최근 webpack 2가 나오면서 webpack 1 이 deprecated 되었다. 다시 설정을 만질 때가 온 듯 하니 같이 작업하면 될 듯 하다.</p>]]></content>
    
    
    <summary type="html">개고생과 노가다, 그리고 고독</summary>
    
    
    <content src="https://blog.javarouka.me/asset/E.N.D.jpg" type="image"/>
    
    
    <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
    <category term="javascript" scheme="https://blog.javarouka.me/tags/javascript/"/>
    
    <category term="Handlebars" scheme="https://blog.javarouka.me/tags/handlebars/"/>
    
    <category term="webpack" scheme="https://blog.javarouka.me/tags/webpack/"/>
    
    <category term="개고생" scheme="https://blog.javarouka.me/tags/%EA%B0%9C%EA%B3%A0%EC%83%9D/"/>
    
  </entry>
  
  <entry>
    <title>운영되던 서비스, ES5 에서 ES6 으로 옮긴 이야기 1</title>
    <link href="https://blog.javarouka.me/2017/05/03/convert-legacy-to-webpack-bundle-1/"/>
    <id>https://blog.javarouka.me/2017/05/03/convert-legacy-to-webpack-bundle-1/</id>
    <published>2017-05-03T14:30:17.000Z</published>
    <updated>2020-09-22T04:18:02.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2016년 5월부터 2016년 6월까지 진행된 나의 to ES6 삽질을 기록해본다. 100% Real 은 아니고… 95% 정도?</p></blockquote><h2 id="프로젝트의-안정화-마무리-즈음의-위험한-만남"><a href="#프로젝트의-안정화-마무리-즈음의-위험한-만남" class="headerlink" title="프로젝트의 안정화 마무리 즈음의 위험한 만남"></a>프로젝트의 안정화 마무리 즈음의 위험한 만남</h2><p>회사에 입사한 뒤로 내가 주로 한 일은 통으로 되어있던 프로젝트에서 내가 소속된 팀의 기능만 빼서 별도의 프로젝트로 분리하는 일이었다.</p><p><a href="http://microservices.io/">MSA</a> 로의 이전을 위해 한창 전사가 달리던 때다.</p><p>내가 속해있던 팀은 기존의 Spring + MyBatis 에서 Spring + JPA 를 적용하여 새로 프로젝트를 구성하였고 개발은 그럭저럭 마무리가 코 앞으로 다가왔다.</p><p>이때 쯤 신기술이 유행하고 있었는데 ~</p><blockquote><p>ECMAScript, React</p></blockquote><p>React 라는 녀석과 함께 ES6 의 유혹은 매우 강렬했다.</p><p>개발자들의 일종의허세끼인 “신기술이면 우왕 굿” 하는 <a href="https://lazygyu.net/blog/hype_driven_development">설레발 주도 개발</a>에 푹 빠진 것도 있었고, 현재 팀 내에서 사용하고 있는 기술이 낙후되었다는 생각을 해오던 터라, 써보고 싶은 마음이 요동쳤다.</p><p>사실 난 이 전까지는 JavaScript 의 Source to Source Compile 에 대한 거부감이 상당했고 그동안 별 불편함을 느끼지 못해 그냥 무시해왔지만, 한번 맛을 들이고 나니 이놈들은 끊을 수 없는 콜라같은 마력을 뿜어냈다</p><p>선행 학습을 며칠간 진행하고 관련 스터디와 예제 코드를 몇번 직접 작성해 보고 더욱 그런 느낌이 들었다.</p><p>이건 바로 적용해야돼!!</p><h2 id="기존-구조는-AMD-Handlebars"><a href="#기존-구조는-AMD-Handlebars" class="headerlink" title="기존 구조는 AMD + Handlebars"></a>기존 구조는 AMD + Handlebars</h2><p>하지만 기존에 완성되어 가던 프로젝트는 프로젝트 초기에 열심히 나름대로 세팅한 AMD 기반으로 동적으로 서버에서 Handlebars 컴파일 된 HTML 을 로드하고 그것을 화면에 innerHTML 등으로 붙여넣어 처리하는 구조였다.</p><p>동적으로 컨텐트와 그에 맞는 스크립트를 로딩하는 간단한 프레임워크였는데, 간간히 발생하는 모듈 Timeout 만 아니면 나름 잘 동작했다.</p><p>뭐 요약하면, Rouka Framework 0.0.1 정도 되려나.</p><p>간단히 소개하면 이런 구조다.</p><ol><li>hash url 기반의 SPA 다</li><li>컨텐츠가 요청되면 서버에서는 server side의 handlebars 를 사용하여 완성된 html을 응답한다.</li><li>그 응답 html 의 루트 엘리먼트에는 data-controller 라는 속성이 optional 로 있다.</li><li>그 속성은 실제 js 파일의 경로이며 require(경로) 를 통해 실제 그 컨텐츠가 사용할 Controller.js 를 동적 로딩한다</li><li>그 컨트롤러 파일은 로딩된 컨텐츠의 엘리먼트 레퍼런스를 가지고 UI의 이벤트 및 초기화를 수행한다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewEL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 동적 디스플레이 뷰 영역 반환</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTML 컨텐트 생성</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createContentWrapper</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wrap = <span class="built_in">document</span>.createElement(<span class="string">&#x27;DIV&#x27;</span>);</span><br><span class="line">    wrap.innerHTML(html);</span><br><span class="line">    getViewEL().appendChild(wrap);</span><br><span class="line">    <span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 이 부분이 핵심.</span></span><br><span class="line"><span class="comment"> * 컨트롤러 속성을 가져와서 해당 컨트롤러 모듈을 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadController</span>(<span class="params">wrap</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params"> resolve </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> contentEl = wrap.querySelect(<span class="string">&#x27;[data-controller]&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!contentEl) <span class="keyword">return</span> resolve(contentEl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> controllerPath = contentEl.dataset.controller</span><br><span class="line">        <span class="keyword">if</span>(!controllerPath) <span class="keyword">return</span> resolve(contentEl);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">require</span>([<span class="string">&#x27;controller/&#x27;</span> + controllerPath], <span class="function"><span class="keyword">function</span>(<span class="params">Controller</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> controller = <span class="keyword">new</span> Controller(contentEl, controllerPath);</span><br><span class="line">            controller.execute();</span><br><span class="line">            resolve(contentEl);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reportError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...컨트롤러 에러 보고</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...서버에 컨텐트 요청</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadContents</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    ajax(path)</span><br><span class="line">        .then(wrapContent)</span><br><span class="line">        .then(loadController)</span><br><span class="line">        .catch(reportError)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 새 페이지 요청</span></span><br><span class="line">loadContents(<span class="string">&#x27;/where/are/you&#x27;</span>);</span><br></pre></td></tr></table></figure><p>글을 읽다보면, 이 코드가 나중에 어떻게 바뀌는지 보게 될 것이다.</p><p>실제 코드는 이보다 훨씬 여러 상황을 고려했고, pre, post 등의 Hook 과 Attribute-Auto-Event-Bind 기능이 붙어있지만 뭐 이 글에선 중요한게 아니니</p><h2 id="개별-파일을-일일히-컴파일"><a href="#개별-파일을-일일히-컴파일" class="headerlink" title="개별 파일을 일일히 컴파일"></a>개별 파일을 일일히 컴파일</h2><p>이 상황에서 나는 ES6의 매력에 빠져 Babel 을 사용하여 ES6/React 를 적용하기 시작한다.</p><p>처음에는 Webpack 이 그리 정돈되지도 않았고, 학습이 좀 어려워(라는 핑계로) 개별 파일을 <a href="https://facebook.github.io/react/jsx-compiler.html">jsx 컴파일러 (Facebook 에서 제공하던 ES6/React 컴파일러. 지금은 Deprecated 되었다)</a> 를 사용하였다.</p><p>그리고 일일히 파일 하나하나를 트랜스파일하여 js 를 두개를 커밋하였는데, 이 과정에서 일어나는 비효율성은 엄청났지만 마침내 작성된 ES6/React 의 코드의 결과물은 나에게 멋지게만 보였다.</p><p><img src="/asset/mywow.jpg" alt="wow"></p><h3 id="IntelliJ-File-Watcher"><a href="#IntelliJ-File-Watcher" class="headerlink" title="IntelliJ File Watcher!"></a>IntelliJ File Watcher!</h3><p>하지만 매번 커맨드라인으로 일일히 컴파일하는 작업은 고역이었고, 실수라도 컴파일하지 않은 코드를 올리는 순간 클라이언트에서 사용할 수 없는 문법 오류가 속출했다. 실수로 올라간 트랜스파일되지 않은 상태로 ES6 이나 JSX 문법을 사용한 파일을 구동하면 브라우저가 이해하지 못하는 것이었다.</p><p>이런 도중에 팀 동료의 도움을 받아 <a href="https://www.jetbrains.com/help/idea/2017.1/using-file-watchers.html">Intellij 의 File Watcher</a>를 추가하여 코딩과 동시에 Transpiling 되는 기능을 적용했다.</p><p>별도로 커맨드라인을 수행할 필요도, js 파일을 생성할 필요도 없이 jsx 파일만 코딩하면 자동으로 js 파일이 트랜스파일링되어 생기는 점은 너무 편했고, 이내 이 툴로 드디어 production 에 몇몇 기능을 개발하여 적용하게 되었다.</p><p>하지만 이건 불행의 전주곡의 시작이었다.</p><h3 id="괴롭다"><a href="#괴롭다" class="headerlink" title="괴롭다.."></a>괴롭다..</h3><p><img src="/asset/otl.jpg" alt="어째 잘못된 길을 든듯한..."></p><p>한계가 매우 빠르게 느껴졌다.<br>크게는 다음과 같은 것들이 막 앞통수 뒤통수를 서라운드로 타격하기 시작했다.</p><p>그 중 크리티컬 히트를 자주 터뜨리는 녀석들은 다음과 같았다.</p><ul><li>개별 컴파일로 인한 기반 코드가 모든 파일에 삽입. (modules, createClass 등의 유틸성 코드 등)</li><li>OS 및 로컬 Babel, Jsx 컴파일러 버전, Babel 플러그인 설정마다 미묘하게 다른 코드 생성</li><li>컴파일 된 파일을 실수로 Commit 하지 않으면 장애로 연결되는 등의 소스파일 이중관리</li><li>다량의 파일 변경 이력을 pull, checkout 등을 통해 겪을 경우 intellij 가 file watcher 과부하로 intellij 가 수분(심하면 5분이상)정도 멈춤</li></ul><p>이대로는 더이상 개발이 힘들어졌고, 나는 결국 애써 외면하던 외부 Source to Source Compile 도구를 찾게 되었다.</p><h3 id="Webpack-amp-Browserify"><a href="#Webpack-amp-Browserify" class="headerlink" title="Webpack &amp; Browserify"></a>Webpack &amp; Browserify</h3><p>정확히 말하면 Source to Source Compiler 를 사용한 번들 도구 (bundle tool)를 찾았다.</p><p>위의 크리티컬한 이슈를 처리하기 위해서는 어쩔 수 없이 source 전체적인 번들 및 변환이 필요했기 떄문이다.<br>또한 <a href="https://www.jetbrains.com/help/idea/2017.1/using-file-watchers.html">Intellij 의 File Watcher</a> 가 지원하던 개발의 편의성 또한 필요했다</p><p>소스를 고칠때마다 매번 수동으로 컴파일하기는 너무 번거로웠다.</p><p>기본적인 Source to Source Compile 이 동작하고, 번들링 기능에, 가급적 소스를 고칠 때 자동으로 백그라운드에서 시스템이 자동으로 최신 내역을 Compile 하는 Watch 기능은 없어서는 안됐다.</p><p>찾아보니 두개가 있었다.</p><ul><li>Webpack</li><li>Browserify</li></ul><blockquote><p>이 둘 관련으로 좋은 글 하나 링크한다.<br><a href="http://blog.namangoel.com/browserify-vs-webpack-js-drama">Browserify VS Webpack - JS Drama</a></p></blockquote><h4 id="Browserify"><a href="#Browserify" class="headerlink" title="Browserify"></a>Browserify</h4><p><a href="http://browserify.org/">Browserify</a> 는 NPM 생태계의 모듈들을 브라우저에서 사용하는 것을 목표로 하는 도구다.</p><p>코드를 CommonJS 문법으로 작성해두면 npm 의 모듈들을 바로 브라우저 환경에서 돌려볼 수 있고, Watchify, Factor Bundle, deAMDFy 등의 도구로 파일 감시, 멀티 번들, AMD 지원등이 가능하다.</p><p>제일 좋은 점은 아주 적은 설정으로 바로 시작할 수 있다는 점이지만, 다른 Task 도구를 사용하지 않으면 사용이 조금 불편할 수 있어서 추가적인 Task Runner(주로 <a href="http://gulpjs.com/">Gulp</a>) 설정이 들어가게 된다.</p><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p><a href="https://webpack.github.io/">Webpack</a> 은 Browserify 와는 다르게, 혼자서 할 수 있는 일이 거의 없다.</p><p>대부분 별도의 loader 라 부르는 모듈과 그 모듈을 적용할 대상을 지정해주는 설정을 같이 요구한다.</p><p>commonjs 를 사용하려면 babel-loader 를 설치하고 설정해야 하며, React 를 사용하려면 babel-loader 의 설정에 react 관련 플러그인의 추가 및 설정이 필요하다.</p><p>다만 webpack 은 정적 리소스까지도 다룰 수 있는 loader 를 제공하며, hot-loading 등의 강력한 기능까지 붙여볼 수 있다.</p><p>별도 Task Runner (gulp 등) 없이 혼자서도 전부 할 수 있는 것도 장점이다.</p><h2 id="인생은-실전"><a href="#인생은-실전" class="headerlink" title="인생은 실전"></a>인생은 실전</h2><p>선택에는 고민자체가 필요없었다.</p><p>NodeJS 모듈을 만들것도 아니고, 정적 파일 관리까지 지원하며 부가적인 기능들이 더욱 막강한 Webpack 으로 정했다.</p><p>먼저 간단한 Webpack 을 학습하기 위해 bolierplate 코드를 받아서 이리저리 변경해보았다.</p><p><a href="https://github.com/geniuscarrier/webpack-boilerplate">boilerplate</a></p><p>역시나 모든 툴들이나 신기술이 그렇듯 hello world 수준의 사용법은 너무나 간단하고 쉬웠다.</p><p>대충 학습을 끝내고 바로 프로젝트에 적용해보기 시작했다.</p><p>예상대로 실제 프로젝트,<br>그리고 이제 어느정도 커져버려서 꽤나 규모가 있는 프로젝트에는 문서대로의 친절함따윈 없었다.</p><p>나는 야생의 아마존을 서성이는 모든게 두려운 새끼 고양이가 된 느낌을 받기 시작했다.</p><p>기존에 사용하던 AMD 툴인 requirejs 를 너무 헤비하게 쓰고 있었던 것이다.</p><p>path 의 정리도 엉망에 controller 의 로딩이 순식간에 전부 작업분으로 남아버렸고, commonjs, amd, es6 모듈은 서로 충돌하기 바빴다.<br>모든게 어우러져 새빨간 컴파일 오류가 작렬했다.</p><p>내용이 길어져 <a href="/2017/05/14/convert-legacy-to-webpack-bundle-2/">2부</a>로 나눈다.</p>]]></content>
    
    
    <summary type="html">개고생과 노가다, 그리고 고독</summary>
    
    
    <content src="https://blog.javarouka.me/images/react.png" type="image"/>
    
    
    <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
    <category term="javascript" scheme="https://blog.javarouka.me/tags/javascript/"/>
    
    <category term="Handlebars" scheme="https://blog.javarouka.me/tags/handlebars/"/>
    
    <category term="webpack" scheme="https://blog.javarouka.me/tags/webpack/"/>
    
    <category term="개고생" scheme="https://blog.javarouka.me/tags/%EA%B0%9C%EA%B3%A0%EC%83%9D/"/>
    
  </entry>
  
</feed>
